---
name: daml-audit
description: "Advanced DAML and Canton Network auditing skill. Use when: (1) Reviewing DAML templates for authorization, privacy, or logic vulnerabilities, (2) Auditing Canton Network participant configurations or domain topology, (3) Reviewing cross-chain bridge logic between Canton and Ethereum/EVM chains, (4) Assessing DAML contract lifecycle security (create, exercise, archive), (5) Evaluating privacy model correctness and stakeholder visibility. Triggers on keywords: DAML, daml, Canton, Canton Network, Daml template, signatory, observer, controller, choice, contract key, divulgence, sub-transaction privacy, participant, domain, synchronization."
---

# Advanced DAML & Canton Network Audit Skill

DAML is a smart contract language with a fundamentally different security model than Solidity/EVM. It uses a permissioned, privacy-first model where visibility, authorization, and contract lifecycle are enforced at the language level. This skill covers DAML-specific vulnerability patterns that general smart contract audits miss entirely.

---

## 1. Authorization Model Audit

DAML's authorization is based on **signatories**, **observers**, and **controllers**. Mistakes here are the #1 source of DAML vulnerabilities.

### Checklist

**Signatory Analysis**
- [ ] Every template has the minimum necessary signatories — no more, no less
- [ ] Signatories cannot be tricked into authorizing unintended state transitions
- [ ] No template allows a party to become signatory without explicit consent
- [ ] Multi-party signatories are intentional (both parties must authorize creation)

**Controller Analysis**
- [ ] Every choice has the correct controller — who can exercise it?
- [ ] No choice grants `controller party` where `party` is an untrusted input
- [ ] Consuming choices (the default) are intentional — does exercising archive the contract?
- [ ] Non-consuming choices are explicitly marked and justified
- [ ] No choice allows a controller to extract value without proper authorization

**Observer Analysis**
- [ ] Observers cannot see contracts they shouldn't (information leakage)
- [ ] Observer lists are not unbounded (performance and privacy risk)
- [ ] No sensitive data exposed to observers who only need the contract's existence

### Common Vulnerabilities

```
VULN-AUTH-001: Unauthorized Choice Exercise
─────────────────────────────────────────
BAD:
  template UnsafeTransfer with
    owner : Party
    recipient : Party
    amount : Decimal
  where
    signatory owner
    controller recipient can        -- WRONG: recipient controls transfer
      Accept : ContractId Asset
        do create Asset with owner = recipient; amount

GOOD:
  template SafeTransfer with
    owner : Party
    recipient : Party
    amount : Decimal
  where
    signatory owner
    observer recipient
    controller owner can            -- Owner initiates
      Execute : ContractId Asset
        do create Asset with owner = recipient; amount
    controller recipient can
      Reject : ()                   -- Recipient can only reject
        do return ()
```

```
VULN-AUTH-002: Missing Signatory on State Change
─────────────────────────────────────────────────
BAD:
  template Token with
    issuer : Party
    holder : Party
    amount : Decimal
  where
    signatory issuer                -- Only issuer signs
    controller holder can
      Transfer : ContractId Token
        with newHolder : Party
        do create this with holder = newHolder
        -- PROBLEM: issuer never consented to newHolder

GOOD:
  -- Use a propose/accept pattern (two-step)
  template TokenTransferProposal with
    issuer : Party
    holder : Party
    newHolder : Party
    amount : Decimal
  where
    signatory holder
    observer newHolder, issuer
    controller newHolder can
      AcceptTransfer : ContractId Token
        do create Token with issuer; holder = newHolder; amount
```

---

## 2. Privacy & Visibility Audit

DAML's privacy model is its biggest differentiator and its most subtle source of bugs. Contracts are only visible to stakeholders (signatories + observers).

### Checklist

**Divulgence Analysis**
- [ ] No unintended divulgence through choice exercise (when a choice fetches another contract, the actor sees it)
- [ ] Divulgence chains are mapped — exercise A fetches B which fetches C — who sees what?
- [ ] No sensitive contract IDs passed as choice arguments to untrusted parties

**Sub-transaction Privacy**
- [ ] Choices that create sub-transactions properly scope visibility
- [ ] No party can reconstruct private sub-transactions from the contracts they see
- [ ] Confirm that Canton's sub-transaction privacy is enabled for sensitive workflows

**Data Minimization**
- [ ] Templates don't store data that stakeholders shouldn't see
- [ ] Contracts split appropriately — public metadata separate from private details
- [ ] No PII or sensitive financial data stored in observer-visible fields

### Privacy Vulnerability Patterns

```
VULN-PRIV-001: Divulgence via Fetch
────────────────────────────────────
template Secret with
    owner : Party
    secretData : Text
  where
    signatory owner

template Processor with
    processor : Party
    owner : Party
  where
    signatory processor
    controller processor can
      Process : Text
        with secretCid : ContractId Secret
        do secret <- fetch secretCid    -- DIVULGES Secret to processor!
           return secret.secretData

FIX: Use a disclosure pattern where the owner explicitly shares
     data via a separate choice, or redesign so the processor
     never needs to fetch the raw secret.
```

```
VULN-PRIV-002: Observer Information Leakage
────────────────────────────────────────────
BAD:
  template Invoice with
    vendor : Party
    buyer : Party
    auditor : Party          -- observer
    amount : Decimal
    internalCostBasis : Decimal  -- auditor can see vendor's margins!
  where
    signatory vendor
    observer buyer, auditor

GOOD:
  -- Split into two contracts
  template Invoice with           -- auditor sees this
    vendor : Party
    buyer : Party
    auditor : Party
    amount : Decimal
  where
    signatory vendor
    observer buyer, auditor

  template InvoiceCost with       -- only vendor sees this
    vendor : Party
    invoiceCid : ContractId Invoice
    internalCostBasis : Decimal
  where
    signatory vendor
```

---

## 3. Contract Lifecycle Audit

### Checklist

**Creation Guards**
- [ ] `ensure` clauses validate all invariants at creation time
- [ ] No template can be created with invalid state (zero amounts, empty parties, self-referential signatories)
- [ ] Numeric fields have bounds checking (no negative amounts, no overflow)

**Archive Safety**
- [ ] Consuming choices don't destroy value (assets must be re-created or settled)
- [ ] No "rug pull" patterns — a party archiving contracts holding others' value
- [ ] Archive-and-recreate patterns preserve all invariants

**Contract Key Safety**
- [ ] Contract keys are unique and deterministic
- [ ] `lookupByKey` results are handled — contract may not exist
- [ ] No TOCTOU (time-of-check-time-of-use) between `lookupByKey` and `fetchByKey`
- [ ] Key maintainers are correct (must be a subset of signatories)

### Lifecycle Vulnerability Patterns

```
VULN-LIFE-001: Missing Ensure Clause
─────────────────────────────────────
BAD:
  template Vault with
    owner : Party
    balance : Decimal
  where
    signatory owner
    -- No ensure! Can create with negative balance

GOOD:
  template Vault with
    owner : Party
    balance : Decimal
  where
    signatory owner
    ensure balance >= 0.0
```

```
VULN-LIFE-002: Value Destruction on Archive
────────────────────────────────────────────
BAD:
  controller admin can
    EmergencyShutdown : ()
      do return ()    -- Archives the contract, all locked value is gone

GOOD:
  controller admin can
    EmergencyShutdown : ContractId Refund
      do create Refund with
           recipient = holder
           amount = balance    -- Value is preserved in a refund contract
```

```
VULN-LIFE-003: Contract Key Race Condition
───────────────────────────────────────────
BAD:
  controller operator can
    ProcessIfExists : Optional (ContractId Result)
      with assetKey : (Party, Text)
      do mbAsset <- lookupByKey @Asset assetKey
         case mbAsset of
           None -> return None
           Some cid -> do
             -- Between lookup and fetch, contract could be archived
             asset <- fetch cid    -- May fail!
             result <- exercise cid Process
             return (Some result)

GOOD:
  -- Use exerciseByKey or fetchByKey directly with error handling
  controller operator can
    ProcessIfExists : Optional (ContractId Result)
      with assetKey : (Party, Text)
      do try do
              result <- exerciseByKey @Asset assetKey Process
              return (Some result)
         catch
           _ -> return None
```

---

## 4. Canton Network Specific Audit

### Participant & Domain Topology

- [ ] Participant nodes have correct party-to-participant mappings
- [ ] Domain connectivity matches business requirements (who talks to whom)
- [ ] Sequencer configuration ensures proper ordering guarantees
- [ ] Mediator nodes properly configured for transaction confirmation

### Cross-Chain Bridge Security (Canton ↔ Ethereum)

This is critical for protocols bridging Canton's tokenized assets to EVM chains.

- [ ] Bridge contract on Canton side has proper multi-signatory authorization
- [ ] Lock/mint pattern: Canton-side lock is atomic with EVM-side mint
- [ ] Burn/unlock pattern: EVM-side burn is verified before Canton-side unlock
- [ ] Bridge relayer cannot forge Canton transaction confirmations
- [ ] Timeout/expiry mechanism for stuck cross-chain transactions
- [ ] No double-spend possible across the bridge (Canton asset locked while EVM asset exists)
- [ ] Oracle/attestation mechanism for cross-chain state verification
- [ ] Canton commitment proofs are verified on-chain (not just relayer signatures)

### Canton-Specific Configuration Audit

- [ ] Topology transactions are properly authorized
- [ ] Participant pruning configured (storage management)
- [ ] Domain time model configured with appropriate skew tolerance
- [ ] ACS (Active Contract Store) snapshot consistency
- [ ] Journal/event log retention appropriate for compliance
- [ ] gRPC TLS enabled between all nodes
- [ ] Admin API not exposed externally

---

## 5. DAML Testing Patterns

### Script-Based Testing (Daml Script)

```daml
testTransferAuthorization : Script ()
testTransferAuthorization = script do
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  mallory <- allocateParty "Mallory"

  -- Alice creates a token
  tokenCid <- submit alice do
    createCmd Token with
      issuer = alice
      holder = alice
      amount = 100.0

  -- Mallory should NOT be able to transfer Alice's token
  submitMustFail mallory do
    exerciseCmd tokenCid Transfer with newHolder = mallory

  -- Alice CAN transfer to Bob
  newTokenCid <- submit alice do
    exerciseCmd tokenCid Transfer with newHolder = bob

  -- Verify Bob is now the holder
  Some token <- queryContractId bob newTokenCid
  assert (token.holder == bob)

  return ()
```

### Key Test Categories for DAML Audits

1. **Authorization tests**: Every choice must have a test proving unauthorized parties are rejected (`submitMustFail`)
2. **Invariant tests**: Create contracts at boundary conditions, verify `ensure` rejects invalid state
3. **Lifecycle tests**: Full create → exercise → archive flows, verify no value loss
4. **Privacy tests**: Verify party visibility — query as each party, confirm they see only what they should
5. **Negative tests**: Attempt every forbidden operation, confirm failure

### Test Template

```daml
-- For each template, test:
testTemplateName : Script ()
testTemplateName = script do
  -- Setup parties
  parties <- setupParties

  -- 1. CREATION: Valid creation succeeds
  cid <- submit party do createCmd ...
  
  -- 2. CREATION: Invalid creation fails (ensure clause)
  submitMustFail party do createCmd ... with invalidField = badValue
  
  -- 3. AUTHORIZATION: Correct controller succeeds
  submit authorizedParty do exerciseCmd cid ChoiceName with ...
  
  -- 4. AUTHORIZATION: Wrong party fails
  submitMustFail unauthorizedParty do exerciseCmd cid ChoiceName with ...
  
  -- 5. LIFECYCLE: Post-exercise state is correct
  contracts <- query @TemplateName party
  assert (length contracts == expectedCount)
  
  -- 6. PRIVACY: Unauthorized party cannot see contract
  invisible <- query @TemplateName unauthorizedParty
  assert (null invisible)
```

---

## 6. Severity Classification for DAML

| Level | DAML-Specific Examples |
|-------|----------------------|
| CRITICAL | Unauthorized party can exercise choice that moves value; bridge allows double-spend; missing signatory enables unilateral asset creation |
| HIGH | Divulgence exposes private financial data; missing ensure allows invalid state; consuming choice destroys locked value |
| MEDIUM | Unnecessary observers see contract metadata; contract keys not optimally structured; verbose divulgence chains |
| LOW | Style issues (ensure could be stricter); missing helper templates; suboptimal contract splitting |
| INFO | Documentation gaps; test coverage suggestions; Canton config optimization |

---

## Output Format

```markdown
## DAML Finding [ID]: [Title]
- **Severity**: CRITICAL / HIGH / MEDIUM / LOW / INFO
- **Category**: Authorization / Privacy / Lifecycle / Bridge / Canton Config
- **Template**: `Module.TemplateName`
- **Choice** (if applicable): `ChoiceName`
- **Description**: What the vulnerability is
- **Impact**: What an attacker or unauthorized party could do
- **DAML Code (Vulnerable)**:
  ```daml
  [relevant snippet]
  ```
- **DAML Code (Fixed)**:
  ```daml
  [corrected snippet]
  ```
- **Test Case**: Script that demonstrates the vulnerability
- **References**: Daml documentation links, Canton security docs
```
