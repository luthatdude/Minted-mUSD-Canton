# Secret templates for Canton deployment
# These are TEMPLATES — do NOT commit real credentials.
#
# PRODUCTION: Use External Secrets Operator (see external-secrets.yaml)
#   ExternalSecret CRDs in external-secrets.yaml pull credentials from
#   AWS Secrets Manager at runtime. Apply those instead of this file.
#
# DEVELOPMENT ONLY — create secrets manually:
#   kubectl create secret generic postgres-credentials \
#     --namespace=musd-canton \
#     --from-literal=username=canton_user \
#     --from-literal=password=<GENERATE_STRONG_PASSWORD>
#
#   kubectl create secret tls canton-tls \
#     --namespace=musd-canton \
#     --cert=path/to/tls.crt \
#     --key=path/to/tls.key
#
#   kubectl create secret generic canton-tls \
#     --namespace=musd-canton \
#     --from-file=tls.crt=path/to/tls.crt \
#     --from-file=tls.key=path/to/tls.key \
#     --from-file=ca.crt=path/to/ca.crt
#
# Removed placeholder values to prevent accidental deployment with defaults.
# Secrets MUST be created via kubectl, External Secrets Operator, or Vault before deployment.
# See: k8s/canton/external-secrets.yaml for production configuration.
---
apiVersion: v1
kind: Secret
metadata:
  name: postgres-credentials
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: postgres
    app.kubernetes.io/component: database
  annotations:
    kubernetes.io/description: "REQUIRED: Create via kubectl create secret - see comments above"
    # INFRA-M-11: Key rotation policy for database credentials.
    # Rotation schedule: Every 90 days (quarterly).
    # Rotation method: Update in AWS Secrets Manager; ExternalSecret will sync automatically.
    # Manual rotation: kubectl create secret generic postgres-credentials --dry-run=client -o yaml | kubectl apply -f -
    # Post-rotation: Restart Canton participant pods to pick up new credentials.
    musd.io/rotation-schedule: "every-90-days"
    musd.io/rotation-method: "aws-secrets-manager-auto-rotation"
    musd.io/last-rotated: "YYYY-MM-DD — update after each rotation"
    musd.io/rotation-owner: "platform-team"
type: Opaque
# Empty stringData - deployment will fail until secrets are properly configured
# This is intentional to prevent using default credentials in production
stringData: {}
---
# TLS certificates for Canton Ledger API
#
# INFRA-M-12: SECURITY — Do NOT share TLS private keys across environments.
# Each environment (dev, staging, production) MUST have unique certificates
# generated by a per-environment CA or cert-manager issuer.
#
# Self-signed certificates are acceptable ONLY for local development.
# For staging/production, use cert-manager with one of:
#   - Let's Encrypt (public endpoints)
#   - Internal CA (private/inter-service endpoints)
#   - AWS Private CA (via AWS PCA Issuer for cert-manager)
#
# Recommended cert-manager setup:
#   apiVersion: cert-manager.io/v1
#   kind: Certificate
#   metadata:
#     name: canton-tls
#     namespace: musd-canton
#   spec:
#     secretName: canton-tls
#     issuerRef:
#       name: internal-ca-issuer  # Per-environment issuer
#       kind: ClusterIssuer
#     dnsNames:
#       - canton-participant.musd-canton.svc.cluster.local
#     duration: 8760h    # 1 year
#     renewBefore: 720h  # Renew 30 days before expiry
#     privateKey:
#       algorithm: ECDSA
#       size: 256
apiVersion: v1
kind: Secret
metadata:
  name: canton-tls
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: canton-participant
    app.kubernetes.io/component: tls
  annotations:
    # INFRA-M-11: TLS certificate rotation policy.
    # Rotation schedule: Every 365 days or upon compromise.
    # Preferred method: cert-manager with auto-renewal 30 days before expiry.
    # Manual rotation: Generate new cert/key, update secret, perform rolling restart.
    musd.io/rotation-schedule: "every-365-days"
    musd.io/rotation-method: "cert-manager-auto-renewal"
    musd.io/last-rotated: "YYYY-MM-DD — update after each rotation"
    musd.io/rotation-owner: "security-team"
    # INFRA-M-12: Per-environment unique certificates required.
    # NEVER copy private keys between environments.
    musd.io/cert-scope: "per-environment-unique"
    musd.io/cert-manager-issuer: "internal-ca-issuer"
    musd.io/self-signed-allowed: "development-only"
type: kubernetes.io/tls
data:
  tls.crt: ""  # base64-encoded certificate chain — MUST be unique per environment
  tls.key: ""  # base64-encoded private key — NEVER shared across environments
  ca.crt: ""   # base64-encoded CA certificate
---
# JSON API credentials referenced by participant-deployment.yaml
# This secret was missing, causing deployment to fail
#
# Create via:
#   kubectl create secret generic json-api-credentials \
#     --namespace=musd-canton \
#     --from-literal=jwt-secret=<GENERATE_256_BIT_SECRET>
#
apiVersion: v1
kind: Secret
metadata:
  name: json-api-credentials
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: canton-participant
    app.kubernetes.io/component: json-api
  annotations:
    kubernetes.io/description: "REQUIRED: JWT secret for JSON API authentication"
    # INFRA-M-11: JWT secret rotation policy.
    # Rotation schedule: Every 90 days.
    # Rotation method: Generate new 256-bit secret (openssl rand -base64 32),
    #   update in AWS Secrets Manager, ExternalSecret syncs automatically.
    # Impact: Active JWT tokens become invalid; services must re-authenticate.
    musd.io/rotation-schedule: "every-90-days"
    musd.io/rotation-method: "aws-secrets-manager-auto-rotation"
    musd.io/last-rotated: "YYYY-MM-DD — update after each rotation"
    musd.io/rotation-owner: "security-team"
type: Opaque
# Empty stringData - deployment will fail until secret is configured
# Generate a 256-bit secret: openssl rand -base64 32
stringData: {}
