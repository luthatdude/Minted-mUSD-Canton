# NGINX API Gateway Deployment
# Reverse proxy for the Daml JSON API with TLS termination and rate limiting.
# This is the ONLY component exposed to external traffic.
apiVersion: v1
kind: Service
metadata:
  name: nginx-proxy
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: nginx-proxy
    app.kubernetes.io/component: api-gateway
  annotations:
    # GCP: Reference a BackendConfig that attaches Cloud Armor security policy
    cloud.google.com/backend-config: '{"default": "nginx-waf-backend"}'
    cloud.google.com/neg: '{"ingress": true}'
    # AWS: Attach WAF WebACL for OWASP + DDoS protection
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
    service.beta.kubernetes.io/aws-load-balancer-cross-zone-load-balancing-enabled: "true"
    # AWS WAF: Set this to your WebACL ARN after creating it in AWS console
    # service.beta.kubernetes.io/aws-load-balancer-waf-acl-arn: "arn:aws:wafv2:REGION:ACCOUNT:regional/webacl/minted-waf/ID"
spec:
  type: LoadBalancer
  ## FIX HIGH-08: Restrict LoadBalancer source IPs to prevent proxy bypass.
  ## Replace with your actual Cloud Armor / WAF IP ranges and office CIDRs.
  ## Without this, attackers can hit the LoadBalancer directly, bypassing WAF rules.
  loadBalancerSourceRanges:
    - "10.0.0.0/8"        # Internal VPC only (default-deny external)
    # Add your Cloud Armor / WAF egress IPs here:
    # - "35.191.0.0/16"   # GCP health check ranges
    # - "130.211.0.0/22"  # GCP health check ranges
  ports:
    - name: https
      port: 443
      targetPort: 8443
      protocol: TCP
    - name: http-redirect
      port: 80
      targetPort: 8080
      protocol: TCP
  selector:
    app.kubernetes.io/name: nginx-proxy
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-proxy
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: nginx-proxy
    app.kubernetes.io/component: api-gateway
spec:
  replicas: 2  # Stateless — safe to scale horizontally
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxUnavailable: 1
      maxSurge: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: nginx-proxy
  template:
    metadata:
      labels:
        app.kubernetes.io/name: nginx-proxy
        app.kubernetes.io/component: api-gateway
    spec:
      serviceAccountName: nginx-proxy
      securityContext:
        runAsNonRoot: true
        runAsUser: 101   # nginx user in official image
        runAsGroup: 101
        fsGroup: 101
        seccompProfile:
          type: RuntimeDefault
      containers:
        - name: nginx
          # Pin nginx image to SHA256 digest for supply chain security
          # nginx 1.27.2-alpine - verify digest before deployment
          image: nginx@sha256:2140dad235c130ac861018a4e13a6bc8aea3a35f3a40e20c1b060d51a7efd250
          ports:
            - name: https
              containerPort: 8443
              protocol: TCP
            - name: http
              containerPort: 8080
              protocol: TCP
          resources:
            requests:
              cpu: 100m
              memory: 128Mi
            limits:
              cpu: 500m
              memory: 256Mi
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop: ["ALL"]
            readOnlyRootFilesystem: true
          volumeMounts:
            - name: nginx-config
              mountPath: /etc/nginx/nginx.conf
              subPath: nginx.conf
              readOnly: true
            - name: tls-certs
              mountPath: /etc/nginx/tls
              readOnly: true
            - name: tmp
              mountPath: /tmp
            - name: log
              mountPath: /var/log/nginx
            - name: cache
              mountPath: /var/cache/nginx
            - name: run
              mountPath: /var/run
          livenessProbe:
            httpGet:
              path: /nginx_status
              port: 8443
              scheme: HTTPS
            initialDelaySeconds: 5
            periodSeconds: 10
            timeoutSeconds: 3
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /nginx_status
              port: 8443
              scheme: HTTPS
            initialDelaySeconds: 3
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
      volumes:
        - name: nginx-config
          configMap:
            name: nginx-config
        - name: tls-certs
          secret:
            secretName: nginx-tls
        - name: tmp
          emptyDir:
            sizeLimit: 50Mi
        - name: log
          emptyDir:
            sizeLimit: 100Mi
        - name: cache
          emptyDir:
            sizeLimit: 50Mi
        - name: run
          emptyDir:
            sizeLimit: 10Mi
      topologySpreadConstraints:
        - maxSkew: 1
          topologyKey: topology.kubernetes.io/zone
          whenUnsatisfiable: DoNotSchedule
          labelSelector:
            matchLabels:
              app.kubernetes.io/name: nginx-proxy
---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: nginx-proxy
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: nginx-proxy
automountServiceAccountToken: false
---
# PodDisruptionBudget — always keep at least 1 proxy running
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: nginx-proxy-pdb
  namespace: musd-canton
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: nginx-proxy
---
# Attaches a Cloud Armor security policy for Layer-7 WAF protection.
# Create the Cloud Armor policy first:
#   gcloud compute security-policies create minted-waf-policy \
#     --description "Minted Protocol WAF" \
#     --type CLOUD_ARMOR
#   gcloud compute security-policies rules create 1000 \
#     --security-policy minted-waf-policy \
#     --expression "evaluatePreconfiguredExpr('xss-v33-stable')" --action deny-403
#   gcloud compute security-policies rules create 1001 \
#     --security-policy minted-waf-policy \
#     --expression "evaluatePreconfiguredExpr('sqli-v33-stable')" --action deny-403
#   gcloud compute security-policies rules create 900 \
#     --security-policy minted-waf-policy \
#     --expression "evaluatePreconfiguredExpr('rce-v33-stable')" --action deny-403
apiVersion: cloud.google.com/v1
kind: BackendConfig
metadata:
  name: nginx-waf-backend
  namespace: musd-canton
spec:
  securityPolicy:
    name: minted-waf-policy
  logging:
    enable: true
    sampleRate: 1.0
  connectionDraining:
    drainingTimeoutSec: 30
