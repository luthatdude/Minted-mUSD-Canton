# Canton participant configuration and bootstrap script
# Mounted as ConfigMap into the Canton container
apiVersion: v1
kind: ConfigMap
metadata:
  name: canton-config
  namespace: musd-canton
  labels:
    app.kubernetes.io/name: canton-participant
    app.kubernetes.io/component: config
data:
  participant.conf: |
    canton {
      participants {
        musd_participant {
          storage {
            type = postgres
            config {
              dataSourceClass = "org.postgresql.ds.PGSimpleDataSource"
              properties = {
                serverName = ${?CANTON_DB_HOST}
                portNumber = ${?CANTON_DB_PORT}
                databaseName = ${?CANTON_DB_NAME}
                currentSchema = "participant"
                user = ${?CANTON_DB_USER}
                password = ${?CANTON_DB_PASSWORD}
                ssl = true
                # INFRA-M-01: Use verify-full to authenticate the PostgreSQL server certificate,
                # preventing MITM attacks. Requires the CA cert to be mounted at the path below.
                # The CA cert must be provisioned via cert-manager or external-secrets.
                sslmode = "verify-full"
                sslrootcert = "/etc/canton/tls/postgres-ca.crt"
              }
            }
            parameters {
              max-connections = 16
            }
          }

          ledger-api {
            port = 5011
            address = "0.0.0.0"

            # INFRA-M-12: TLS certificates MUST be unique per environment.
            # Use cert-manager to auto-provision per-environment certs.
            # NEVER use self-signed certs or shared keys in staging/production.
            tls {
              cert-chain-file = "/etc/canton/tls/tls.crt"
              private-key-file = "/etc/canton/tls/tls.key"
              trust-collection-file = "/etc/canton/tls/ca.crt"
            }

            # Rate limiting on the Ledger API level
            rate-limit {
              max-api-services-queue-size = 10000
              max-api-services-index-db-queue-size = 1000
              max-used-heap-space-percentage = 85
            }
          }

          admin-api {
            port = 5012
            address = "127.0.0.1"  # Admin API is localhost-only — never expose externally
            
            # Enable TLS client certificate authentication for Admin API
            # Requires mounting admin client certificates
            tls {
              cert-chain-file = "/etc/canton/tls/admin-tls.crt"
              private-key-file = "/etc/canton/tls/admin-tls.key"
              trust-collection-file = "/etc/canton/tls/admin-ca.crt"
              client-auth = {
                type = require
                admin-client {
                  cert-chain-file = "/etc/canton/tls/admin-client.crt"
                }
              }
            }
          }

          parameters {
            # Party allocation requires admin privileges
            manual-start = false
          }

          # Resource limits to prevent abuse
          engine {
            max-interpretor-stack-depth = 1000
            max-steps = 100000
          }
        }
      }

      monitoring {
        metrics {
          reporters = [{
            type = prometheus
            address = "0.0.0.0"
            port = 9090
          }]
        }
        health {
          server {
            address = "0.0.0.0"
            port = 8081
          }
        }
      }
    }

  init.canton: |
    // Bootstrap script: runs once on participant startup
    // Allocates the mUSD operator party and connects to the domain

    import com.digitalasset.canton.console._

    // Allocate the mUSD operator party (idempotent — returns existing if already allocated)
    val operatorParty = musd_participant.parties.enable(
      "mUSD-Operator",
      waitForDomain = DomainChoice.All
    )

    logger.info(s"mUSD Operator party: ${operatorParty}")

    // Connect to the Canton Network domain using environment-provided settings.
    // Required env vars on participant container:
    //   CANTON_DOMAIN_ALIAS (default: "canton-network")
    //   CANTON_DOMAIN_URL   (required in production)
    val domainAlias = sys.env.getOrElse("CANTON_DOMAIN_ALIAS", "canton-network")
    val domainUrl = sys.env.getOrElse("CANTON_DOMAIN_URL", "")
    if (domainUrl.isEmpty) {
      logger.error("CANTON_DOMAIN_URL is not set; refusing bootstrap without production domain connection")
      throw new IllegalStateException("CANTON_DOMAIN_URL is required")
    }
    musd_participant.domains.connect(domainAlias, domainUrl)
    logger.info(s"Connected participant to domain alias '${domainAlias}' at ${domainUrl}")

    logger.info("Canton participant bootstrap complete")
