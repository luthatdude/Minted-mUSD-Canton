module Minted.Protocol.V3 where

import DA.Time
import DA.Optional (fromOptional)
import DA.Action (foldlA)
import DA.Math (round)

-- ============================================================================
-- 1. ASSET LAYER (UTXO)
-- ============================================================================

template Asset
  with
    issuer : Party
    owner : Party
    symbol : Text
    amount : Decimal
  where
    signatory issuer, owner

    choice Asset_Transfer : ContractId Asset
      with newOwner : Party
      controller owner
      do create this with owner = newOwner

    choice Asset_Split : (ContractId Asset, ContractId Asset)
      with splitAmount : Decimal
      controller owner
      do
        assert (amount >= splitAmount)
        remaining <- create this with amount = amount - splitAmount
        split <- create this with amount = splitAmount
        return (remaining, split)

    -- Merge two assets of the same symbol back together
    choice Asset_Merge : ContractId Asset
      with otherCid : ContractId Asset
      controller owner
      do
        other <- fetch otherCid
        assert (other.symbol == symbol && other.owner == owner && other.issuer == issuer)
        archive otherCid
        create this with amount = amount + other.amount


-- ============================================================================
-- 2. ORACLE LAYER
-- ============================================================================

template PriceOracle
  with
    provider : Party
    symbol : Text
    priceInUsd : Decimal
    lastUpdated : Time
  where
    signatory provider
    key (provider, symbol) : (Party, Text)
    maintainer key._1


-- ============================================================================
-- 3. LIQUIDITY LAYER (DEX)
-- ============================================================================

template LiquidityPool
  with
    operator : Party
    collateralSymbol : Text
    musdSymbol : Text
    pricePerCollateral : Decimal
  where
    signatory operator

    -- Swaps mUSD (Debt Asset) for Collateral (Vault Asset)
    choice Swap_mUSD_For_Collateral : ContractId Asset
      with
        musdCid : ContractId Asset
        user : Party
      controller user
      do
        musd <- fetch musdCid
        assert (musd.symbol == musdSymbol)
        let collateralAmount = musd.amount / pricePerCollateral
        archive musdCid
        create Asset with issuer = operator, owner = user, symbol = collateralSymbol, amount = collateralAmount

    -- Swaps Collateral for mUSD (used during liquidation to convert seized collateral)
    choice Swap_Collateral_For_mUSD : ContractId Asset
      with
        collateralCid : ContractId Asset
        user : Party
      controller user
      do
        col <- fetch collateralCid
        assert (col.symbol == collateralSymbol)
        let musdAmount = col.amount * pricePerCollateral
        archive collateralCid
        create Asset with issuer = operator, owner = user, symbol = musdSymbol, amount = musdAmount


-- ============================================================================
-- 4. VAULT CONFIG
-- ============================================================================

data VaultConfig = VaultConfig
  with
    liquidationThreshold : Decimal   -- e.g. 1.5  = 150% min collateral ratio
    interestRateBps      : Decimal   -- e.g. 500  = 5% APR
    liquidationPenaltyBps : Decimal  -- e.g. 1000 = 10% penalty on seized collateral
    liquidationBonusBps  : Decimal   -- e.g. 500  = 5% keeper bonus from penalty
    closeFactorBps       : Decimal   -- e.g. 5000 = 50% max debt repayable per liquidation
    dustThreshold        : Decimal   -- e.g. 10.0 = vaults below 10 mUSD debt get fully liquidated
  deriving (Eq, Show)


-- ============================================================================
-- 5. LIQUIDATION RECEIPT (audit trail)
-- ============================================================================

template LiquidationReceipt
  with
    provider     : Party
    vaultOwner   : Party
    liquidator   : Party
    token        : Text
    debtRepaid   : Decimal
    collateralSeized : Decimal
    penaltyAmount    : Decimal
    keeperBonus      : Decimal
    protocolFee      : Decimal
    healthBefore     : Decimal    -- collateral ratio before liquidation
    healthAfter      : Decimal    -- collateral ratio after (0.0 if fully liquidated)
    isFullLiquidation : Bool
    timestamp    : Time
  where
    signatory provider
    observer vaultOwner, liquidator


-- ============================================================================
-- 6. VAULT LAYER (The CDP) — now with liquidation
-- ============================================================================

template Vault
  with
    provider : Party
    owner : Party
    token : Text
    collateralAmount : Decimal
    principalDebt : Decimal
    accruedInterest : Decimal
    lastAccrualTime : Time
    config : VaultConfig
  where
    signatory provider
    observer owner

    let
      -- Precision-safe Interest Math
      calcInterest (currentTime : Time) =
        let
          elapsedSeconds = intToDecimal (round (convertTimeToMicroseconds (subTime currentTime lastAccrualTime) / 1000000))
          yearInSeconds = 31536000.0
          interest = (principalDebt * config.interestRateBps * elapsedSeconds) / (10000.0 * yearInSeconds)
        in interest

      getTotalDebt (currentTime : Time) =
        principalDebt + accruedInterest + calcInterest currentTime

      getHealthRatio (currentTime : Time) (price : Decimal) =
        let totalDebt = getTotalDebt currentTime
        in if totalDebt <= 0.0
           then 999.0   -- no debt = perfectly healthy
           else (collateralAmount * price) / totalDebt

      isLiquidatable (currentTime : Time) (price : Decimal) =
        let ratio = getHealthRatio currentTime price
        in ratio < config.liquidationThreshold

    -- ----------------------------------------------------------------
    -- ATOMIC LEVERAGE CHOICE (unchanged)
    -- ----------------------------------------------------------------
    choice AdjustLeverage : (ContractId Vault, Optional (ContractId Asset))
      with
        initialCollateralCid : Optional (ContractId Asset)
        extraBorrowAmount : Decimal
        poolCid : ContractId LiquidityPool
        currentTime : Time
        oracleCid : ContractId PriceOracle
      controller owner
      do
        oracle <- fetch oracleCid
        assert (oracle.symbol == token && oracle.provider == provider)

        let totalDebtBefore = getTotalDebt currentTime

        addedAmt <- case initialCollateralCid of
          Some cid -> do
            asset <- fetch cid
            assert (asset.symbol == token && asset.owner == owner)
            archive cid
            return asset.amount
          None -> return 0.0

        (finalCollateral, finalDebt) <- if extraBorrowAmount > 0.0
          then do
            mUSDCid <- create Asset with
                issuer = provider, owner = owner, symbol = "mUSD", amount = extraBorrowAmount
            newCollateralCid <- exercise poolCid Swap_mUSD_For_Collateral with
                musdCid = mUSDCid, user = owner
            newCol <- fetch newCollateralCid
            archive newCollateralCid
            return (collateralAmount + addedAmt + newCol.amount, principalDebt + extraBorrowAmount)
          else
            return (collateralAmount + addedAmt, principalDebt)

        let
          totalValue = finalCollateral * oracle.priceInUsd
          minRequiredValue = (finalDebt + totalDebtBefore - principalDebt) / config.liquidationThreshold
        assertMsg "Insolvent: Leverage too high" (totalValue >= minRequiredValue)

        newVault <- create this with
          collateralAmount = finalCollateral
          principalDebt = finalDebt
          accruedInterest = totalDebtBefore - principalDebt
          lastAccrualTime = currentTime
        return (newVault, None)

    -- ----------------------------------------------------------------
    -- VOLUNTARY REPAY: owner pays down their own debt
    -- ----------------------------------------------------------------
    choice Vault_Repay : ContractId Vault
      with
        musdCid : ContractId Asset     -- mUSD asset the owner is burning to repay
        currentTime : Time
      controller owner
      do
        payment <- fetch musdCid
        assert (payment.symbol == "mUSD" && payment.owner == owner)
        archive musdCid

        let
          totalDebt = getTotalDebt currentTime
          repayAmount = min payment.amount totalDebt
          -- Apply repayment: interest first, then principal
          interestOwed = accruedInterest + calcInterest currentTime
          interestPaid = min repayAmount interestOwed
          principalPaid = repayAmount - interestPaid
          newInterest = interestOwed - interestPaid
          newPrincipal = principalDebt - principalPaid

        -- Refund overpayment
        when (payment.amount > repayAmount) do
          void $ create Asset with
            issuer = provider, owner = owner, symbol = "mUSD"
            amount = payment.amount - repayAmount

        create this with
          principalDebt = newPrincipal
          accruedInterest = newInterest
          lastAccrualTime = currentTime

    -- ----------------------------------------------------------------
    -- VOLUNTARY WITHDRAW: owner removes collateral (must stay healthy)
    -- ----------------------------------------------------------------
    choice Vault_WithdrawCollateral : (ContractId Vault, ContractId Asset)
      with
        withdrawAmount : Decimal
        currentTime : Time
        oracleCid : ContractId PriceOracle
      controller owner
      do
        oracle <- fetch oracleCid
        assert (oracle.symbol == token && oracle.provider == provider)
        assert (withdrawAmount > 0.0 && withdrawAmount <= collateralAmount)

        let
          totalDebt = getTotalDebt currentTime
          remainingCollateral = collateralAmount - withdrawAmount
          remainingValue = remainingCollateral * oracle.priceInUsd
          minRequired = totalDebt * config.liquidationThreshold

        assertMsg "Withdrawal would make vault undercollateralized"
          (totalDebt <= 0.0 || remainingValue >= minRequired)

        asset <- create Asset with
          issuer = provider, owner = owner, symbol = token, amount = withdrawAmount

        vault <- create this with
          collateralAmount = remainingCollateral
          accruedInterest = accruedInterest + calcInterest currentTime
          lastAccrualTime = currentTime

        return (vault, asset)

    -- ----------------------------------------------------------------
    -- LIQUIDATE: any party can liquidate an underwater vault
    -- ----------------------------------------------------------------
    --
    -- Flow:
    --   1. Liquidator provides mUSD to cover a portion of the debt
    --   2. Contract verifies vault is below liquidation threshold
    --   3. Collateral seized = debtRepaid * (1 + penalty) / oraclePrice
    --   4. Keeper bonus carved from the penalty; rest is protocol fee
    --   5. If remaining debt < dustThreshold, full liquidation is forced
    --   6. A LiquidationReceipt is created for the audit trail
    --   7. Returns: (Maybe new vault, collateral to liquidator, receipt)
    --
    choice Liquidate : (Optional (ContractId Vault), ContractId Asset, ContractId LiquidationReceipt)
      with
        liquidator   : Party
        musdCid      : ContractId Asset   -- mUSD the liquidator is putting up
        currentTime  : Time
        oracleCid    : ContractId PriceOracle
      controller liquidator
      do
        -- 1. Fetch oracle price
        oracle <- fetch oracleCid
        assert (oracle.symbol == token && oracle.provider == provider)
        let price = oracle.priceInUsd

        -- 2. Accrue interest and check health
        let
          totalDebt = getTotalDebt currentTime
          healthBefore = if totalDebt <= 0.0
                         then 999.0
                         else (collateralAmount * price) / totalDebt

        assertMsg "Vault is not liquidatable (health ratio above threshold)"
          (healthBefore < config.liquidationThreshold)

        -- 3. Validate liquidator's mUSD payment
        payment <- fetch musdCid
        assert (payment.symbol == "mUSD" && payment.owner == liquidator)
        archive musdCid

        -- 4. Compute max repayable debt (close factor)
        let
          maxRepayable = totalDebt * config.closeFactorBps / 10000.0
          debtToRepay = min payment.amount maxRepayable

        -- Refund excess mUSD to liquidator
        when (payment.amount > debtToRepay) do
          void $ create Asset with
            issuer = provider, owner = liquidator, symbol = "mUSD"
            amount = payment.amount - debtToRepay

        -- 5. Calculate collateral seizure with penalty
        let
          penaltyMultiplier = 1.0 + config.liquidationPenaltyBps / 10000.0
          collateralToSeize = min collateralAmount (debtToRepay * penaltyMultiplier / price)
          penaltyCollateral = collateralToSeize - (debtToRepay / price)
          keeperBonus = penaltyCollateral * config.liquidationBonusBps / (config.liquidationPenaltyBps)
          protocolFee = penaltyCollateral - keeperBonus

        -- 6. Determine if this is a full liquidation
        let
          remainingCollateral = collateralAmount - collateralToSeize
          -- Apply repayment: interest first, then principal
          interestOwed = accruedInterest + calcInterest currentTime
          interestPaid = min debtToRepay interestOwed
          principalPaid = debtToRepay - interestPaid
          remainingDebt = totalDebt - debtToRepay
          isFull = remainingDebt <= config.dustThreshold
                   || remainingCollateral <= 0.0

        -- 7. Transfer seized collateral to liquidator (includes their bonus)
        liquidatorCollateral <- create Asset with
          issuer = provider
          owner = liquidator
          symbol = token
          amount = collateralToSeize - protocolFee

        -- 8. Protocol fee goes to provider
        when (protocolFee > 0.0) do
          void $ create Asset with
            issuer = provider
            owner = provider
            symbol = token
            amount = protocolFee

        -- 9. Burn the repaid mUSD (debt reduction)
        -- The mUSD was already archived above — debt is reduced in the vault state.

        -- 10. Create or close the vault
        let
          healthAfter = if isFull || remainingDebt <= 0.0
                        then 0.0
                        else (remainingCollateral * price) / remainingDebt

        maybeVault <- if isFull
          then do
            -- Full liquidation: return any dust collateral to owner
            when (remainingCollateral > 0.0) do
              void $ create Asset with
                issuer = provider, owner = owner, symbol = token
                amount = remainingCollateral
            return None
          else do
            v <- create this with
              collateralAmount = remainingCollateral
              principalDebt = principalDebt - principalPaid
              accruedInterest = interestOwed - interestPaid
              lastAccrualTime = currentTime
            return (Some v)

        -- 11. Audit receipt
        receipt <- create LiquidationReceipt with
          provider
          vaultOwner = owner
          liquidator
          token
          debtRepaid = debtToRepay
          collateralSeized = collateralToSeize
          penaltyAmount = penaltyCollateral
          keeperBonus
          protocolFee
          healthBefore
          healthAfter
          isFullLiquidation = isFull
          timestamp = currentTime

        return (maybeVault, liquidatorCollateral, receipt)


-- ============================================================================
-- 7. VAULT MANAGER (Factory — The Rule Pattern)
-- ============================================================================
-- The Provider signs this once, allowing any party to create their own Vault.

template VaultManager
  with
    provider : Party
    defaultConfig : VaultConfig
  where
    signatory provider

    nonconsuming choice OpenVault : ContractId Vault
      with
        owner : Party
        token : Text
      controller owner
      do
        now <- getTime
        create Vault with
          provider
          owner
          token
          config = defaultConfig
          collateralAmount = 0.0
          principalDebt = 0.0
          accruedInterest = 0.0
          lastAccrualTime = now

    -- Admin: update default config for future vaults
    choice UpdateDefaultConfig : ContractId VaultManager
      with
        newConfig : VaultConfig
      controller provider
      do
        create this with defaultConfig = newConfig

    -- Admin: update config on an existing vault (migration)
    choice UpdateVaultConfig : ContractId Vault
      with
        vaultCid : ContractId Vault
        newConfig : VaultConfig
      controller provider
      do
        vault <- fetch vaultCid
        assert (vault.provider == provider)
        archive vaultCid
        create vault with config = newConfig


-- ============================================================================
-- 8. LIQUIDATION ENGINE (Keeper Coordination)
-- ============================================================================
-- Tracks liquidatable vaults, lets keepers claim them to avoid duplicate work.

data LiquidationStatus = Pending | Claimed | Executed | Cancelled
  deriving (Eq, Show)

template LiquidationOrder
  with
    provider  : Party
    vaultOwner : Party
    token     : Text
    keeper    : Optional Party
    status    : LiquidationStatus
    estimatedDebt : Decimal
    estimatedCollateral : Decimal
    createdAt : Time
  where
    signatory provider
    observer (optional [] (\k -> [k]) keeper)

    -- A keeper claims the right to liquidate
    choice ClaimOrder : ContractId LiquidationOrder
      with
        claimant : Party
      controller claimant
      do
        assert (status == Pending)
        create this with
          keeper = Some claimant
          status = Claimed

    -- Mark as executed after successful liquidation
    choice CompleteOrder : ContractId LiquidationOrder
      controller provider
      do
        assert (status == Claimed)
        create this with status = Executed

    -- Cancel if vault was repaid or no longer underwater
    choice CancelOrder : ContractId LiquidationOrder
      controller provider
      do
        assert (status == Pending || status == Claimed)
        create this with status = Cancelled
