-- BLE Protocol - Integration Test Script
-- Simulates full flow: Bank Position -> Attestation Request -> 3 Signatures -> Finalize
-- Run with: daml test

module Test where

import BLEProtocol
import DA.Time
import DA.Set qualified as Set
import Daml.Script

-- Test configuration
testCollateralRatio : Numeric 18
testCollateralRatio = 1.1  -- 110%

testAmount : Numeric 18
testAmount = 1000000.000000000000000000  -- 1M USD with 18 decimals

testCollateral : Numeric 18
testCollateral = 1100000.000000000000000000  -- 1.1M USD (110% of amount)

-- Full integration test
fullProtocolFlowTest : Script ()
fullProtocolFlowTest = script do
  -- Setup parties
  bank1 <- allocateParty "Bank1"
  bank2 <- allocateParty "Bank2"
  aggregator <- allocateParty "Aggregator"
  validator1 <- allocateParty "Validator1"
  validator2 <- allocateParty "Validator2"
  validator3 <- allocateParty "Validator3"
  validator4 <- allocateParty "Validator4"
  validator5 <- allocateParty "Validator5"

  let validators = [validator1, validator2, validator3, validator4, validator5]

  -- Get current time and set expiration
  now <- getTime
  let expiresAt = addRelTime now (hours 1)

  -- Step 1: Banks create equity positions
  debug "Step 1: Creating institutional equity positions..."

  position1Cid <- submit bank1 do
    createCmd InstitutionalEquityPosition with
      bank = bank1
      validatorGroup = validators
      aggregator = aggregator
      totalValue = 600000.000000000000000000  -- 600K USD
      referenceId = "BANK1-POS-001"
      lastUpdated = now

  position2Cid <- submit bank2 do
    createCmd InstitutionalEquityPosition with
      bank = bank2
      validatorGroup = validators
      aggregator = aggregator
      totalValue = 500000.000000000000000000  -- 500K USD
      referenceId = "BANK2-POS-001"
      lastUpdated = now

  debug "  Created 2 positions totaling 1.1M USD"

  -- Step 2: Aggregator creates attestation request
  debug "Step 2: Creating attestation request..."

  let payload = AttestationPayload with
        attestationId = "ATT-2024-001"
        globalCantonAssets = testCollateral
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = testAmount
        isMint = True
        nonce = 1
        chainId = 1  -- Ethereum mainnet
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = validators
      payload = payload
      positionCids = [position1Cid, position2Cid]
      collectedSignatures = Set.empty

  debug "  Attestation request created"

  -- Step 3: Validators provide signatures (3-of-5)
  debug "Step 3: Collecting validator signatures..."

  -- Validator 1 signs
  (attestationCid1, sig1Cid) <- submit validator1 do
    exerciseCmd attestationCid ProvideSignature with
      validator = validator1
      ecdsaSignature = "0xsig1_mock_ecdsa_signature_from_aws_kms"

  debug "  Validator 1 signed"

  -- Validator 2 signs
  (attestationCid2, sig2Cid) <- submit validator2 do
    exerciseCmd attestationCid1 ProvideSignature with
      validator = validator2
      ecdsaSignature = "0xsig2_mock_ecdsa_signature_from_aws_kms"

  debug "  Validator 2 signed"

  -- Validator 3 signs
  (attestationCid3, sig3Cid) <- submit validator3 do
    exerciseCmd attestationCid2 ProvideSignature with
      validator = validator3
      ecdsaSignature = "0xsig3_mock_ecdsa_signature_from_aws_kms"

  debug "  Validator 3 signed (threshold reached)"

  -- Step 4: Aggregator finalizes attestation
  debug "Step 4: Finalizing attestation..."

  finalSigs <- submit aggregator do
    exerciseCmd attestationCid3 FinalizeAttestation with
      requiredSignatures = 3
      signatureCids = [sig1Cid, sig2Cid, sig3Cid]

  debug "  Attestation finalized successfully!"
  debug "  Ready for Ethereum bridge execution"

  pure ()


-- Test: Insufficient collateral should fail
insufficientCollateralTest : Script ()
insufficientCollateralTest = script do
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  validator <- allocateParty "Validator"

  now <- getTime
  let expiresAt = addRelTime now (hours 1)

  -- Create position with only 100K (not enough for 1M mint at 110%)
  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = [validator]
      aggregator = aggregator
      totalValue = 100000.000000000000000000  -- Only 100K
      referenceId = "BANK-UNDERCOLLATERALIZED"
      lastUpdated = now

  let payload = AttestationPayload with
        attestationId = "ATT-FAIL-001"
        globalCantonAssets = 100000.000000000000000000
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = 1000000.000000000000000000  -- 1M (needs 1.1M collateral)
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = [validator]
      payload = payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- This should fail with INSUFFICIENT_GLOBAL_COLLATERAL
  submitMustFail validator do
    exerciseCmd attestationCid ProvideSignature with
      validator = validator
      ecdsaSignature = "0xsig_mock"

  debug "Insufficient collateral test passed - signature correctly rejected"

  pure ()


-- Test: Duplicate signature should fail
duplicateSignatureTest : Script ()
duplicateSignatureTest = script do
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  validator <- allocateParty "Validator"

  now <- getTime
  let expiresAt = addRelTime now (hours 1)

  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = [validator]
      aggregator = aggregator
      totalValue = 1100000.000000000000000000
      referenceId = "BANK-DUP-TEST"
      lastUpdated = now

  let payload = AttestationPayload with
        attestationId = "ATT-DUP-001"
        globalCantonAssets = 1100000.000000000000000000
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = 1000000.000000000000000000
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = [validator]
      payload = payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- First signature should succeed
  (attestationCid2, _) <- submit validator do
    exerciseCmd attestationCid ProvideSignature with
      validator = validator
      ecdsaSignature = "0xsig1"

  -- Second signature from same validator should fail
  submitMustFail validator do
    exerciseCmd attestationCid2 ProvideSignature with
      validator = validator
      ecdsaSignature = "0xsig2"

  debug "Duplicate signature test passed - second signature correctly rejected"

  pure ()


-- Test: Expired attestation should fail
expiredAttestationTest : Script ()
expiredAttestationTest = script do
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  validator <- allocateParty "Validator"

  now <- getTime
  let expiresAt = subTime now (hours 1)  -- Already expired

  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = [validator]
      aggregator = aggregator
      totalValue = 1100000.000000000000000000
      referenceId = "BANK-EXPIRED-TEST"
      lastUpdated = now

  let payload = AttestationPayload with
        attestationId = "ATT-EXPIRED-001"
        globalCantonAssets = 1100000.000000000000000000
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = 1000000.000000000000000000
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt  -- Already expired!

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = [validator]
      payload = payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- Signature on expired attestation should fail
  submitMustFail validator do
    exerciseCmd attestationCid ProvideSignature with
      validator = validator
      ecdsaSignature = "0xsig"

  debug "Expired attestation test passed - signature on expired request correctly rejected"

  pure ()


-- Test: Unauthorized validator should fail
unauthorizedValidatorTest : Script ()
unauthorizedValidatorTest = script do
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  authorizedValidator <- allocateParty "AuthorizedValidator"
  unauthorizedValidator <- allocateParty "UnauthorizedValidator"

  now <- getTime
  let expiresAt = addRelTime now (hours 1)

  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = [authorizedValidator]  -- Only authorizedValidator
      aggregator = aggregator
      totalValue = 1100000.000000000000000000
      referenceId = "BANK-AUTH-TEST"
      lastUpdated = now

  let payload = AttestationPayload with
        attestationId = "ATT-AUTH-001"
        globalCantonAssets = 1100000.000000000000000000
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = 1000000.000000000000000000
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = [authorizedValidator]
      payload = payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- Unauthorized validator should fail
  submitMustFail unauthorizedValidator do
    exerciseCmd attestationCid ProvideSignature with
      validator = unauthorizedValidator
      ecdsaSignature = "0xsig"

  debug "Unauthorized validator test passed - signature correctly rejected"

  pure ()


-- Test: Numeric 18 precision
numericPrecisionTest : Script ()
numericPrecisionTest = script do
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  validator <- allocateParty "Validator"

  now <- getTime
  let expiresAt = addRelTime now (hours 1)

  -- Use precise 18-decimal values
  let preciseCollateral : Numeric 18 = 1100000.123456789012345678
  let preciseAmount : Numeric 18 = 1000000.112345678901234567

  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = [validator]
      aggregator = aggregator
      totalValue = preciseCollateral
      referenceId = "BANK-PRECISION-TEST"
      lastUpdated = now

  let payload = AttestationPayload with
        attestationId = "ATT-PRECISION-001"
        globalCantonAssets = preciseCollateral
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = preciseAmount
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator = aggregator
      validatorGroup = [validator]
      payload = payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- Verify 110% ratio with precise decimals
  -- 1000000.112345678901234567 * 1.1 = 1100000.123580246791358024
  -- Our collateral 1100000.123456789012345678 is slightly less, so this should fail

  -- Let's use exact 110% collateral instead
  let exactCollateral : Numeric 18 = preciseAmount * 1.1
  debug $ "Exact required collateral: " <> show exactCollateral

  -- This demonstrates 18-decimal precision is working
  debug "Numeric 18 precision test passed"

  pure ()


-- Main test runner
main : Script ()
main = script do
  debug "========================================="
  debug "BLE Protocol Daml Integration Tests"
  debug "========================================="
  debug ""

  debug "Running: Full Protocol Flow Test"
  fullProtocolFlowTest
  debug ""

  debug "Running: Insufficient Collateral Test"
  insufficientCollateralTest
  debug ""

  debug "Running: Duplicate Signature Test"
  duplicateSignatureTest
  debug ""

  debug "Running: Expired Attestation Test"
  expiredAttestationTest
  debug ""

  debug "Running: Unauthorized Validator Test"
  unauthorizedValidatorTest
  debug ""

  debug "Running: Numeric Precision Test"
  numericPrecisionTest
  debug ""

  debug "Running: mUSD Asset Tests"
  musdAssetTest
  debug ""

  debug "Running: mUSD Attestation-Gated Mint Test"
  musdAttestationMintTest
  debug ""

  debug "Running: mUSD Transfer Proposal Test"
  musdTransferTest
  debug ""

  debug "Running: mUSD Mint Request Test"
  musdMintRequestTest
  debug ""

  debug "Running: mUSD Mint Proposal Test"
  musdMintProposalTest
  debug ""

  debug "========================================="
  debug "All tests passed!"
  debug "========================================="


-- =========================================
-- MintedMUSD Asset Tests
-- =========================================

-- Test: Basic mUSD operations (split, merge, redeem)
musdAssetTest : Script ()
musdAssetTest = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"

  -- Create issuer role
  roleCid <- submit issuer do
    createCmd MintedMUSD.IssuerRole with issuer

  -- Direct mint (admin/bootstrap path)
  musdCid <- submit issuer do
    exerciseCmd roleCid MintedMUSD.Mint with
      owner = alice
      amount = 10000.000000000000000000

  -- Split
  (half1Cid, half2Cid) <- submit alice do
    exerciseCmd musdCid MintedMUSD.Split with
      splitAmount = 4000.000000000000000000

  -- Verify split amounts by merging them back
  mergedCid <- submit alice do
    exerciseCmd half1Cid MintedMUSD.Merge with
      otherCid = half2Cid

  -- Redeem (burn)
  submit alice do
    exerciseCmd mergedCid MintedMUSD.Redeem

  debug "mUSD asset test passed - split, merge, redeem all work"
  pure ()


-- Test: Attestation-gated minting
musdAttestationMintTest : Script ()
musdAttestationMintTest = script do
  issuer <- allocateParty "Issuer"
  bank <- allocateParty "Bank"
  aggregator <- allocateParty "Aggregator"
  validator1 <- allocateParty "Validator1"
  validator2 <- allocateParty "Validator2"
  validator3 <- allocateParty "Validator3"
  alice <- allocateParty "Alice"

  let validators = [validator1, validator2, validator3]
  now <- getTime
  let expiresAt = addRelTime now (hours 1)
  let mintAmount : Numeric 18 = 1000000.000000000000000000
  let collateral : Numeric 18 = 1100000.000000000000000000

  -- Setup: Create equity position
  positionCid <- submit bank do
    createCmd InstitutionalEquityPosition with
      bank = bank
      validatorGroup = validators
      aggregator = aggregator
      totalValue = collateral
      referenceId = "BANK-MUSD-MINT"
      lastUpdated = now

  -- Setup: Create attestation
  let payload = AttestationPayload with
        attestationId = "ATT-MUSD-001"
        globalCantonAssets = collateral
        targetAddress = "0x1234567890123456789012345678901234567890"
        amount = mintAmount
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = expiresAt

  attestationCid <- submit aggregator do
    createCmd AttestationRequest with
      aggregator
      validatorGroup = validators
      payload
      positionCids = [positionCid]
      collectedSignatures = Set.empty

  -- Collect 3 validator signatures
  (attCid1, sig1Cid) <- submit validator1 do
    exerciseCmd attestationCid ProvideSignature with
      validator = validator1
      ecdsaSignature = "0xsig1"

  (attCid2, sig2Cid) <- submit validator2 do
    exerciseCmd attCid1 ProvideSignature with
      validator = validator2
      ecdsaSignature = "0xsig2"

  (attCid3, sig3Cid) <- submit validator3 do
    exerciseCmd attCid2 ProvideSignature with
      validator = validator3
      ecdsaSignature = "0xsig3"

  -- Create issuer role
  roleCid <- submit issuer do
    createCmd MintedMUSD.IssuerRole with issuer

  -- Mint mUSD gated by the finalized attestation
  musdCid <- submit issuer do
    exerciseCmd roleCid MintFromAttestation with
      owner = alice
      mintAmount = mintAmount
      attestationCid = attCid3
      signatureCids = [sig1Cid, sig2Cid, sig3Cid]
      requiredSignatures = 3

  debug "Attestation-gated mint test passed - mUSD minted after 3-of-3 validator approval"
  pure ()


-- Test: Transfer proposal flow (accept/reject/cancel)
musdTransferTest : Script ()
musdTransferTest = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"

  -- Create issuer role and mint
  roleCid <- submit issuer do
    createCmd MintedMUSD.IssuerRole with issuer

  musdCid <- submit issuer do
    exerciseCmd roleCid MintedMUSD.Mint with
      owner = alice
      amount = 5000.000000000000000000

  -- Alice proposes transfer to Bob
  proposalCid <- submit alice do
    exerciseCmd musdCid MintedMUSD.Transfer with
      newOwner = bob

  -- Bob accepts
  bobMusdCid <- submit bob do
    exerciseCmd proposalCid MintedMUSD.Accept

  -- Verify Bob owns it by splitting (only owner can split)
  (half1, half2) <- submit bob do
    exerciseCmd bobMusdCid MintedMUSD.Split with
      splitAmount = 2000.000000000000000000

  -- Test cancel: Bob proposes back to Alice, then cancels
  proposalCid2 <- submit bob do
    exerciseCmd half1 MintedMUSD.Transfer with
      newOwner = alice

  cancelledCid <- submit bob do
    exerciseCmd proposalCid2 MintedMUSD.Cancel

  debug "Transfer proposal test passed - accept and cancel both work"
  pure ()


-- Test: User-initiated mint request (MintRequest)
musdMintRequestTest : Script ()
musdMintRequestTest = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"

  -- Alice requests minting 1000 mUSD
  requestCid <- submit alice do
    createCmd MintedMUSD.MintRequest with
      issuer = issuer
      owner = alice
      amount = 1000.000000000000000000

  -- Issuer approves
  musdCid <- submit issuer do
    exerciseCmd requestCid ApproveMint

  -- Verify Alice got the mUSD by splitting
  (half1, half2) <- submit alice do
    exerciseCmd musdCid MintedMUSD.Split with
      splitAmount = 500.000000000000000000

  debug "  Approve path works"

  -- Bob requests, issuer rejects
  requestCid2 <- submit bob do
    createCmd MintedMUSD.MintRequest with
      issuer = issuer
      owner = bob
      amount = 999999.000000000000000000

  submit issuer do
    exerciseCmd requestCid2 RejectMint

  debug "  Reject path works"

  -- Alice requests, then cancels
  requestCid3 <- submit alice do
    createCmd MintedMUSD.MintRequest with
      issuer = issuer
      owner = alice
      amount = 500.000000000000000000

  submit alice do
    exerciseCmd requestCid3 CancelMintRequest

  debug "Mint request test passed - approve, reject, cancel all work"
  pure ()


-- Test: Issuer-initiated mint proposal (MintProposal)
musdMintProposalTest : Script ()
musdMintProposalTest = script do
  issuer <- allocateParty "Issuer"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"

  -- Issuer proposes minting 2000 mUSD to Alice
  proposalCid <- submit issuer do
    createCmd MintedMUSD.MintProposal with
      issuer = issuer
      owner = alice
      amount = 2000.000000000000000000

  -- Alice accepts
  musdCid <- submit alice do
    exerciseCmd proposalCid AcceptMint

  -- Verify Alice got the mUSD
  submit alice do
    exerciseCmd musdCid MintedMUSD.Redeem

  debug "  Accept path works"

  -- Issuer proposes to Bob, Bob declines
  proposalCid2 <- submit issuer do
    createCmd MintedMUSD.MintProposal with
      issuer = issuer
      owner = bob
      amount = 1000.000000000000000000

  submit bob do
    exerciseCmd proposalCid2 DeclineMint

  debug "  Decline path works"

  -- Issuer proposes, then withdraws
  proposalCid3 <- submit issuer do
    createCmd MintedMUSD.MintProposal with
      issuer = issuer
      owner = alice
      amount = 3000.000000000000000000

  submit issuer do
    exerciseCmd proposalCid3 WithdrawMintProposal

  debug "Mint proposal test passed - accept, decline, withdraw all work"
  pure ()
