-- | V3ProtocolExtendedTest.daml
-- Tests for Minted.Protocol.V3 templates.
-- Follows the same import pattern as NegativeTests.daml

module V3ProtocolExtendedTest where

import Daml.Script
import DA.Time
import DA.Date
import DA.Set qualified as Set
import DA.Optional (fromSome)
import Minted.Protocol.V3

-- ============================================================
--                     TEST HELPERS
-- ============================================================

data V3Setup = V3Setup with
  operator   : Party
  governance : Party
  alice      : Party
  bob        : Party
  validator1 : Party
  validator2 : Party
  validator3 : Party
  attacker   : Party

setupV3 : Script V3Setup
setupV3 = do
  operator   <- allocateParty "Operator"
  governance <- allocateParty "Governance"
  alice      <- allocateParty "Alice"
  bob        <- allocateParty "Bob"
  validator1 <- allocateParty "Validator1"
  validator2 <- allocateParty "Validator2"
  validator3 <- allocateParty "Validator3"
  attacker   <- allocateParty "Attacker"
  setTime (datetime 2026 Feb 10 12 0 0)
  return V3Setup with ..

defaultVaultConfig : VaultConfig
defaultVaultConfig = VaultConfig with
  liquidationThreshold = 1.5
  interestRateBps = 500
  liquidationPenaltyBps = 1000
  liquidationBonusBps = 500
  closeFactorBps = 5000
  dustThreshold = 10.0

-- ============================================================
--       1. PRICE ORACLE
-- ============================================================

testPriceOracleUpdate : Script ()
testPriceOracleUpdate = do
  s <- setupV3

  oracleCid <- submit s.operator do
    createCmd PriceOracle with
      provider = s.operator
      symbol = "ETH"
      price = 2000.0
      lastUpdated = datetime 2026 Feb 10 12 0 0
      observers = [s.alice]

  newCid <- submit s.operator do
    exerciseCmd oracleCid Oracle_UpdatePrice with
      newPrice = 2500.0

  oracle <- queryContractId s.operator newCid
  case oracle of
    None -> abort "Oracle not found"
    Some o -> assertMsg "Price updated" (o.price == 2500.0)
  debug "✅ 1. Price oracle updated"

testPriceOracleQuery : Script ()
testPriceOracleQuery = do
  s <- setupV3

  oracleCid <- submit s.operator do
    createCmd PriceOracle with
      provider = s.operator
      symbol = "ETH"
      price = 2000.0
      lastUpdated = datetime 2026 Feb 10 12 0 0
      observers = [s.alice]

  price <- submitMulti [s.alice] [s.operator] do
    exerciseCmd oracleCid Oracle_GetPrice with
      requester = s.alice
      maxStaleness = hours 1
  assertMsg "Price is 2000" (price == 2000.0)
  debug "✅ 2. Price oracle query"

-- ============================================================
--       2. VAULT MANAGER
-- ============================================================

testOpenVault : Script ()
testOpenVault = do
  s <- setupV3

  mgrCid <- submit s.operator do
    createCmd VaultManager with
      operator = s.operator
      defaultConfig = defaultVaultConfig
      allowedCollaterals = ["ETH", "wBTC"]
      observers = [s.alice]

  -- OpenVault only takes owner + collateralSymbol
  vaultCid <- submitMulti [s.alice] [s.operator] do
    exerciseCmd mgrCid OpenVault with
      owner = s.alice
      collateralSymbol = "ETH"

  vault <- queryContractId s.operator vaultCid
  case vault of
    None -> abort "Vault not found"
    Some v -> do
      assertMsg "Owner is Alice" (v.owner == s.alice)
      assertMsg "Collateral is ETH" (v.collateralSymbol == "ETH")
  debug "✅ 3. Vault opened"

testUpdateDefaultConfig : Script ()
testUpdateDefaultConfig = do
  s <- setupV3

  mgrCid <- submit s.operator do
    createCmd VaultManager with
      operator = s.operator
      defaultConfig = defaultVaultConfig
      allowedCollaterals = ["ETH"]
      observers = []

  let newConfig = defaultVaultConfig with liquidationThreshold = 1.2

  newCid <- submit s.operator do
    exerciseCmd mgrCid UpdateDefaultConfig with
      newConfig
  debug "✅ 4. Default config updated"

testUnsupportedCollateralFails : Script ()
testUnsupportedCollateralFails = do
  s <- setupV3

  mgrCid <- submit s.operator do
    createCmd VaultManager with
      operator = s.operator
      defaultConfig = defaultVaultConfig
      allowedCollaterals = ["ETH"]
      observers = [s.alice]

  submitMultiMustFail [s.alice] [s.operator] do
    exerciseCmd mgrCid OpenVault with
      owner = s.alice
      collateralSymbol = "DOGE"
  debug "✅ 5. Unsupported collateral rejected"

-- ============================================================
--       3. VAULT LIFECYCLE
-- ============================================================

testVaultGetTotalDebt : Script ()
testVaultGetTotalDebt = do
  s <- setupV3
  now <- getTime

  vaultCid <- submitMulti [s.operator, s.alice] [] do
    createCmd Vault with
      operator = s.operator
      owner = s.alice
      collateralSymbol = "ETH"
      collateralAmount = 10.0
      principalDebt = 5000.0
      accruedInterest = 50.0
      lastInterestUpdate = now
      config = defaultVaultConfig
      observers = [s.operator]

  totalDebt <- submitMulti [s.alice] [s.operator] do
    exerciseCmd vaultCid Vault_GetTotalDebt with
      requester = s.alice
  assertMsg "Total debt = 5050" (totalDebt == 5050.0)
  debug "✅ 6. Vault total debt query"

-- ============================================================
--       4. LIQUIDATION ORDERS
-- ============================================================

testLiquidationOrderClaim : Script ()
testLiquidationOrderClaim = do
  s <- setupV3
  now <- getTime

  vaultCid <- submitMulti [s.operator, s.alice] [] do
    createCmd Vault with
      operator = s.operator
      owner = s.alice
      collateralSymbol = "ETH"
      collateralAmount = 10.0
      principalDebt = 15000.0
      accruedInterest = 0.0
      lastInterestUpdate = now
      config = defaultVaultConfig
      observers = [s.operator, s.bob]

  orderCid <- submit s.operator do
    createCmd LiquidationOrder with
      operator = s.operator
      vaultCid
      vaultOwner = s.alice
      estimatedDebt = 15000.0
      estimatedSeize = 7.5
      status = Pending
      claimedBy = None
      createdAt = now
      observers = [s.bob]

  -- ClaimOrder takes keeper
  claimedCid <- submitMulti [s.bob] [s.operator] do
    exerciseCmd orderCid ClaimOrder with
      keeper = s.bob

  order <- queryContractId s.operator claimedCid
  case order of
    None -> abort "Order not found"
    Some o -> do
      assertMsg "Status Claimed" (o.status == Claimed)
      assertMsg "Claimed by Bob" (o.claimedBy == Some s.bob)
  debug "✅ 7. Liquidation order claimed"

testLiquidationOrderCancel : Script ()
testLiquidationOrderCancel = do
  s <- setupV3
  now <- getTime

  vaultCid <- submitMulti [s.operator, s.alice] [] do
    createCmd Vault with
      operator = s.operator
      owner = s.alice
      collateralSymbol = "ETH"
      collateralAmount = 10.0
      principalDebt = 5000.0
      accruedInterest = 0.0
      lastInterestUpdate = now
      config = defaultVaultConfig
      observers = [s.operator]

  orderCid <- submit s.operator do
    createCmd LiquidationOrder with
      operator = s.operator
      vaultCid
      vaultOwner = s.alice
      estimatedDebt = 5000.0
      estimatedSeize = 2.5
      status = Pending
      claimedBy = None
      createdAt = now
      observers = []

  -- CancelOrder has no params
  cancelledCid <- submit s.operator do
    exerciseCmd orderCid CancelOrder
  debug "✅ 8. Liquidation order cancelled"

-- ============================================================
--       5. MUSD SUPPLY SERVICE
-- ============================================================

testSupplyServiceVaultMint : Script ()
testSupplyServiceVaultMint = do
  s <- setupV3

  supplyCid <- submitMulti [s.operator, s.governance] [] do
    createCmd MUSDSupplyService with
      operator = s.operator
      governance = s.governance
      supplyCap = 10000000.0
      currentSupply = 0.0
      largeMintThreshold = 1000000.0
      pendingLargeMints = []
      observers = []

  -- SupplyService_VaultMint takes borrower, borrowAmount, agreementHash, agreementUri
  (newCid, musdCid) <- submitMulti [s.operator, s.alice] [s.governance] do
    exerciseCmd supplyCid SupplyService_VaultMint with
      borrower = s.alice
      borrowAmount = 50000.0
      agreementHash = "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2"
      agreementUri = "https://minted.app/mpa"

  svc <- queryContractId s.operator newCid
  case svc of
    None -> abort "Supply service not found"
    Some sv -> assertMsg "Supply increased" (sv.currentSupply == 50000.0)
  debug "✅ 9. Supply service vault mint"

testSupplyServiceUpdateCap : Script ()
testSupplyServiceUpdateCap = do
  s <- setupV3

  supplyCid <- submitMulti [s.operator, s.governance] [] do
    createCmd MUSDSupplyService with
      operator = s.operator
      governance = s.governance
      supplyCap = 10000000.0
      currentSupply = 0.0
      largeMintThreshold = 1000000.0
      pendingLargeMints = []
      observers = []

  newCid <- submit s.governance do
    exerciseCmd supplyCid SupplyService_UpdateCap with
      newCap = 50000000.0
  debug "✅ 10. Supply cap updated"

testSupplyServiceCapExceeded : Script ()
testSupplyServiceCapExceeded = do
  s <- setupV3

  supplyCid <- submitMulti [s.operator, s.governance] [] do
    createCmd MUSDSupplyService with
      operator = s.operator
      governance = s.governance
      supplyCap = 100000.0
      currentSupply = 90000.0
      largeMintThreshold = 1000000.0
      pendingLargeMints = []
      observers = []

  submitMultiMustFail [s.operator, s.alice] [s.governance] do
    exerciseCmd supplyCid SupplyService_VaultMint with
      borrower = s.alice
      borrowAmount = 20000.0
      agreementHash = "b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3"
      agreementUri = "uri"
  debug "✅ 11. Supply cap exceeded fails"

-- ============================================================
--       6. BRIDGE SERVICE
-- ============================================================

testBridgePauseUnpause : Script ()
testBridgePauseUnpause = do
  s <- setupV3

  bridgeCid <- submitMulti [s.operator, s.governance] [] do
    createCmd BridgeService with
      operator = s.operator
      governance = s.governance
      validators = [s.validator1]
      requiredSignatures = 1
      totalBridgedIn = 0.0
      totalBridgedOut = 0.0
      lastNonce = 0
      paused = False
      observers = []

  -- Bridge_Pause has no params
  pausedCid <- submitMulti [s.operator, s.governance] [] do
    exerciseCmd bridgeCid Bridge_Pause

  bridge <- queryContractId s.operator pausedCid
  case bridge of
    None -> abort "Bridge not found"
    Some b -> assertMsg "Paused" b.paused

  -- Bridge_Unpause has no params
  unpausedCid <- submitMulti [s.operator, s.governance] [] do
    exerciseCmd pausedCid Bridge_Unpause

  bridge2 <- queryContractId s.operator unpausedCid
  case bridge2 of
    None -> abort "Bridge not found"
    Some b -> assertMsg "Unpaused" (not b.paused)
  debug "✅ 12. Bridge pause/unpause"

-- ============================================================
--       7. ATTESTATION REQUEST
-- ============================================================

testAttestationSignComplete : Script ()
testAttestationSignComplete = do
  s <- setupV3
  now <- getTime

  let payload = AttestationPayload with
        attestationId = "att-001"
        globalCantonAssets = 5000000.0
        targetAddress = "0xAlice"
        amount = 10000.0
        isMint = True
        nonce = 1
        chainId = 1
        expiresAt = addRelTime now (hours 24)

  attCid <- submit s.operator do
    createCmd AttestationRequest with
      aggregator = s.operator
      validatorGroup = [s.validator1, s.validator2, s.validator3]
      payload
      collectedSignatures = Set.empty
      direction = CantonToEthereum

  -- Attestation_Sign takes validator + ecdsaSignature
  att2 <- submitMulti [s.validator1] [s.operator] do
    exerciseCmd attCid Attestation_Sign with
      validator = s.validator1
      ecdsaSignature = "304502210099e10a25b5a80100d60a1b22e3f21cb19b02206dc38f8484cb58d36a37e9dc9bbfc47bfcb2bb63c25737be0ab7e22a49f4e3e4f5a6b7c8d9e0a1b2c3"

  att3 <- submitMulti [s.validator2] [s.operator] do
    exerciseCmd att2 Attestation_Sign with
      validator = s.validator2
      ecdsaSignature = "3046022100a2b3c4d5e6f7a8b9c0d1e2f3a4b5c6d7e8f9a0b1c2d30221009e8d7c6b5a4f3e2d1c0b9a8f7e6d5c4b3a2f1e0d9c8b7a6f5e4d3c2b1a0f9e8d7c6b5a4f3e2d1c0b9a8f7"

  -- Attestation_Complete has no params
  submit s.operator do
    exerciseCmd att3 Attestation_Complete
  debug "✅ 13. Attestation sign and complete"

testAttestationCancel : Script ()
testAttestationCancel = do
  s <- setupV3
  now <- getTime

  let payload = AttestationPayload with
        attestationId = "att-cancel"
        globalCantonAssets = 5000000.0
        targetAddress = "0xAlice"
        amount = 10000.0
        isMint = True
        nonce = 3
        chainId = 1
        expiresAt = addRelTime now (hours 24)

  attCid <- submit s.operator do
    createCmd AttestationRequest with
      aggregator = s.operator
      validatorGroup = [s.validator1, s.validator2]
      payload
      collectedSignatures = Set.empty
      direction = CantonToEthereum

  -- Attestation_Cancel has no params
  submit s.operator do
    exerciseCmd attCid Attestation_Cancel
  debug "✅ 14. Attestation cancelled"

-- ============================================================
--       8. MINTED MUSD TOKEN
-- ============================================================

testMintedMUSDTransfer : Script ()
testMintedMUSDTransfer = do
  s <- setupV3

  musdCid <- submitMulti [s.operator, s.alice] [] do
    createCmd MintedMUSD with
      issuer = s.operator
      owner = s.alice
      amount = 1000.0
      blacklisted = False
      agreementHash = "b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3"
      agreementUri = "uri"
      observers = [s.operator, s.bob]

  proposalCid <- submitMulti [s.alice] [s.operator] do
    exerciseCmd musdCid MUSD_Transfer with
      newOwner = s.bob

  newMusdCid <- submitMulti [s.bob] [s.operator] do
    exerciseCmd proposalCid TransferProposal_Accept
  debug "✅ 15. MintedMUSD transfer"

testBlacklistedMUSDCannotTransfer : Script ()
testBlacklistedMUSDCannotTransfer = do
  s <- setupV3

  musdCid <- submitMulti [s.operator, s.alice] [] do
    createCmd MintedMUSD with
      issuer = s.operator
      owner = s.alice
      amount = 1000.0
      blacklisted = True
      agreementHash = "b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3"
      agreementUri = "uri"
      observers = [s.operator]

  submitMultiMustFail [s.alice] [s.operator] do
    exerciseCmd musdCid MUSD_Transfer with
      newOwner = s.bob
  debug "✅ 16. Blacklisted MUSD cannot transfer"

-- ============================================================
--       9. COLLATERAL DEPOSIT PROOF
-- ============================================================

testCollateralProofConsume : Script ()
testCollateralProofConsume = do
  s <- setupV3
  now <- getTime

  proofCid <- submit s.operator do
    createCmd CollateralDepositProof with
      verifier = s.operator
      depositor = s.alice
      collateralSymbol = "ETH"
      amount = 10.0
      ethTxHash = "0xa1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2"
      blockNumber = 100
      blockTimestamp = now
      used = False

  consumedCid <- submit s.operator do
    exerciseCmd proofCid CollateralProof_Consume with
      consumer = s.alice

  proof <- queryContractId s.operator consumedCid
  case proof of
    None -> abort "Proof not found"
    Some p -> assertMsg "Proof consumed" p.used
  debug "✅ 17. Collateral proof consumed"
