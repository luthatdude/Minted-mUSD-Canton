-- | CantonDirectMint
-- Canton-side thin accounting layer for mUSD minting
--
-- Architecture:
--   User deposits stables (USDC) on Canton via CantonDirectMint
--   → Canton mUSD minted to user (1:1 minus fee)
--   → BridgeOutRequest emitted to pipe backing stables to Ethereum Treasury
--   → No Canton Treasury needed — backing lives on Ethereum where yield is generated
--   → Reserve tracking number maintained for audit/sync
--
-- The Canton side is a thin accounting layer:
--   - Tracks who holds mUSD
--   - Tracks who's staking in smUSD (separate module)
--   - Tracks what collateral is in vaults (existing Vault templates)
--   - Actual USDC backing lives on Ethereum

module CantonDirectMint where

import DA.Time
import DA.Set qualified as Set
import DA.Text qualified as DA.Text
import DA.Optional (whenSome, fromSome, isSome)
import Compliance (ComplianceRegistry, ValidateMint(..), ValidateRedemption(..), ValidateTransfer(..))
import Governance (GovernanceActionLog(..), ActionType(..), ConsumeProof(..))
import UserPrivacySettings (lookupUserObservers)

-- 18-decimal precision for 1:1 mapping with Ethereum Wei
type Money = Numeric 18
type Bps = Int

-- ============================================================
--                     SECTION 1: CANTON USDC (Deposit Asset)
-- ============================================================

-- | Represents USDC deposited on Canton side.
-- In production this would be a Canton-native USDC holding or tokenized deposit.
template CantonUSDC
  with
    issuer : Party
    owner : Party
    amount : Money
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0

    -- | Update observers from user's privacy settings
    choice CantonUSDC_UpdateObservers : ContractId CantonUSDC
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice CantonUSDC_Transfer : ContractId CantonUSDCTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create CantonUSDCTransferProposal with
          usdc = this
          newOwner

    choice CantonUSDC_Split : (ContractId CantonUSDC, ContractId CantonUSDC)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

-- | Transfer proposal for CantonUSDC (dual-signatory safe)
template CantonUSDCTransferProposal
  with
    usdc : CantonUSDC
    newOwner : Party
  where
    signatory usdc.issuer, usdc.owner
    observer newOwner

    choice CantonUSDCTransferProposal_Accept : ContractId CantonUSDC
      controller newOwner
      do create usdc with owner = newOwner

    choice CantonUSDCTransferProposal_Reject : ContractId CantonUSDC
      controller newOwner
      do create usdc

-- ============================================================
--                     SECTION 1B: USDCx (xReserve Bridged USDC)
-- ============================================================

-- | USDCx: Dollar-denominated stablecoin created by xReserve on Canton.
-- When a user deposits USDC into xReserve on Ethereum, a mint of USDCx is 
-- initiated on Canton through the protocol. xReserve works in tandem with 
-- Circle Gateway and Circle CCTP to make USDCx on Canton interoperable with 
-- USDC across supported blockchains, without reliance on third-party bridges.
template USDCx
  with
    issuer : Party            -- xReserve protocol operator
    owner : Party
    amount : Money
    sourceChain : Text        -- Original chain (e.g., "ethereum", "base", "arbitrum")
    cctpNonce : Int           -- Circle CCTP attestation nonce for provenance
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0

    -- | Update observers from user's privacy settings
    choice USDCx_UpdateObservers : ContractId USDCx
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice USDCx_Transfer : ContractId USDCxTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create USDCxTransferProposal with
          usdcx = this
          newOwner

    choice USDCx_Split : (ContractId USDCx, ContractId USDCx)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    -- AUDIT NOTE DAML-H05: Burn is controller issuer only, but this is safe because:
    -- 1. Both issuer AND owner are signatories on USDCx — owner consented at creation
    -- 2. Protocol services (DirectMint_MintWithUSDCx) exercise burns internally
    -- 3. Making dual-consent would break protocol burns
    choice USDCx_Burn : ()
      controller issuer
      do return ()

-- | Transfer proposal for USDCx (dual-signatory safe)
template USDCxTransferProposal
  with
    usdcx : USDCx
    newOwner : Party
  where
    signatory usdcx.issuer, usdcx.owner
    observer newOwner

    choice USDCxTransferProposal_Accept : ContractId USDCx
      controller newOwner
      do create usdcx with owner = newOwner

    choice USDCxTransferProposal_Reject : ContractId USDCx
      controller newOwner
      do create usdcx

-- ============================================================
--                     SECTION 2: CANTON mUSD
-- ============================================================

-- | Canton-side mUSD token. Thin wrapper — the real backing
-- lives on Ethereum Treasury.
template CantonMUSD
  with
    issuer : Party
    owner : Party
    amount : Money
    agreementHash : Text  -- SHA-256 hash of the Master Participation Agreement PDF
    agreementUri : Text   -- URI to the legal terms document
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0
      && DA.Text.length agreementHash == 64
      && DA.Text.length agreementUri > 0

    -- | Update observers from user's privacy settings
    choice CantonMUSD_UpdateObservers : ContractId CantonMUSD
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    -- NOTE: agreement declaration removed (deprecated in Daml 3.x)
    -- By holding or transferring this Canton mUSD token, the owner acknowledges
    -- they are bound by the Master Participation Agreement.
    -- Agreement hash and URI are stored in the agreementHash / agreementUri fields.

    -- FIX DL-C1: Use proposal pattern for safe dual-signatory transfers
    -- FIX INSTITUTIONAL: Added compliance check for transfers (anti-blacklist/freeze)
    -- FIX DAML-C01: complianceRegistryCid is now REQUIRED (not Optional) to prevent bypass
    choice CantonMUSD_Transfer : ContractId CantonMUSDTransferProposal
      with
        newOwner : Party
        complianceRegistryCid : ContractId ComplianceRegistry
      controller owner
      do
        -- FIX DAML-C01: Compliance check is mandatory — caller must provide valid CID
        exercise complianceRegistryCid ValidateTransfer with
          sender = owner
          receiver = newOwner
        create CantonMUSDTransferProposal with
          musd = this
          newOwner

    choice CantonMUSD_Split : (ContractId CantonMUSD, ContractId CantonMUSD)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    choice CantonMUSD_Merge : ContractId CantonMUSD
      with
        otherCid : ContractId CantonMUSD
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        archive otherCid
        create this with amount = amount + other.amount

    -- AUDIT NOTE DAML-C02: Burn is controller issuer only, but this is safe because:
    -- 1. Both issuer AND owner are signatories on CantonMUSD — owner consented at creation
    -- 2. Protocol services (staking, lending, redemption, loop) exercise burns internally
    -- 3. Making dual-consent would break all protocol burns (CantonSMUSD, CantonLending, etc.)
    -- 4. Burn is rate-limited by BurnRateLimiter (DAML-R05) as a separate backstop
    choice CantonMUSD_Burn : ()
      controller issuer
      do
        return ()

-- | FIX DL-C1: Transfer proposal for CantonMUSD (dual-signatory safe)
-- Prevents forced signatory obligations on unwitting recipients
template CantonMUSDTransferProposal
  with
    musd : CantonMUSD
    newOwner : Party
  where
    signatory musd.issuer, musd.owner
    observer newOwner

    choice CantonMUSDTransferProposal_Accept : ContractId CantonMUSD
      controller newOwner
      do create musd with owner = newOwner

    choice CantonMUSDTransferProposal_Reject : ContractId CantonMUSD
      controller newOwner
      do create musd

    choice CantonMUSDTransferProposal_Cancel : ContractId CantonMUSD
      controller musd.owner
      do create musd

-- ============================================================
--                     SECTION 2b: BURN RATE LIMITER (FIX DAML-R05)
-- ============================================================

-- | BurnRateLimiter — Per-epoch burn rate limiting for all mUSD burn paths.
-- FIX DAML-R05: CantonMUSD_Burn has no rate guards on its own (it's controller issuer).
-- This template provides centralized, on-ledger burn tracking across ALL protocol
-- paths (staking unstake, lending repay, direct mint redeem) to prevent mass-burn
-- attacks even if the operator key is compromised.
--
-- Usage:
--   Before burning mUSD, protocol services call BurnLimit_RecordBurn to verify
--   the burn doesn't exceed the per-epoch limit. If it does, the transaction aborts.
--   This is a defence-in-depth measure — DirectMint_Redeem already has its own
--   daily rate limit, but this covers ALL burn paths uniformly.
template BurnRateLimiter
  with
    operator            : Party
    epochBurnLimit      : Money   -- Max total burns per epoch (e.g. 1,000,000 mUSD / 24h)
    currentEpochBurns   : Money   -- Cumulative burns in current epoch
    epochStart          : Time    -- Start of current epoch window
    epochDurationSeconds : Int    -- Epoch length in seconds (e.g. 86400 = 24h)
    paused              : Bool    -- Emergency halt on burns
  where
    signatory operator
    key operator : Party
    maintainer key

    ensure epochBurnLimit > 0.0
        && epochDurationSeconds > 0
        && currentEpochBurns >= 0.0

    -- | Record a burn and enforce rate limit.
    -- Must be called by protocol services BEFORE exercising CantonMUSD_Burn.
    -- Rolls epoch window automatically when expired.
    choice BurnLimit_RecordBurn : ContractId BurnRateLimiter
      with
        burnAmount : Money
      controller operator
      do
        assertMsg "BURNS_PAUSED" (not paused)
        assertMsg "BURN_AMOUNT_POSITIVE" (burnAmount > 0.0)
        now <- getTime
        let elapsed = subTime now epochStart
        let epochDuration = seconds epochDurationSeconds
        -- Auto-reset epoch if window has passed
        let (newStart, newBurns) = if elapsed >= epochDuration
              then (now, 0.0)
              else (epochStart, currentEpochBurns)
        assertMsg "EPOCH_BURN_LIMIT_EXCEEDED" (newBurns + burnAmount <= epochBurnLimit)
        create this with
          currentEpochBurns = newBurns + burnAmount
          epochStart = newStart

    -- | Query current burn usage (nonconsuming)
    nonconsuming choice BurnLimit_GetUsage : (Money, Money, Time)
      controller operator
      do return (currentEpochBurns, epochBurnLimit, epochStart)

    -- | Admin: update epoch burn limit (governance-gated)
    choice BurnLimit_UpdateLimit : ContractId BurnRateLimiter
      with
        newLimit : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        assertMsg "LIMIT_POSITIVE" (newLimit > 0.0)
        create this with epochBurnLimit = newLimit

    -- | Admin: pause/unpause all burns
    choice BurnLimit_SetPaused : ContractId BurnRateLimiter
      with
        newPaused : Bool
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        create this with paused = newPaused

-- ============================================================
--                     SECTION 3: BRIDGE OUT REQUEST
-- ============================================================

-- | Emitted when backing stables need to be piped to Ethereum Treasury.
-- The relay picks this up and executes the cross-chain transfer.
-- This is the critical piece — it's the pipe that moves backing
-- assets to where yield exists.
template BridgeOutRequest
  with
    operator : Party          -- Protocol operator
    user : Party              -- Who deposited
    amount : Money            -- Amount of stables to bridge
    targetChainId : Int       -- Destination chain (1 = Ethereum mainnet)
    targetTreasury : Text     -- Ethereum Treasury contract address
    nonce : Int               -- Unique request ID
    createdAt : Time          -- When request was created
    status : Text             -- "pending" | "bridged" | "failed"
    validators : [Party]      -- Validators who will attest to the bridge
  where
    signatory operator
    observer user, validators

    -- Relay marks bridge as completed after Ethereum confirmation
    choice BridgeOut_Complete : ContractId BridgeOutRequest
      with
        relayParty : Party
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "bridged"

    -- Mark as failed for retry
    choice BridgeOut_Fail : ContractId BridgeOutRequest
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "failed"

    -- FIX DAML-H-06: Retry failed bridge
    choice BridgeOut_Retry : ContractId BridgeOutRequest
      controller operator
      do
        assertMsg "MUST_BE_FAILED" (status == "failed")
        now <- getTime
        create this with status = "pending", createdAt = now

    -- FIX DAML-H-06: Refund user for permanently failed bridge
    choice BridgeOut_RefundUser : ContractId CantonUSDC
      with
        usdcIssuer : Party
      controller operator
      do
        assertMsg "MUST_BE_FAILED" (status == "failed")
        create CantonUSDC with
          issuer = usdcIssuer
          owner = user
          amount = amount
          privacyObservers = []

-- ============================================================
--                     SECTION 4: RESERVE TRACKER
-- ============================================================

-- | Tracks total stables deposited on Canton side.
-- This is the reserve tracking number — how much was deposited
-- via Canton that should be backed on Ethereum.
-- No actual USDC held here — just accounting.
template ReserveTracker
  with
    operator : Party
    -- FIX DAML-011: Governance party provides oversight of all reserve tracking mutations
    governance : Party
    totalDeposited : Money      -- Total USDC ever deposited via Canton mint
    totalRedeemed : Money       -- Total USDC ever redeemed back
    totalBridgedOut : Money     -- Total successfully bridged to Ethereum
    totalBridgedIn : Money      -- Total bridged back from Ethereum (for redemptions)
    cantonMUSDSupply : Money    -- Current outstanding Canton mUSD
    lastUpdated : Time
  where
    signatory operator
    -- FIX DAML-011: Governance observer ensures all reserve changes are visible for audit
    observer governance

    ensure totalDeposited >= 0.0
        && totalRedeemed >= 0.0
        && totalBridgedOut >= 0.0
        && totalBridgedIn >= 0.0
        && cantonMUSDSupply >= 0.0

    -- Record a new deposit (mint)
    choice Reserve_RecordDeposit : ContractId ReserveTracker
      with
        depositAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalDeposited = totalDeposited + depositAmount
          cantonMUSDSupply = cantonMUSDSupply + depositAmount
          lastUpdated = now

    -- Record a redemption (burn)
    choice Reserve_RecordRedemption : ContractId ReserveTracker
      with
        redeemAmount : Money
      controller operator
      do
        assertMsg "INSUFFICIENT_SUPPLY" (cantonMUSDSupply >= redeemAmount)
        now <- getTime
        create this with
          totalRedeemed = totalRedeemed + redeemAmount
          cantonMUSDSupply = cantonMUSDSupply - redeemAmount
          lastUpdated = now

    -- Record successful bridge-out to Ethereum
    choice Reserve_RecordBridgeOut : ContractId ReserveTracker
      with
        bridgeAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalBridgedOut = totalBridgedOut + bridgeAmount
          lastUpdated = now

    -- Record bridge-in from Ethereum (for redemptions)
    choice Reserve_RecordBridgeIn : ContractId ReserveTracker
      with
        bridgeAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalBridgedIn = totalBridgedIn + bridgeAmount
          lastUpdated = now

    -- FIX DAML-C-03: Allow services to cross-check supply
    -- NOTE: ReserveTracker.cantonMUSDSupply and CantonDirectMintService.currentSupply
    -- are intentionally dual-tracked. ReserveTracker is the authoritative accounting ledger;
    -- currentSupply is a cached value for fast access. Use this choice to cross-check.
    nonconsuming choice Reserve_GetSupply : Money
      with
        requester : Party
      controller requester
      do return cantonMUSDSupply

    -- | FIX DAML-011: Governance-gated emergency reset for the ReserveTracker.
    -- Allows admin to reset all accounting counters in case of discrepancies
    -- between Canton and Ethereum state. Requires GovernanceActionLog proof.
    -- Normal accounting choices (RecordDeposit, RecordRedemption, etc.) remain
    -- operator-only as they are operational, not governance, actions.
    choice Reserve_AdminReset : ContractId ReserveTracker
      with
        newTotalDeposited : Money
        newTotalRedeemed : Money
        newTotalBridgedOut : Money
        newTotalBridgedIn : Money
        newCantonMUSDSupply : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        assertMsg "DEPOSITED_NON_NEGATIVE" (newTotalDeposited >= 0.0)
        assertMsg "REDEEMED_NON_NEGATIVE" (newTotalRedeemed >= 0.0)
        assertMsg "BRIDGED_OUT_NON_NEGATIVE" (newTotalBridgedOut >= 0.0)
        assertMsg "BRIDGED_IN_NON_NEGATIVE" (newTotalBridgedIn >= 0.0)
        assertMsg "SUPPLY_NON_NEGATIVE" (newCantonMUSDSupply >= 0.0)
        now <- getTime
        create this with
          totalDeposited = newTotalDeposited
          totalRedeemed = newTotalRedeemed
          totalBridgedOut = newTotalBridgedOut
          totalBridgedIn = newTotalBridgedIn
          cantonMUSDSupply = newCantonMUSDSupply
          lastUpdated = now

-- ============================================================
--                     SECTION 5: DIRECT MINT SERVICE
-- ============================================================

-- | The CantonDirectMint service.
-- Mints Canton mUSD and emits a bridge request for the backing stables.
-- Does NOT hold stables locally — they get piped to Ethereum Treasury.
-- Supports both:
--   1. CantonUSDC - Direct USDC deposits on Canton
--   2. USDCx - Bridged USDC from xReserve via Circle CCTP
template CantonDirectMintService
  with
    operator : Party
    usdcIssuer : Party
    usdcxIssuer : Optional Party  -- xReserve USDCx issuer (None = USDCx minting disabled)
    mintFeeBps : Bps             -- Fee in basis points (e.g., 30 = 0.30%)
    redeemFeeBps : Bps
    minAmount : Money            -- Minimum mint/redeem amount
    maxAmount : Money            -- Maximum per-transaction
    supplyCap : Money            -- Max outstanding Canton mUSD
    currentSupply : Money        -- Current outstanding Canton mUSD
    accumulatedFees : Money      -- Protocol fees collected
    paused : Bool                -- Emergency halt
    validators : [Party]         -- Bridge validators
    targetChainId : Int          -- Default: 1 (Ethereum mainnet)
    targetTreasury : Text        -- Ethereum Treasury address
    nextNonce : Int              -- Auto-incrementing nonce for bridge requests
    -- 24h rolling window rate limiting
    dailyMintLimit : Money       -- Max net mint volume per 24h window
    dailyMinted : Money          -- Cumulative mints in current window
    dailyBurned : Money          -- Cumulative burns in current window (offsets mints)
    lastRateLimitReset : Time    -- Timestamp of last window reset
    -- Compliance hook (optional — None disables compliance checks)
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    -- Master Participation Agreement reference (embedded in every minted token)
    mpaHash : Text               -- SHA-256 hash of the MPA PDF
    mpaUri : Text                -- URI to the MPA document
    authorizedMinters : [Party]  -- Users authorized to mint (visibility required)
    -- FIX DAML-019: Revoked minters retain redemption visibility via separate observer list.
    -- When a minter is revoked from authorizedMinters, add them to redemptionObservers
    -- so they can still see this service contract and exercise DirectMint_Redeem.
    redemptionObservers : [Party]
  where
    signatory operator
    -- FIX DAML-019: redemptionObservers included so revoked minters retain redemption visibility
    observer usdcIssuer, authorizedMinters, redemptionObservers

    -- | Mint: User deposits USDC on Canton → gets Canton mUSD
    -- → BridgeOutRequest emitted to pipe USDC to Ethereum Treasury
    choice DirectMint_Mint : (ContractId CantonDirectMintService, ContractId CantonMUSD, ContractId BridgeOutRequest)
      with
        user : Party
        usdcCid : ContractId CantonUSDC
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        assertMsg "NOT_AUTHORIZED_MINTER" (user `elem` authorizedMinters)

        -- Compliance check: verify minter is not blacklisted
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateMint with minter = user

        usdc <- fetch usdcCid
        assertMsg "USDC_ISSUER_MISMATCH" (usdc.issuer == usdcIssuer)
        assertMsg "USDC_OWNER_MISMATCH" (usdc.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (usdc.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (usdc.amount <= maxAmount)

        let feeAmount = usdc.amount * intToNumeric mintFeeBps / 10000.0
        let netAmount = usdc.amount - feeAmount

        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + netAmount <= supplyCap)

        -- 24h rolling window rate limit check
        now <- getTime
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)
        let netMinted = if resetMinted > resetBurned then resetMinted - resetBurned else 0.0
        assertMsg "DAILY_MINT_LIMIT" (netMinted + netAmount <= dailyMintLimit)

        -- Transfer USDC to operator (staging for bridge-out)
        -- The operator holds it temporarily until bridge confirms
        -- FIX: CantonUSDC_Transfer now returns proposal; accept it
        usdcProposal <- exercise usdcCid CantonUSDC_Transfer with newOwner = operator
        exercise usdcProposal CantonUSDCTransferProposal_Accept

        -- Mint Canton mUSD to user (1:1 minus fee)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = netAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs
        bridgeReq <- create BridgeOutRequest with
          operator = operator
          user = user
          amount = usdc.amount  -- Bridge the full USDC amount (including fee portion)
          targetChainId = targetChainId
          targetTreasury = targetTreasury
          nonce = nextNonce
          createdAt = now
          status = "pending"
          validators = validators

        -- FIX CRITICAL: Archive old service before creating new one
        -- Without this, old instances remain active with stale state,
        -- allowing users to bypass supply cap and rate limits
        archive self

        -- Update service state including rate limit tracking
        newService <- create this with
          currentSupply = currentSupply + netAmount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
          dailyMinted = resetMinted + netAmount
          dailyBurned = resetBurned
          lastRateLimitReset = resetTime

        return (newService, musdCid, bridgeReq)

    -- | Mint with USDCx: User deposits USDCx (xReserve bridged USDC) → gets Canton mUSD
    -- FIX: USDCx must be bridged to Ethereum Treasury so it can earn yield via
    -- Pendle/Morpho/Sky strategies. The relay redeems USDCx → USDC on Ethereum
    -- and deposits into TreasuryV2.
    choice DirectMint_MintWithUSDCx : (ContractId CantonDirectMintService, ContractId CantonMUSD, ContractId BridgeOutRequest)
      with
        user : Party
        usdcxCid : ContractId USDCx
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        assertMsg "NOT_AUTHORIZED_MINTER" (user `elem` authorizedMinters)
        assertMsg "USDCX_MINTING_DISABLED" (isSome usdcxIssuer)

        -- Compliance check: verify minter is not blacklisted
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateMint with minter = user

        usdcx <- fetch usdcxCid
        let expectedIssuer = fromSome usdcxIssuer
        assertMsg "USDCX_ISSUER_MISMATCH" (usdcx.issuer == expectedIssuer)
        assertMsg "USDCX_OWNER_MISMATCH" (usdcx.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (usdcx.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (usdcx.amount <= maxAmount)

        let feeAmount = usdcx.amount * intToNumeric mintFeeBps / 10000.0
        let netAmount = usdcx.amount - feeAmount

        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + netAmount <= supplyCap)

        -- 24h rolling window rate limit check
        now <- getTime
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)
        let netMinted = if resetMinted > resetBurned then resetMinted - resetBurned else 0.0
        assertMsg "DAILY_MINT_LIMIT" (netMinted + netAmount <= dailyMintLimit)

        -- Transfer USDCx to operator (staging for bridge-out)
        -- The operator holds it temporarily until bridge confirms
        usdcxProposal <- exercise usdcxCid USDCx_Transfer with newOwner = operator
        exercise usdcxProposal USDCxTransferProposal_Accept

        -- Mint Canton mUSD to user (1:1 minus fee)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = netAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        -- FIX: Emit bridge-out request to convert USDCx → USDC in Ethereum Treasury
        -- The relay will:
        --   1. Redeem USDCx via xReserve → receive USDC on Ethereum
        --   2. Deposit USDC into TreasuryV2 for yield generation
        bridgeReq <- create BridgeOutRequest with
          operator = operator
          user = user
          amount = usdcx.amount  -- Bridge the full USDCx amount (including fee portion)
          targetChainId = targetChainId
          targetTreasury = targetTreasury
          nonce = nextNonce
          createdAt = now
          status = "pending"
          validators = validators

        -- FIX CRITICAL: Archive old service before creating new one
        archive self

        -- Update service state including rate limit tracking
        newService <- create this with
          currentSupply = currentSupply + netAmount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
          dailyMinted = resetMinted + netAmount
          dailyBurned = resetBurned
          lastRateLimitReset = resetTime

        return (newService, musdCid, bridgeReq)

    -- | Redeem: User burns Canton mUSD → needs USDC bridged back from Ethereum
    -- This is a two-phase process:
    --   Phase 1: Burn mUSD, create redemption request
    --   Phase 2: Bridge-in from Ethereum fulfills the redemption (handled by BLEProtocol)
    choice DirectMint_Redeem : (ContractId CantonDirectMintService, ContractId RedemptionRequest)
      with
        user : Party
        musdCid : ContractId CantonMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- Compliance check: verify redeemer is not blacklisted or frozen
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateRedemption with redeemer = user

        musd <- fetch musdCid
        assertMsg "MUSD_ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "MUSD_OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (musd.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (musd.amount <= maxAmount)

        let feeAmount = musd.amount * intToNumeric redeemFeeBps / 10000.0
        let netAmount = musd.amount - feeAmount

        -- FIX DAML-002: Atomic coupling of BurnRateLimiter + CantonMUSD_Burn.
        -- Both operations execute in the SAME DAML transaction (same `do` block),
        -- guaranteeing atomicity: if the burn fails, rate-limit state rolls back,
        -- and if the rate limit is exceeded, the burn never executes.
        _ <- exerciseByKey @BurnRateLimiter operator BurnLimit_RecordBurn with
          burnAmount = musd.amount
        -- Burn the mUSD
        exercise musdCid CantonMUSD_Burn

        -- Create redemption request (bridge-in needed from Ethereum)
        now <- getTime
        redemptionCid <- create RedemptionRequest with
          operator = operator
          user = user
          musdBurned = musd.amount
          usdcOwed = netAmount
          feeAmount = feeAmount
          createdAt = now
          fulfilled = False
          expiresAt = addRelTime now (hours 72)  -- FIX DAML-C-02: 72-hour timeout for refund

        -- Track burn in rate limit window (burns offset mints)
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)

        -- FIX CRITICAL: Archive old service before creating new one
        archive self

        newService <- create this with
          currentSupply = currentSupply - musd.amount
          accumulatedFees = accumulatedFees + feeAmount
          dailyMinted = resetMinted
          dailyBurned = resetBurned + musd.amount
          lastRateLimitReset = resetTime

        return (newService, redemptionCid)

    -- Admin controls
    -- FIX D-M02: Added rate limiting - cap changes limited to 20% per update
    -- FIX INSTITUTIONAL: Requires governance proof for supply cap changes
    choice DirectMint_UpdateSupplyCap : ContractId CantonDirectMintService
      with
        newCap : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Verify governance approval
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == SupplyCapChange)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        assertMsg "CAP_BELOW_CURRENT_SUPPLY" (newCap >= currentSupply)
        -- FIX D-M02: Limit cap changes to max 20% increase per update
        let maxIncrease = supplyCap * 1.2
        assertMsg "CAP_INCREASE_TOO_LARGE" (newCap <= maxIncrease)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with supplyCap = newCap

    -- FIX DAML-S6: Governance-gated (was previously operator-only bypass)
    choice DirectMint_SetPaused : ContractId CantonDirectMintService
      with
        newPaused : Bool
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with paused = newPaused

    -- FIX DAML-S6: Governance-gated (was previously operator-only bypass)
    choice DirectMint_SetDailyMintLimit : ContractId CantonDirectMintService
      with
        newLimit : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        assertMsg "LIMIT_MUST_BE_POSITIVE" (newLimit > 0.0)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with dailyMintLimit = newLimit

    -- FIX INSTITUTIONAL: Compliance registry changes require governance proof
    choice DirectMint_SetComplianceRegistry : ContractId CantonDirectMintService
      with
        newRegistryCid : Optional (ContractId ComplianceRegistry)
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Verify governance approval for compliance changes
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with complianceRegistryCid = newRegistryCid

    -- FIX DAML-010: Governance-gated fee withdrawal (was previously operator-only bypass)
    choice DirectMint_WithdrawFees : ContractId CantonDirectMintService
      with
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-010: Consume governance proof (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == TreasuryWithdrawal)
        -- FIX DAML-H03: Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonDirectMint")
        assertMsg "NO_FEES_TO_WITHDRAW" (accumulatedFees > 0.0)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with accumulatedFees = 0.0

    -- FIX DAML-019: Add revoked minter to redemption observers for continued visibility
    choice DirectMint_AddRedemptionObserver : ContractId CantonDirectMintService
      with
        party : Party
      controller operator
      do
        archive self
        create this with redemptionObservers = party :: redemptionObservers

    -- FIX DAML-019: Remove party from redemption observers after all redemptions fulfilled
    choice DirectMint_RemoveRedemptionObserver : ContractId CantonDirectMintService
      with
        party : Party
      controller operator
      do
        archive self
        create this with redemptionObservers = filter (/= party) redemptionObservers

-- ============================================================
--                     SECTION 6: REDEMPTION REQUEST
-- ============================================================

-- | Pending redemption — user burned mUSD, awaiting USDC bridge-in from Ethereum.
template RedemptionRequest
  with
    operator : Party
    user : Party
    musdBurned : Money        -- How much mUSD was burned
    usdcOwed : Money          -- Net USDC owed to user (after fee)
    feeAmount : Money         -- Fee deducted
    createdAt : Time
    fulfilled : Bool
    expiresAt : Time          -- FIX DAML-C-02: Timeout for refund eligibility
  where
    signatory operator, user  -- User is signatory since they initiated redemption

    -- FIX DAML-C-02: Refund user if redemption not fulfilled before timeout
    choice Redemption_Refund : ContractId CantonMUSD
      controller user
      do
        assertMsg "ALREADY_FULFILLED" (not fulfilled)
        now <- getTime
        assertMsg "NOT_YET_EXPIRED" (now > expiresAt)
        -- Refund by re-minting the burned mUSD amount to the user
        create CantonMUSD with
          issuer = operator
          owner = user
          amount = musdBurned
          agreementHash = ""
          agreementUri = ""
          privacyObservers = []

    -- Operator fulfills after bridge-in from Ethereum delivers USDC
    choice Redemption_Fulfill : (ContractId RedemptionRequest, ContractId CantonUSDC)
      with
        usdcCid : ContractId CantonUSDC
      controller operator
      do
        assertMsg "ALREADY_FULFILLED" (not fulfilled)
        usdc <- fetch usdcCid
        assertMsg "INSUFFICIENT_USDC" (usdc.amount >= usdcOwed)

        -- Split exact amount if needed, then accept transfer proposal
        payoutCid <- if usdc.amount == usdcOwed
          then do
            proposal <- exercise usdcCid CantonUSDC_Transfer with newOwner = user
            exercise proposal CantonUSDCTransferProposal_Accept
          else do
            (exact, _remainder) <- exercise usdcCid CantonUSDC_Split with splitAmount = usdcOwed
            proposal <- exercise exact CantonUSDC_Transfer with newOwner = user
            exercise proposal CantonUSDCTransferProposal_Accept

        fulfilledReq <- create this with fulfilled = True
        return (fulfilledReq, payoutCid)

