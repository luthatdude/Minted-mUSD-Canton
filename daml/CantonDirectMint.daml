-- | CantonDirectMint
-- Canton-side thin accounting layer for mUSD minting
--
-- Architecture:
--   User deposits stables (USDC) on Canton via CantonDirectMint
--   → Canton mUSD minted to user (1:1 minus fee)
--   → BridgeOutRequest emitted to pipe backing stables to Ethereum Treasury
--   → No Canton Treasury needed — backing lives on Ethereum where yield is generated
--   → Reserve tracking number maintained for audit/sync
--
-- The Canton side is a thin accounting layer:
--   - Tracks who holds mUSD
--   - Tracks who's staking in smUSD (separate module)
--   - Tracks what collateral is in vaults (existing Vault templates)
--   - Actual USDC backing lives on Ethereum

module CantonDirectMint where

import DA.Time
import DA.Set qualified as Set
import DA.Text qualified as DA.Text
import DA.Optional (whenSome, fromSome, isSome)
import Compliance (ComplianceRegistry, ValidateMint(..), ValidateRedemption(..), ValidateTransfer(..))
import Governance (GovernanceActionLog(..), ActionType(..))
import UserPrivacySettings (lookupUserObservers)

-- 18-decimal precision for 1:1 mapping with Ethereum Wei
type Money = Numeric 18
type Bps = Int

-- ============================================================
--                     SECTION 1: CANTON USDC (Deposit Asset)
-- ============================================================

-- | Represents USDC deposited on Canton side.
-- In production this would be a Canton-native USDC holding or tokenized deposit.
template CantonUSDC
  with
    issuer : Party
    owner : Party
    amount : Money
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0

    -- | Update observers from user's privacy settings
    choice CantonUSDC_UpdateObservers : ContractId CantonUSDC
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice CantonUSDC_Transfer : ContractId CantonUSDCTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create CantonUSDCTransferProposal with
          usdc = this
          newOwner

    choice CantonUSDC_Split : (ContractId CantonUSDC, ContractId CantonUSDC)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

-- | Transfer proposal for CantonUSDC (dual-signatory safe)
template CantonUSDCTransferProposal
  with
    usdc : CantonUSDC
    newOwner : Party
  where
    signatory usdc.issuer, usdc.owner
    observer newOwner

    choice CantonUSDCTransferProposal_Accept : ContractId CantonUSDC
      controller newOwner
      do create usdc with owner = newOwner

    choice CantonUSDCTransferProposal_Reject : ContractId CantonUSDC
      controller newOwner
      do create usdc

-- ============================================================
--                     SECTION 1B: USDCx (xReserve Bridged USDC)
-- ============================================================

-- | USDCx: Dollar-denominated stablecoin created by xReserve on Canton.
-- When a user deposits USDC into xReserve on Ethereum, a mint of USDCx is 
-- initiated on Canton through the protocol. xReserve works in tandem with 
-- Circle Gateway and Circle CCTP to make USDCx on Canton interoperable with 
-- USDC across supported blockchains, without reliance on third-party bridges.
template USDCx
  with
    issuer : Party            -- xReserve protocol operator
    owner : Party
    amount : Money
    sourceChain : Text        -- Original chain (e.g., "ethereum", "base", "arbitrum")
    cctpNonce : Int           -- Circle CCTP attestation nonce for provenance
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0

    -- | Update observers from user's privacy settings
    choice USDCx_UpdateObservers : ContractId USDCx
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice USDCx_Transfer : ContractId USDCxTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create USDCxTransferProposal with
          usdcx = this
          newOwner

    choice USDCx_Split : (ContractId USDCx, ContractId USDCx)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    choice USDCx_Burn : ()
      controller issuer
      do return ()

-- | Transfer proposal for USDCx (dual-signatory safe)
template USDCxTransferProposal
  with
    usdcx : USDCx
    newOwner : Party
  where
    signatory usdcx.issuer, usdcx.owner
    observer newOwner

    choice USDCxTransferProposal_Accept : ContractId USDCx
      controller newOwner
      do create usdcx with owner = newOwner

    choice USDCxTransferProposal_Reject : ContractId USDCx
      controller newOwner
      do create usdcx

-- ============================================================
--                     SECTION 2: CANTON mUSD
-- ============================================================

-- | Canton-side mUSD token. Thin wrapper — the real backing
-- lives on Ethereum Treasury.
template CantonMUSD
  with
    issuer : Party
    owner : Party
    amount : Money
    agreementHash : Text  -- SHA-256 hash of the Master Participation Agreement PDF
    agreementUri : Text   -- URI to the legal terms document
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure amount > 0.0
      && DA.Text.length agreementHash == 64
      && DA.Text.length agreementUri > 0

    -- | Update observers from user's privacy settings
    choice CantonMUSD_UpdateObservers : ContractId CantonMUSD
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    -- NOTE: agreement declaration removed (deprecated in Daml 3.x)
    -- By holding or transferring this Canton mUSD token, the owner acknowledges
    -- they are bound by the Master Participation Agreement.
    -- Agreement hash and URI are stored in the agreementHash / agreementUri fields.

    -- FIX DL-C1: Use proposal pattern for safe dual-signatory transfers
    -- FIX INSTITUTIONAL: Added compliance check for transfers (anti-blacklist/freeze)
    choice CantonMUSD_Transfer : ContractId CantonMUSDTransferProposal
      with
        newOwner : Party
        complianceRegistryCid : Optional (ContractId ComplianceRegistry)
      controller owner
      do
        -- Compliance check: verify sender and receiver are not blacklisted/frozen
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateTransfer with
            sender = owner
            receiver = newOwner
        create CantonMUSDTransferProposal with
          musd = this
          newOwner

    choice CantonMUSD_Split : (ContractId CantonMUSD, ContractId CantonMUSD)
      with
        splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    choice CantonMUSD_Merge : ContractId CantonMUSD
      with
        otherCid : ContractId CantonMUSD
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        archive otherCid
        create this with amount = amount + other.amount

    choice CantonMUSD_Burn : ()
      controller issuer
      do
        return ()

-- | FIX DL-C1: Transfer proposal for CantonMUSD (dual-signatory safe)
-- Prevents forced signatory obligations on unwitting recipients
template CantonMUSDTransferProposal
  with
    musd : CantonMUSD
    newOwner : Party
  where
    signatory musd.issuer, musd.owner
    observer newOwner

    choice CantonMUSDTransferProposal_Accept : ContractId CantonMUSD
      controller newOwner
      do create musd with owner = newOwner

    choice CantonMUSDTransferProposal_Reject : ContractId CantonMUSD
      controller newOwner
      do create musd

    choice CantonMUSDTransferProposal_Cancel : ContractId CantonMUSD
      controller musd.owner
      do create musd

-- ============================================================
--                     SECTION 3: BRIDGE OUT REQUEST
-- ============================================================

-- | Emitted when backing stables need to be piped to Ethereum Treasury.
-- The relay picks this up and executes the cross-chain transfer.
-- This is the critical piece — it's the pipe that moves backing
-- assets to where yield exists.
template BridgeOutRequest
  with
    operator : Party          -- Protocol operator
    user : Party              -- Who deposited
    amount : Money            -- Amount of stables to bridge
    targetChainId : Int       -- Destination chain (1 = Ethereum mainnet)
    targetTreasury : Text     -- Ethereum Treasury contract address
    nonce : Int               -- Unique request ID
    createdAt : Time          -- When request was created
    status : Text             -- "pending" | "bridged" | "failed"
    validators : [Party]      -- Validators who will attest to the bridge
  where
    signatory operator
    observer user, validators

    -- Relay marks bridge as completed after Ethereum confirmation
    choice BridgeOut_Complete : ContractId BridgeOutRequest
      with
        relayParty : Party
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "bridged"

    -- Mark as failed for retry
    choice BridgeOut_Fail : ContractId BridgeOutRequest
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "failed"

-- ============================================================
--                     SECTION 4: RESERVE TRACKER
-- ============================================================

-- | Tracks total stables deposited on Canton side.
-- This is the reserve tracking number — how much was deposited
-- via Canton that should be backed on Ethereum.
-- No actual USDC held here — just accounting.
template ReserveTracker
  with
    operator : Party
    totalDeposited : Money      -- Total USDC ever deposited via Canton mint
    totalRedeemed : Money       -- Total USDC ever redeemed back
    totalBridgedOut : Money     -- Total successfully bridged to Ethereum
    totalBridgedIn : Money      -- Total bridged back from Ethereum (for redemptions)
    cantonMUSDSupply : Money    -- Current outstanding Canton mUSD
    lastUpdated : Time
  where
    signatory operator

    ensure totalDeposited >= 0.0
        && totalRedeemed >= 0.0
        && totalBridgedOut >= 0.0
        && totalBridgedIn >= 0.0
        && cantonMUSDSupply >= 0.0

    -- Record a new deposit (mint)
    choice Reserve_RecordDeposit : ContractId ReserveTracker
      with
        depositAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalDeposited = totalDeposited + depositAmount
          cantonMUSDSupply = cantonMUSDSupply + depositAmount
          lastUpdated = now

    -- Record a redemption (burn)
    choice Reserve_RecordRedemption : ContractId ReserveTracker
      with
        redeemAmount : Money
      controller operator
      do
        assertMsg "INSUFFICIENT_SUPPLY" (cantonMUSDSupply >= redeemAmount)
        now <- getTime
        create this with
          totalRedeemed = totalRedeemed + redeemAmount
          cantonMUSDSupply = cantonMUSDSupply - redeemAmount
          lastUpdated = now

    -- Record successful bridge-out to Ethereum
    choice Reserve_RecordBridgeOut : ContractId ReserveTracker
      with
        bridgeAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalBridgedOut = totalBridgedOut + bridgeAmount
          lastUpdated = now

    -- Record bridge-in from Ethereum (for redemptions)
    choice Reserve_RecordBridgeIn : ContractId ReserveTracker
      with
        bridgeAmount : Money
      controller operator
      do
        now <- getTime
        create this with
          totalBridgedIn = totalBridgedIn + bridgeAmount
          lastUpdated = now

-- ============================================================
--                     SECTION 5: DIRECT MINT SERVICE
-- ============================================================

-- | The CantonDirectMint service.
-- Mints Canton mUSD and emits a bridge request for the backing stables.
-- Does NOT hold stables locally — they get piped to Ethereum Treasury.
-- Supports both:
--   1. CantonUSDC - Direct USDC deposits on Canton
--   2. USDCx - Bridged USDC from xReserve via Circle CCTP
template CantonDirectMintService
  with
    operator : Party
    usdcIssuer : Party
    usdcxIssuer : Optional Party  -- xReserve USDCx issuer (None = USDCx minting disabled)
    mintFeeBps : Bps             -- Fee in basis points (e.g., 30 = 0.30%)
    redeemFeeBps : Bps
    minAmount : Money            -- Minimum mint/redeem amount
    maxAmount : Money            -- Maximum per-transaction
    supplyCap : Money            -- Max outstanding Canton mUSD
    currentSupply : Money        -- Current outstanding Canton mUSD
    accumulatedFees : Money      -- Protocol fees collected
    paused : Bool                -- Emergency halt
    validators : [Party]         -- Bridge validators
    targetChainId : Int          -- Default: 1 (Ethereum mainnet)
    targetTreasury : Text        -- Ethereum Treasury address
    nextNonce : Int              -- Auto-incrementing nonce for bridge requests
    -- 24h rolling window rate limiting
    dailyMintLimit : Money       -- Max net mint volume per 24h window
    dailyMinted : Money          -- Cumulative mints in current window
    dailyBurned : Money          -- Cumulative burns in current window (offsets mints)
    lastRateLimitReset : Time    -- Timestamp of last window reset
    -- Compliance hook (optional — None disables compliance checks)
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    -- Master Participation Agreement reference (embedded in every minted token)
    mpaHash : Text               -- SHA-256 hash of the MPA PDF
    mpaUri : Text                -- URI to the MPA document
    authorizedMinters : [Party]  -- Users authorized to mint (visibility required)
  where
    signatory operator
    observer usdcIssuer, authorizedMinters

    -- | Mint: User deposits USDC on Canton → gets Canton mUSD
    -- → BridgeOutRequest emitted to pipe USDC to Ethereum Treasury
    choice DirectMint_Mint : (ContractId CantonDirectMintService, ContractId CantonMUSD, ContractId BridgeOutRequest)
      with
        user : Party
        usdcCid : ContractId CantonUSDC
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- Compliance check: verify minter is not blacklisted
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateMint with minter = user

        usdc <- fetch usdcCid
        assertMsg "USDC_ISSUER_MISMATCH" (usdc.issuer == usdcIssuer)
        assertMsg "USDC_OWNER_MISMATCH" (usdc.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (usdc.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (usdc.amount <= maxAmount)

        let feeAmount = usdc.amount * intToNumeric mintFeeBps / 10000.0
        let netAmount = usdc.amount - feeAmount

        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + netAmount <= supplyCap)

        -- 24h rolling window rate limit check
        now <- getTime
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)
        let netMinted = if resetMinted > resetBurned then resetMinted - resetBurned else 0.0
        assertMsg "DAILY_MINT_LIMIT" (netMinted + netAmount <= dailyMintLimit)

        -- Transfer USDC to operator (staging for bridge-out)
        -- The operator holds it temporarily until bridge confirms
        -- FIX: CantonUSDC_Transfer now returns proposal; accept it
        usdcProposal <- exercise usdcCid CantonUSDC_Transfer with newOwner = operator
        exercise usdcProposal CantonUSDCTransferProposal_Accept

        -- Mint Canton mUSD to user (1:1 minus fee)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = netAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs
        bridgeReq <- create BridgeOutRequest with
          operator = operator
          user = user
          amount = usdc.amount  -- Bridge the full USDC amount (including fee portion)
          targetChainId = targetChainId
          targetTreasury = targetTreasury
          nonce = nextNonce
          createdAt = now
          status = "pending"
          validators = validators

        -- FIX CRITICAL: Archive old service before creating new one
        -- Without this, old instances remain active with stale state,
        -- allowing users to bypass supply cap and rate limits
        archive self

        -- Update service state including rate limit tracking
        newService <- create this with
          currentSupply = currentSupply + netAmount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
          dailyMinted = resetMinted + netAmount
          dailyBurned = resetBurned
          lastRateLimitReset = resetTime

        return (newService, musdCid, bridgeReq)

    -- | Mint with USDCx: User deposits USDCx (xReserve bridged USDC) → gets Canton mUSD
    -- FIX: USDCx must be bridged to Ethereum Treasury so it can earn yield via
    -- Pendle/Morpho/Sky strategies. The relay redeems USDCx → USDC on Ethereum
    -- and deposits into TreasuryV2.
    choice DirectMint_MintWithUSDCx : (ContractId CantonDirectMintService, ContractId CantonMUSD, ContractId BridgeOutRequest)
      with
        user : Party
        usdcxCid : ContractId USDCx
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        assertMsg "USDCX_MINTING_DISABLED" (isSome usdcxIssuer)

        -- Compliance check: verify minter is not blacklisted
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateMint with minter = user

        usdcx <- fetch usdcxCid
        let expectedIssuer = fromSome usdcxIssuer
        assertMsg "USDCX_ISSUER_MISMATCH" (usdcx.issuer == expectedIssuer)
        assertMsg "USDCX_OWNER_MISMATCH" (usdcx.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (usdcx.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (usdcx.amount <= maxAmount)

        let feeAmount = usdcx.amount * intToNumeric mintFeeBps / 10000.0
        let netAmount = usdcx.amount - feeAmount

        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + netAmount <= supplyCap)

        -- 24h rolling window rate limit check
        now <- getTime
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)
        let netMinted = if resetMinted > resetBurned then resetMinted - resetBurned else 0.0
        assertMsg "DAILY_MINT_LIMIT" (netMinted + netAmount <= dailyMintLimit)

        -- Transfer USDCx to operator (staging for bridge-out)
        -- The operator holds it temporarily until bridge confirms
        usdcxProposal <- exercise usdcxCid USDCx_Transfer with newOwner = operator
        exercise usdcxProposal USDCxTransferProposal_Accept

        -- Mint Canton mUSD to user (1:1 minus fee)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = netAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        -- FIX: Emit bridge-out request to convert USDCx → USDC in Ethereum Treasury
        -- The relay will:
        --   1. Redeem USDCx via xReserve → receive USDC on Ethereum
        --   2. Deposit USDC into TreasuryV2 for yield generation
        bridgeReq <- create BridgeOutRequest with
          operator = operator
          user = user
          amount = usdcx.amount  -- Bridge the full USDCx amount (including fee portion)
          targetChainId = targetChainId
          targetTreasury = targetTreasury
          nonce = nextNonce
          createdAt = now
          status = "pending"
          validators = validators

        -- FIX CRITICAL: Archive old service before creating new one
        archive self

        -- Update service state including rate limit tracking
        newService <- create this with
          currentSupply = currentSupply + netAmount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
          dailyMinted = resetMinted + netAmount
          dailyBurned = resetBurned
          lastRateLimitReset = resetTime

        return (newService, musdCid, bridgeReq)

    -- | Redeem: User burns Canton mUSD → needs USDC bridged back from Ethereum
    -- This is a two-phase process:
    --   Phase 1: Burn mUSD, create redemption request
    --   Phase 2: Bridge-in from Ethereum fulfills the redemption (handled by BLEProtocol)
    choice DirectMint_Redeem : (ContractId CantonDirectMintService, ContractId RedemptionRequest)
      with
        user : Party
        musdCid : ContractId CantonMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- Compliance check: verify redeemer is not blacklisted or frozen
        whenSome complianceRegistryCid $ \cid ->
          exercise cid ValidateRedemption with redeemer = user

        musd <- fetch musdCid
        assertMsg "MUSD_ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "MUSD_OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (musd.amount >= minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (musd.amount <= maxAmount)

        let feeAmount = musd.amount * intToNumeric redeemFeeBps / 10000.0
        let netAmount = musd.amount - feeAmount

        -- Burn the mUSD
        exercise musdCid CantonMUSD_Burn

        -- Create redemption request (bridge-in needed from Ethereum)
        now <- getTime
        redemptionCid <- create RedemptionRequest with
          operator = operator
          user = user
          musdBurned = musd.amount
          usdcOwed = netAmount
          feeAmount = feeAmount
          createdAt = now
          fulfilled = False

        -- Track burn in rate limit window (burns offset mints)
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetBurned, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, 0.0, now)
              else (dailyMinted, dailyBurned, lastRateLimitReset)

        -- FIX CRITICAL: Archive old service before creating new one
        archive self

        newService <- create this with
          currentSupply = currentSupply - musd.amount
          accumulatedFees = accumulatedFees + feeAmount
          dailyMinted = resetMinted
          dailyBurned = resetBurned + musd.amount
          lastRateLimitReset = resetTime

        return (newService, redemptionCid)

    -- Admin controls
    -- FIX D-M02: Added rate limiting - cap changes limited to 20% per update
    -- FIX INSTITUTIONAL: Requires governance proof for supply cap changes
    choice DirectMint_UpdateSupplyCap : ContractId CantonDirectMintService
      with
        newCap : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Verify governance approval
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == SupplyCapChange)
        assertMsg "CAP_BELOW_CURRENT_SUPPLY" (newCap >= currentSupply)
        -- FIX D-M02: Limit cap changes to max 20% increase per update
        let maxIncrease = supplyCap * 1.2
        assertMsg "CAP_INCREASE_TOO_LARGE" (newCap <= maxIncrease)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with supplyCap = newCap

    -- FIX DAML-S6: Governance-gated (was previously operator-only bypass)
    choice DirectMint_SetPaused : ContractId CantonDirectMintService
      with
        newPaused : Bool
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with paused = newPaused

    -- FIX DAML-S6: Governance-gated (was previously operator-only bypass)
    choice DirectMint_SetDailyMintLimit : ContractId CantonDirectMintService
      with
        newLimit : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "LIMIT_MUST_BE_POSITIVE" (newLimit > 0.0)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with dailyMintLimit = newLimit

    -- FIX INSTITUTIONAL: Compliance registry changes require governance proof
    choice DirectMint_SetComplianceRegistry : ContractId CantonDirectMintService
      with
        newRegistryCid : Optional (ContractId ComplianceRegistry)
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Verify governance approval for compliance changes
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with complianceRegistryCid = newRegistryCid

    choice DirectMint_WithdrawFees : ContractId CantonDirectMintService
      controller operator
      do
        assertMsg "NO_FEES_TO_WITHDRAW" (accumulatedFees > 0.0)
        -- FIX CRITICAL: Archive old service before creating new one
        archive self
        create this with accumulatedFees = 0.0

-- ============================================================
--                     SECTION 6: REDEMPTION REQUEST
-- ============================================================

-- | Pending redemption — user burned mUSD, awaiting USDC bridge-in from Ethereum.
template RedemptionRequest
  with
    operator : Party
    user : Party
    musdBurned : Money        -- How much mUSD was burned
    usdcOwed : Money          -- Net USDC owed to user (after fee)
    feeAmount : Money         -- Fee deducted
    createdAt : Time
    fulfilled : Bool
  where
    signatory operator, user  -- User is signatory since they initiated redemption

    -- Operator fulfills after bridge-in from Ethereum delivers USDC
    choice Redemption_Fulfill : (ContractId RedemptionRequest, ContractId CantonUSDC)
      with
        usdcCid : ContractId CantonUSDC
      controller operator
      do
        assertMsg "ALREADY_FULFILLED" (not fulfilled)
        usdc <- fetch usdcCid
        assertMsg "INSUFFICIENT_USDC" (usdc.amount >= usdcOwed)

        -- Split exact amount if needed, then accept transfer proposal
        payoutCid <- if usdc.amount == usdcOwed
          then do
            proposal <- exercise usdcCid CantonUSDC_Transfer with newOwner = user
            exercise proposal CantonUSDCTransferProposal_Accept
          else do
            (exact, _remainder) <- exercise usdcCid CantonUSDC_Split with splitAmount = usdcOwed
            proposal <- exercise exact CantonUSDC_Transfer with newOwner = user
            exercise proposal CantonUSDCTransferProposal_Accept

        fulfilledReq <- create this with fulfilled = True
        return (fulfilledReq, payoutCid)

