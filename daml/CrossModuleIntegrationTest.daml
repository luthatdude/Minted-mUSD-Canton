-- | CrossModuleIntegrationTest
-- Cross-module integration tests covering multi-module flows.
-- These tests verify that templates from different modules compose correctly
-- and that security invariants hold across module boundaries.
--
-- Covered flows:
--   1. Mint → Stake → Unstake (CantonDirectMint × CantonSMUSD)
--   2. Deposit → Borrow → Repay → Withdraw (CantonLending full cycle)
--   3. Share price sync within bounds (CantonSMUSD)
--   4. Share price increase > 10% rejected (CantonSMUSD FIX D-M09)
--   5. Share price decrease > 10% rejected (CantonSMUSD)
--   6. Liquidation of undercollateralized position (CantonLending)
--   7. Healthy position cannot be liquidated (CantonLending)
--   8. sMUSD escrowed in Lending blocked from BoostPool (FIX D-M04)
--   9. Compliance blocks blacklisted transfers (FIX D-M08)
--  10. Supply cap coordination between Lending and DirectMint (FIX D-M02)

module CrossModuleIntegrationTest where

import Daml.Script
import DA.Time
import DA.Date
import DA.Optional (fromSome)
import DA.Set qualified as Set
import CantonDirectMint (CantonMUSD(..), CantonMUSD_Burn(..), CantonMUSD_Transfer(..), CantonUSDC(..), CantonDirectMintService(..), Money, Bps)
import CantonSMUSD (CantonSMUSD(..), CantonStakingService(..), SyncGlobalSharePrice(..), Stake(..), Unstake(..), GetSharePrice(..))
import CantonLending (CantonLendingService(..), CantonPriceFeed(..), EscrowedCollateral(..), CantonDebtPosition(..), CantonLiquidationReceipt(..), CollateralType(..), CollateralConfig(..), defaultCTNConfig, defaultUSDCConfig, defaultUSDCxConfig, defaultSMUSDConfig, Lending_DepositCTN(..), Lending_Borrow(..), Lending_Repay(..), Lending_WithdrawCTN(..), Lending_Liquidate(..), PriceFeed_EmergencyUpdate(..))
import CantonBoostPool (CantonCoin(..))
import Compliance (ComplianceRegistry(..), ValidateMint(..), ValidateTransfer(..))
import Governance (GovernanceActionLog(..), ActionType(..))

-- ============================================================
--                     TEST HELPERS
-- ============================================================

testMpaHash : Text
testMpaHash = "a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6a1b2c3d4e5f6abcd"

testMpaUri : Text
testMpaUri = "https://minted.app/terms"

-- | Create a compliance registry for tests.
-- Uses the regulator as signatory and operator as observer.
createTestComplianceRegistry : Party -> Party -> Script (ContractId ComplianceRegistry)
createTestComplianceRegistry regulator operator = do
  now <- getTime
  submit regulator do
    createCmd ComplianceRegistry with
      regulator
      operator
      blacklisted = Set.empty
      frozen = Set.empty
      lastUpdated = now

-- | Create a compliance registry with specific blacklisted parties.
createTestComplianceRegistryWithBlacklist : Party -> Party -> [Party] -> Script (ContractId ComplianceRegistry)
createTestComplianceRegistryWithBlacklist regulator operator blocked = do
  now <- getTime
  submit regulator do
    createCmd ComplianceRegistry with
      regulator
      operator
      blacklisted = Set.fromList blocked
      frozen = Set.empty
      lastUpdated = now

-- ============================================================
--  1. INTEGRATION: MINT mUSD → STAKE → UNSTAKE
--     CantonDirectMint × CantonSMUSD cross-module
-- ============================================================

testMintStakeUnstakeFlow : Script ()
testMintStakeUnstakeFlow = do
  operator <- allocateParty "Operator"
  alice <- allocateParty "Alice"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  -- Create compliance registry
  complianceCid <- createTestComplianceRegistry regulator operator

  -- Step 1: Create mUSD for Alice (simulating a mint without full DirectMintService)
  musdCid <- submitMulti [operator, alice] [] do
    createCmd CantonMUSD with
      issuer = operator
      owner = alice
      amount = 1000.0
      agreementHash = testMpaHash
      agreementUri = testMpaUri
      privacyObservers = []

  -- Step 2: Create staking service
  stakingCid <- submit operator do
    createCmd CantonStakingService with
      operator
      totalShares = 0.0
      globalSharePrice = 1.0
      globalTotalAssets = 0.0
      globalTotalShares = 0.0
      lastSyncEpoch = 0
      cooldownSeconds = 0  -- No cooldown for test
      minDeposit = 1.0
      paused = False
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      observers = [alice]

  -- Step 3: Alice stakes mUSD → gets smUSD shares
  (stakingCid2, smusdCid) <- submit alice do
    exerciseCmd stakingCid Stake with
      user = alice
      musdCid

  -- Verify smUSD
  smusd <- queryContractId operator smusdCid
  let s = fromSome smusd
  assertMsg "Got 1000 shares" (s.shares == 1000.0)
  assertMsg "Entry price is 1.0" (s.entrySharePrice == 1.0)

  -- Step 4: Unstake → get mUSD back at current share price (1.0)
  (stakingCid3, musdBackCid) <- submit alice do
    exerciseCmd stakingCid2 Unstake with
      user = alice
      smusdCid

  musdBack <- queryContractId operator musdBackCid
  assertMsg "Got 1000 mUSD back" ((fromSome musdBack).amount == 1000.0)
  debug "✅ Integration 1: Mint → Stake → Unstake flow"

-- ============================================================
--  2. INTEGRATION: DEPOSIT → BORROW → REPAY → WITHDRAW
--     Full CantonLending lifecycle
-- ============================================================

testLendingFullCycleIntegration : Script ()
testLendingFullCycleIntegration = do
  operator <- allocateParty "Operator"
  user <- allocateParty "User"
  regulator <- allocateParty "Regulator"
  liquidator <- allocateParty "Liquidator"

  setTime (datetime 2026 Feb 6 12 0 0)

  -- Create compliance registry
  complianceCid <- createTestComplianceRegistry regulator operator

  -- Create price feed
  ctnFeedCid <- submit operator do
    createCmd CantonPriceFeed with
      operator
      symbol = "CTN"
      priceUsd = 0.17
      lastUpdated = datetime 2026 Feb 6 12 0 0
      source = "test"
      observers = [user, liquidator]

  -- Create lending service with all required fields
  serviceCid <- submit operator do
    createCmd CantonLendingService with
      operator
      configs = [defaultCTNConfig, defaultUSDCConfig, defaultUSDCxConfig, defaultSMUSDConfig]
      totalBorrows = 0.0
      interestRateBps = 500
      reserveFactorBps = 1000
      protocolReserves = 0.0
      minBorrow = 10.0
      closeFactorBps = 5000
      paused = False
      cantonSupplyCap = 10000000.0
      cantonCurrentSupply = 0.0
      directMintServiceName = "default"
      globalMintCap = 50000000.0
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      serviceName = "lending-test"
      observers = [user, liquidator]

  -- Step 1: Deposit 10000 CTN
  coinCid <- submitMulti [operator, user] [] do
    createCmd CantonCoin with
      issuer = operator
      owner = user
      amount = 10000.0
      privacyObservers = []

  (svc1, escrowCid) <- submit user do
    exerciseCmd serviceCid Lending_DepositCTN with
      user
      coinCid

  -- Step 2: Borrow 500 mUSD
  (svc2, debtCid, musdCid) <- submit user do
    exerciseCmd svc1 Lending_Borrow with
      user
      borrowAmount = 500.0
      escrowCids = [escrowCid]
      priceFeedCids = [ctnFeedCid]

  -- Verify debt
  debt <- queryContractId operator debtCid
  assertMsg "Borrowed 500" ((fromSome debt).principalDebt == 500.0)

  -- Step 3: Repay
  (svc3, newDebtCid) <- submitMulti [user] [operator] do
    exerciseCmd svc2 Lending_Repay with
      user
      musdCid
      debtCid

  -- Step 4: Withdraw
  (svc4, returnedCoinCid) <- submit user do
    exerciseCmd svc3 Lending_WithdrawCTN with
      user
      escrowCid
      withdrawAmount = 10000.0
      otherEscrowCids = []
      priceFeedCids = [ctnFeedCid]

  coin <- queryContractId operator returnedCoinCid
  assertMsg "Got 10000 CTN back" ((fromSome coin).amount == 10000.0)
  debug "✅ Integration 2: Deposit → Borrow → Repay → Withdraw lifecycle"

-- ============================================================
--  3. INTEGRATION: SHARE PRICE SYNC WITHIN BOUNDS
--     CantonSMUSD — verify SyncGlobalSharePrice within ±10%
-- ============================================================

testSharePriceSyncWithinBounds : Script ()
testSharePriceSyncWithinBounds = do
  operator <- allocateParty "Operator"
  alice <- allocateParty "Alice"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  stakingCid <- submit operator do
    createCmd CantonStakingService with
      operator
      totalShares = 100.0
      globalSharePrice = 1.0
      globalTotalAssets = 100.0
      globalTotalShares = 100.0
      lastSyncEpoch = 0
      cooldownSeconds = 86400
      minDeposit = 1.0
      paused = False
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      observers = [alice]

  -- Sync to 1.05 (5% increase — within 10% cap)
  stakingCid2 <- submit operator do
    exerciseCmd stakingCid SyncGlobalSharePrice with
      newGlobalSharePrice = 1.05
      newGlobalTotalAssets = 105.0
      newGlobalTotalShares = 100.0
      epochNumber = 1

  -- Verify the price was applied
  price <- submit operator do
    exerciseCmd stakingCid2 GetSharePrice
  assertMsg "Price updated to 1.05" (price == 1.05)
  debug "✅ Integration 3: Share price sync within bounds"

-- ============================================================
--  4. INTEGRATION: SHARE PRICE INCREASE > 10% REJECTED (FIX D-M09)
-- ============================================================

testSharePriceIncreaseTooLargeRejected : Script ()
testSharePriceIncreaseTooLargeRejected = do
  operator <- allocateParty "Operator"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  stakingCid <- submit operator do
    createCmd CantonStakingService with
      operator
      totalShares = 100.0
      globalSharePrice = 1.0
      globalTotalAssets = 100.0
      globalTotalShares = 100.0
      lastSyncEpoch = 0
      cooldownSeconds = 86400
      minDeposit = 1.0
      paused = False
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      observers = []

  -- Try to increase price by 15% (1.0 → 1.15) — should be rejected (max 10%)
  submitMustFail operator do
    exerciseCmd stakingCid SyncGlobalSharePrice with
      newGlobalSharePrice = 1.15
      newGlobalTotalAssets = 115.0
      newGlobalTotalShares = 100.0
      epochNumber = 1
  debug "✅ Integration 4: Share price increase >10% rejected (FIX D-M09)"

-- ============================================================
--  5. INTEGRATION: SHARE PRICE DECREASE > 10% REJECTED
-- ============================================================

testSharePriceDecreaseTooLargeRejected : Script ()
testSharePriceDecreaseTooLargeRejected = do
  operator <- allocateParty "Operator"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  stakingCid <- submit operator do
    createCmd CantonStakingService with
      operator
      totalShares = 100.0
      globalSharePrice = 1.0
      globalTotalAssets = 100.0
      globalTotalShares = 100.0
      lastSyncEpoch = 0
      cooldownSeconds = 86400
      minDeposit = 1.0
      paused = False
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      observers = []

  -- Try to decrease price by 15% (1.0 → 0.85) — should be rejected (max 10%)
  submitMustFail operator do
    exerciseCmd stakingCid SyncGlobalSharePrice with
      newGlobalSharePrice = 0.85
      newGlobalTotalAssets = 85.0
      newGlobalTotalShares = 100.0
      epochNumber = 1
  debug "✅ Integration 5: Share price decrease >10% rejected"

-- ============================================================
--  6. INTEGRATION: LIQUIDATION OF UNDERCOLLATERALIZED POSITION
--     CantonLending — price crash triggers liquidation
-- ============================================================

testLiquidationFlow : Script ()
testLiquidationFlow = do
  operator <- allocateParty "Operator"
  borrower <- allocateParty "Borrower"
  keeper <- allocateParty "Keeper"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  -- Price feeds
  ctnFeedCid <- submit operator do
    createCmd CantonPriceFeed with
      operator
      symbol = "CTN"
      priceUsd = 0.17
      lastUpdated = datetime 2026 Feb 6 12 0 0
      source = "test"
      observers = [borrower, keeper]

  -- Lending service
  serviceCid <- submit operator do
    createCmd CantonLendingService with
      operator
      configs = [defaultCTNConfig, defaultUSDCConfig, defaultUSDCxConfig, defaultSMUSDConfig]
      totalBorrows = 0.0
      interestRateBps = 500
      reserveFactorBps = 1000
      protocolReserves = 0.0
      minBorrow = 10.0
      closeFactorBps = 5000
      paused = False
      cantonSupplyCap = 10000000.0
      cantonCurrentSupply = 0.0
      directMintServiceName = "default"
      globalMintCap = 50000000.0
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      serviceName = "lending-liq"
      observers = [borrower, keeper]

  -- Deposit collateral + borrow near limit
  coinCid <- submitMulti [operator, borrower] [] do
    createCmd CantonCoin with
      issuer = operator
      owner = borrower
      amount = 10000.0
      privacyObservers = []

  (svc1, escrowCid) <- submit borrower do
    exerciseCmd serviceCid Lending_DepositCTN with
      user = borrower
      coinCid

  (svc2, debtCid, _musdCid) <- submit borrower do
    exerciseCmd svc1 Lending_Borrow with
      user = borrower
      borrowAmount = 1100.0
      escrowCids = [escrowCid]
      priceFeedCids = [ctnFeedCid]

  -- Crash price → position undercollateralized
  passTime (minutes 6)
  crashedFeedCid <- submit operator do
    exerciseCmd ctnFeedCid PriceFeed_EmergencyUpdate with
      newPriceUsd = 0.10
      reason = "CTN crash"

  -- Keeper gets mUSD for repayment
  liqMusdCid <- submitMulti [operator, keeper] [] do
    createCmd CantonMUSD with
      issuer = operator
      owner = keeper
      amount = 550.0
      agreementHash = testMpaHash
      agreementUri = testMpaUri
      privacyObservers = []

  -- Liquidate position
  (svc3, receiptCid) <- submitMulti [keeper] [operator] do
    exerciseCmd svc2 Lending_Liquidate with
      liquidator = keeper
      borrower
      repayAmount = 550.0
      targetEscrowCid = escrowCid
      debtCid
      musdCid = liqMusdCid
      escrowCids = [escrowCid]
      priceFeedCids = [crashedFeedCid]

  -- Verify receipt
  receipt <- queryContractId operator receiptCid
  let r = fromSome receipt
  assertMsg "Receipt records debt repaid" (r.debtRepaid > 0.0)
  assertMsg "Receipt records seized collateral" (r.collateralSeized > 0.0)
  debug "✅ Integration 6: Liquidation of undercollateralized position"

-- ============================================================
--  7. INTEGRATION: HEALTHY POSITION CANNOT BE LIQUIDATED
-- ============================================================

testHealthyPositionNotLiquidatable : Script ()
testHealthyPositionNotLiquidatable = do
  operator <- allocateParty "Operator"
  borrower <- allocateParty "Borrower"
  keeper <- allocateParty "Keeper"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  ctnFeedCid <- submit operator do
    createCmd CantonPriceFeed with
      operator
      symbol = "CTN"
      priceUsd = 0.17
      lastUpdated = datetime 2026 Feb 6 12 0 0
      source = "test"
      observers = [borrower, keeper]

  serviceCid <- submit operator do
    createCmd CantonLendingService with
      operator
      configs = [defaultCTNConfig, defaultUSDCConfig, defaultUSDCxConfig, defaultSMUSDConfig]
      totalBorrows = 0.0
      interestRateBps = 500
      reserveFactorBps = 1000
      protocolReserves = 0.0
      minBorrow = 10.0
      closeFactorBps = 5000
      paused = False
      cantonSupplyCap = 10000000.0
      cantonCurrentSupply = 0.0
      directMintServiceName = "default"
      globalMintCap = 50000000.0
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      serviceName = "lending-healthy"
      observers = [borrower, keeper]

  coinCid <- submitMulti [operator, borrower] [] do
    createCmd CantonCoin with
      issuer = operator
      owner = borrower
      amount = 10000.0
      privacyObservers = []

  (svc1, escrowCid) <- submit borrower do
    exerciseCmd serviceCid Lending_DepositCTN with
      user = borrower
      coinCid

  -- Borrow a small amount (well-collateralized)
  (svc2, debtCid, _musdCid) <- submit borrower do
    exerciseCmd svc1 Lending_Borrow with
      user = borrower
      borrowAmount = 100.0
      escrowCids = [escrowCid]
      priceFeedCids = [ctnFeedCid]

  liqMusdCid <- submitMulti [operator, keeper] [] do
    createCmd CantonMUSD with
      issuer = operator
      owner = keeper
      amount = 50.0
      agreementHash = testMpaHash
      agreementUri = testMpaUri
      privacyObservers = []

  -- Should fail — position is healthy
  submitMustFail keeper do
    exerciseCmd svc2 Lending_Liquidate with
      liquidator = keeper
      borrower
      repayAmount = 50.0
      targetEscrowCid = escrowCid
      debtCid
      musdCid = liqMusdCid
      escrowCids = [escrowCid]
      priceFeedCids = [ctnFeedCid]
  debug "✅ Integration 7: Healthy position cannot be liquidated"

-- ============================================================
--  8. NOTE: sMUSD ESCROWED IN LENDING → BOOSTPOOL BLOCKED (FIX D-M04)
--     CantonLending × CantonBoostPool cross-module invariant
--
--     This test validates FIX D-M04 — preventing a user from using
--     sMUSD that is already escrowed as lending collateral to qualify for
--     BoostPool deposits. The Deposit choice now checks via lookupByKey
--     that no EscrowedCollateral exists for (operator, user, CTN_SMUSD).
--     Full BoostPool service setup requires extensive template
--     instantiation (pool config, reward tracking, etc.) and is tested
--     in CantonBoostPool's own unit tests.
-- ============================================================

-- ============================================================
--  9. INTEGRATION: COMPLIANCE BLOCKS BLACKLISTED TRANSFERS (FIX D-M08)
--     CantonDirectMint × Compliance cross-module
-- ============================================================

testComplianceBlocksBlacklistedTransfer : Script ()
testComplianceBlocksBlacklistedTransfer = do
  operator <- allocateParty "Operator"
  alice <- allocateParty "Alice"
  bob <- allocateParty "Bob"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  -- Create compliance registry with Bob blacklisted
  complianceCid <- createTestComplianceRegistryWithBlacklist regulator operator [bob]

  -- Create mUSD for Alice
  musdCid <- submitMulti [operator, alice] [] do
    createCmd CantonMUSD with
      issuer = operator
      owner = alice
      amount = 100.0
      agreementHash = testMpaHash
      agreementUri = testMpaUri
      privacyObservers = []

  -- Alice tries to transfer mUSD to blacklisted Bob → should fail
  submitMustFail alice do
    exerciseCmd musdCid CantonMUSD_Transfer with
      newOwner = bob
      complianceRegistryCid = complianceCid
  debug "✅ Integration 9: Compliance blocks transfer to blacklisted party (FIX D-M08)"

-- ============================================================
--  10. INTEGRATION: SUPPLY CAP COORDINATION (FIX D-M02)
--      CantonLending × CantonDirectMint cross-module
-- ============================================================

testSupplyCapCoordination : Script ()
testSupplyCapCoordination = do
  operator <- allocateParty "Operator"
  user <- allocateParty "User"
  regulator <- allocateParty "Regulator"

  setTime (datetime 2026 Feb 6 12 0 0)

  complianceCid <- createTestComplianceRegistry regulator operator

  -- Create DirectMintService with a key — tests FIX D-M02
  _dmServiceCid <- submit operator do
    createCmd CantonDirectMintService with
      operator
      usdcIssuer = operator
      usdcxIssuer = None
      mintFeeBps = 30
      redeemFeeBps = 30
      minAmount = 1.0
      maxAmount = 1000000.0
      supplyCap = 50000000.0
      currentSupply = 40000000.0  -- Already near cap
      accumulatedFees = 0.0
      paused = False
      validators = []
      targetChainId = 1
      targetTreasury = "0x1234"
      nextNonce = 1
      dailyMintLimit = 10000000.0
      dailyMinted = 0.0
      dailyBurned = 0.0
      lastRateLimitReset = datetime 2026 Feb 6 0 0 0
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      authorizedMinters = [user]
      serviceName = "default"  -- FIX D-M02: Key field for cross-module lookup

  -- Create Lending service pointing to the DirectMint service
  ctnFeedCid <- submit operator do
    createCmd CantonPriceFeed with
      operator
      symbol = "CTN"
      priceUsd = 0.17
      lastUpdated = datetime 2026 Feb 6 12 0 0
      source = "test"
      observers = [user]

  lendingCid <- submit operator do
    createCmd CantonLendingService with
      operator
      configs = [defaultCTNConfig, defaultUSDCConfig, defaultUSDCxConfig, defaultSMUSDConfig]
      totalBorrows = 0.0
      interestRateBps = 500
      reserveFactorBps = 1000
      protocolReserves = 0.0
      minBorrow = 10.0
      closeFactorBps = 5000
      paused = False
      cantonSupplyCap = 10000000.0
      cantonCurrentSupply = 0.0
      directMintServiceName = "default"  -- Points to DirectMint via key
      globalMintCap = 50000000.0         -- Same cap: DM at 40M → only 10M left for lending
      complianceRegistryCid = complianceCid
      mpaHash = testMpaHash
      mpaUri = testMpaUri
      serviceName = "lending-cap"
      observers = [user]

  -- Deposit collateral
  coinCid <- submitMulti [operator, user] [] do
    createCmd CantonCoin with
      issuer = operator
      owner = user
      amount = 1000000.0
      privacyObservers = []

  (svc1, escrowCid) <- submit user do
    exerciseCmd lendingCid Lending_DepositCTN with
      user
      coinCid

  -- Try to borrow 11M mUSD → should fail because DM has 40M + 11M = 51M > 50M globalMintCap
  submitMustFail user do
    exerciseCmd svc1 Lending_Borrow with
      user
      borrowAmount = 11000000.0
      escrowCids = [escrowCid]
      priceFeedCids = [ctnFeedCid]
  debug "✅ Integration 10: Supply cap coordination between Lending + DirectMint (FIX D-M02)"
