-- | CantonLending
-- Canton-native lending module with actual token escrowing
--
-- Architecture:
--   Users deposit Canton-native assets (CantonCoin, CantonUSDC, USDCx, CantonSMUSD)
--   as collateral into escrowed positions. They borrow CantonMUSD against this collateral.
--
--   Price feeds from Tradecraft DEX API (primary, no auth) and Temple DEX API (fallback).
--   Liquidations seize escrowed collateral and route through Tradecraft/Temple AMMs.
--
--   Unlike V3.daml's text-based Vault system, this module escrows ACTUAL token contracts.
--   Collateral is locked on-ledger — not tracked by reference to Ethereum.
--
-- Supported Collateral:
--   - CantonCoin (CTN)   — volatile, Temple DEX price feed, ~65% LTV
--   - CantonUSDC         — stable 1:1, hardcoded price, ~95% LTV
--   - USDCx              — stable 1:1 (xReserve bridged), ~95% LTV
--   - CantonSMUSD        — yield-bearing, globalSharePrice feed, ~90% LTV
--
-- Revenue Model:
--   Interest on borrows → routed to sMUSD stakers (mirroring Ethereum BorrowModule)
--   Liquidation penalties → keeper bonus + protocol fee
--   Reserve factor → protocol reserves

module CantonLending where

import DA.Time
import DA.Text qualified as DA.Text
import DA.Optional (fromOptional)
import DA.List (sort, length, (!!))
import CantonDirectMint (CantonMUSD(..), CantonMUSD_Burn(..), CantonMUSD_Split(..), CantonUSDC(..), USDCx(..), Money, Bps, BurnRateLimiter(..), BurnLimit_RecordBurn(..))
import CantonSMUSD (CantonSMUSD(..))
import CantonBoostPool (CantonCoin(..))
import UserPrivacySettings (lookupUserObservers)
import Governance (GovernanceActionLog(..), ActionType(..), ConsumeProof(..))
import Compliance (ComplianceRegistry, ValidateTransfer(..))

-- ============================================================
--                     SECTION 1: COLLATERAL CONFIG
-- ============================================================

-- | Collateral asset type tag
data CollateralType
  = CTN_Coin       -- CantonCoin (volatile)
  | CTN_USDC       -- CantonUSDC (stable)
  | CTN_USDCx      -- USDCx / xReserve bridged (stable)
  | CTN_SMUSD      -- CantonSMUSD (yield-bearing stable)
  deriving (Eq, Show, Ord)

-- | Per-asset collateral parameters (mirrors CollateralVault.sol CollateralConfig)
data CollateralConfig = CollateralConfig with
    collateralType         : CollateralType
    enabled                : Bool
    collateralFactorBps    : Bps    -- Max LTV. e.g. 6500 = 65% for CTN, 9500 = 95% for USDC
    liquidationThresholdBps : Bps   -- Liquidation triggers here. e.g. 7500 = 75%
    liquidationPenaltyBps  : Bps    -- Penalty on seized collateral. e.g. 500 = 5%
    liquidationBonusBps    : Bps    -- Keeper bonus from penalty. e.g. 250 = 2.5%
  deriving (Eq, Show)

-- | Default configs for each collateral type
defaultCTNConfig : CollateralConfig
defaultCTNConfig = CollateralConfig with
    collateralType = CTN_Coin
    enabled = True
    collateralFactorBps = 6500       -- 65% LTV — volatile asset
    liquidationThresholdBps = 7500   -- 75% — liquidation trigger
    liquidationPenaltyBps = 1000     -- 10% penalty
    liquidationBonusBps = 500        -- 5% keeper bonus

defaultUSDCConfig : CollateralConfig
defaultUSDCConfig = CollateralConfig with
    collateralType = CTN_USDC
    enabled = True
    collateralFactorBps = 9500       -- 95% LTV — stable
    liquidationThresholdBps = 9700   -- 97% — tight spread
    liquidationPenaltyBps = 300      -- 3% penalty
    liquidationBonusBps = 150        -- 1.5% keeper bonus

defaultUSDCxConfig : CollateralConfig
defaultUSDCxConfig = CollateralConfig with
    collateralType = CTN_USDCx
    enabled = True
    collateralFactorBps = 9500
    liquidationThresholdBps = 9700
    liquidationPenaltyBps = 300
    liquidationBonusBps = 150

defaultSMUSDConfig : CollateralConfig
defaultSMUSDConfig = CollateralConfig with
    collateralType = CTN_SMUSD
    enabled = True
    collateralFactorBps = 9000       -- 90% LTV — yield-bearing, slight cooldown risk
    liquidationThresholdBps = 9300   -- 93%
    liquidationPenaltyBps = 400      -- 4% penalty
    liquidationBonusBps = 200        -- 2% keeper bonus

-- ============================================================
--                     SECTION 2: CANTON PRICE FEED
-- ============================================================

-- | CantonPriceFeed — Source-agnostic oracle for Canton-native assets.
-- Primary: Tradecraft DEX API (GET /v1/ratio/CC/USDCx — no auth, AMM-based)
-- Fallback: Temple DEX API (Amulet/USDCx pair — JWT auth)
-- Operator syncs prices from either source via relay service.
-- Each asset gets its own feed. Stale feeds block borrows/withdrawals
-- but NOT liquidations (liquidations use unsafe/stale-tolerant path).
template CantonPriceFeed
  with
    operator    : Party
    symbol      : Text           -- e.g. "CTN", "USDC", "USDCx", "sMUSD"
    priceUsd    : Money          -- USD price (18 decimals)
    lastUpdated : Time
    source      : Text           -- e.g. "temple-dex-twap", "hardcoded", "smusd-share-price"
    observers   : [Party]
  where
    signatory operator
    observer observers

    key (operator, symbol) : (Party, Text)
    maintainer key._1

    ensure priceUsd > 0.0

    -- | Get price with staleness check (for borrows / withdrawals)
    nonconsuming choice PriceFeed_GetPrice : Money
      with
        requester    : Party
        maxStaleness : RelTime
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester `elem` observers || requester == operator)
        now <- getTime
        let age = subTime now lastUpdated
        assertMsg "PRICE_STALE" (age <= maxStaleness)
        return priceUsd

    -- | Get price WITHOUT staleness check (for liquidation path)
    -- Liquidations must proceed even with stale prices to protect protocol solvency
    nonconsuming choice PriceFeed_GetPriceUnsafe : Money
      with
        requester : Party
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester `elem` observers || requester == operator)
        return priceUsd

    -- | Update price from Tradecraft/Temple DEX API
    -- Governance-gated to prevent unilateral oracle manipulation
    choice PriceFeed_Update : ContractId CantonPriceFeed
      with
        newPriceUsd : Money
        newSource   : Text
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "PRICE_MUST_BE_POSITIVE" (newPriceUsd > 0.0)
        -- Minimum 10-second interval between updates to prevent rapid oscillation
        now <- getTime
        let timeSinceUpdate = subTime now lastUpdated
        assertMsg "UPDATE_TOO_FREQUENT" (timeSinceUpdate >= seconds 10)
        -- Cap price movement to ±50% per update to prevent oracle manipulation
        let maxPrice = priceUsd * 1.5
        let minPrice = priceUsd * 0.5
        assertMsg "PRICE_MOVE_TOO_LARGE" (newPriceUsd >= minPrice && newPriceUsd <= maxPrice)
        create this with
          priceUsd = newPriceUsd
          lastUpdated = now
          source = newSource

    -- | Emergency price override (bypasses movement cap)
    -- Only for circuit-breaker scenarios where price moved >50%
    -- Minimum 5-minute cooldown between emergency updates
    choice PriceFeed_EmergencyUpdate : ContractId CantonPriceFeed
      with
        newPriceUsd : Money
        reason      : Text
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "PRICE_MUST_BE_POSITIVE" (newPriceUsd > 0.0)
        assertMsg "REASON_REQUIRED" (DA.Text.length reason > 0)
        now <- getTime
        let timeSinceUpdate = subTime now lastUpdated
        assertMsg "EMERGENCY_UPDATE_COOLDOWN" (timeSinceUpdate >= minutes 5)
        create this with
          priceUsd = newPriceUsd
          lastUpdated = now
          source = "emergency-override: " <> reason

-- ============================================================
--               SECTION 2b: MULTI-ORACLE FEED
-- ============================================================

-- | MultiOracleFeed — Aggregates multiple independent price feeds for an asset.
-- Instead of relying on a single oracle per asset, this template
-- reads from 2+ independent CantonPriceFeed sources and uses the median price.
-- This prevents any single oracle from manipulating prices.
--
-- The lending service reads from MultiOracleFeed instead of individual feeds.
-- Each individual feed is still independently updatable by its source.
template MultiOracleFeed
  with
    operator       : Party
    symbol         : Text                     -- e.g. "CTN", "sMUSD"
    feedCids       : [ContractId CantonPriceFeed]  -- Individual oracle feed CIDs
    minFeeds       : Int                      -- Minimum feeds that must agree (quorum)
    maxDeviationBps : Int                     -- Max allowed deviation between feeds (e.g. 500 = 5%)
    observers      : [Party]
  where
    signatory operator
    observer observers

    ensure minFeeds >= 2 && DA.List.length feedCids >= minFeeds && maxDeviationBps > 0

    key (operator, "multi-" <> symbol) : (Party, Text)
    maintainer key._1

    -- | Get median price from multiple feeds with staleness check
    -- Aggregates prices, checks deviation, returns median
    nonconsuming choice MultiOracle_GetPrice : Money
      with
        requester    : Party
        maxStaleness : RelTime
      controller requester
      do
        -- Read all individual feed prices (with staleness check)
        prices <- mapA (\cid -> exercise cid PriceFeed_GetPrice with requester; maxStaleness) feedCids
        assertMsg "INSUFFICIENT_ORACLE_RESPONSES" (DA.List.length prices >= minFeeds)

        -- Check deviation between feeds
        let sorted = sort prices
        let maxP = sorted !! (DA.List.length sorted - 1)
        let minP = sorted !! 0
        let deviation = if minP > 0.0
              then ((maxP - minP) / minP) * 10000.0
              else 0.0
        assertMsg "ORACLE_PRICE_DEVIATION_TOO_LARGE" (deviation <= intToNumeric maxDeviationBps)

        -- Return median
        let mid = DA.List.length sorted / 2
        return (sorted !! mid)

    -- | Get median price WITHOUT staleness check (for liquidation path)
    nonconsuming choice MultiOracle_GetPriceUnsafe : Money
      with
        requester : Party
      controller requester
      do
        prices <- mapA (\cid -> exercise cid PriceFeed_GetPriceUnsafe with requester) feedCids
        assertMsg "INSUFFICIENT_ORACLE_RESPONSES" (DA.List.length prices >= minFeeds)
        let sorted = sort prices
        -- For unsafe path: still check deviation but with wider tolerance (10%)
        let maxP = sorted !! (DA.List.length sorted - 1)
        let minP = sorted !! 0
        let deviation = if minP > 0.0
              then ((maxP - minP) / minP) * 10000.0
              else 0.0
        assertMsg "ORACLE_PRICE_DEVIATION_TOO_LARGE_UNSAFE" (deviation <= intToNumeric (maxDeviationBps * 2))
        let mid = DA.List.length sorted / 2
        return (sorted !! mid)

    -- | Update feed list (admin)
    choice MultiOracle_UpdateFeeds : ContractId MultiOracleFeed
      with
        newFeedCids : [ContractId CantonPriceFeed]
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "INSUFFICIENT_FEEDS" (DA.List.length newFeedCids >= minFeeds)
        create this with feedCids = newFeedCids

-- ============================================================
--               SECTION 2c: KEEPER REGISTRY
-- ============================================================

-- | KeeperBond — On-ledger bond required for liquidation keepers.
-- Keepers must register and deposit a bond (in mUSD)
-- before they can execute liquidations. The bond is slashable if the
-- keeper submits a liquidation for a healthy position (disincentivizes
-- griefing attacks). This replaces the fully-open liquidation model.
template KeeperBond
  with
    operator : Party
    keeper   : Party
    bondAmount : Money      -- mUSD bond deposited
    registeredAt : Time     -- When keeper registered
    slashCount : Int        -- Number of times keeper has been slashed
    active : Bool           -- Whether keeper is currently active
  where
    signatory operator, keeper
    ensure bondAmount > 0.0

    key (operator, keeper) : (Party, Party)
    maintainer key._1

    -- | Deactivate keeper (admin)
    choice KeeperBond_Deactivate : ContractId KeeperBond
      controller operator
      do create this with active = False

    -- | Reactivate keeper (admin)
    choice KeeperBond_Activate : ContractId KeeperBond
      controller operator
      do create this with active = True

    -- | Slash bond (called by LendingService if keeper griefs)
    choice KeeperBond_Slash : ContractId KeeperBond
      with
        slashAmount : Money
        reason : Text
      controller operator
      do
        assertMsg "SLASH_EXCEEDS_BOND" (slashAmount <= bondAmount)
        create this with
          bondAmount = bondAmount - slashAmount
          slashCount = slashCount + 1
          active = bondAmount - slashAmount > 0.0  -- Auto-deactivate if bond depleted

-- ============================================================
--                     SECTION 3: ESCROWED COLLATERAL POSITION
-- ============================================================

-- | EscrowedCollateral — Actual token contracts locked as collateral.
-- This is the key difference from V3.daml: we CONSUME the token contract
-- and track the escrowed amount. Withdrawal recreates the token.
--
-- Each user has one EscrowedCollateral per collateral type.
-- Multi-collateral users have multiple positions.
template EscrowedCollateral
  with
    operator       : Party
    owner          : Party
    collateralType : CollateralType
    amount         : Money          -- Escrowed amount
    depositedAt    : Time           -- First deposit time
    lastUpdatedAt  : Time           -- Last deposit/withdrawal time
    -- Track original token provenance for USDCx (restored on withdrawal)
    originalSourceChain : Optional Text   -- Original USDCx sourceChain (None for non-USDCx)
    originalCctpNonce   : Optional Int    -- Original USDCx cctpNonce (None for non-USDCx)
    privacyObservers : [Party]      -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory operator, owner
    observer privacyObservers

    ensure amount > 0.0

    key (operator, owner, collateralType) : (Party, Party, CollateralType)
    maintainer key._1

    -- | Update observers from user's privacy settings
    choice Escrow_UpdateObservers : ContractId EscrowedCollateral
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    -- | Add more collateral to this position (consuming choice — recreates with new total)
    -- Operator-controlled — called by LendingService after verifying token proof
    choice Escrow_AddCollateral : ContractId EscrowedCollateral
      with
        addAmount : Money
      controller operator
      do
        assertMsg "ADD_AMOUNT_POSITIVE" (addAmount > 0.0)
        now <- getTime
        create this with
          amount = amount + addAmount
          lastUpdatedAt = now

    -- | Withdraw collateral (partial) — health check done at LendingService level
    choice Escrow_WithdrawPartial : (ContractId EscrowedCollateral, Money)
      with
        withdrawAmount : Money
      controller operator  -- Only service can withdraw (after health check)
      do
        assertMsg "WITHDRAW_POSITIVE" (withdrawAmount > 0.0)
        assertMsg "INSUFFICIENT_COLLATERAL" (amount > withdrawAmount)
        now <- getTime
        newEscrow <- create this with
          amount = amount - withdrawAmount
          lastUpdatedAt = now
        return (newEscrow, withdrawAmount)

    -- | Withdraw ALL collateral (consuming) — health check done at LendingService level
    choice Escrow_WithdrawAll : Money
      controller operator
      do
        return amount

    -- | Seize collateral for liquidation (operator-controlled)
    choice Escrow_Seize : (Optional (ContractId EscrowedCollateral), Money)
      with
        seizeAmount : Money
      controller operator
      do
        assertMsg "SEIZE_POSITIVE" (seizeAmount > 0.0)
        assertMsg "SEIZE_EXCEEDS_BALANCE" (seizeAmount <= amount)
        now <- getTime
        if seizeAmount == amount
          then return (None, seizeAmount)
          else do
            newEscrow <- create this with
              amount = amount - seizeAmount
              lastUpdatedAt = now
            return (Some newEscrow, seizeAmount)

-- ============================================================
--                     SECTION 4: DEBT POSITION
-- ============================================================

-- | CantonDebtPosition — Tracks mUSD borrowed against escrowed collateral.
-- Interest accrues per-second using Compound-style model.
-- One position per user (can have multiple collateral types backing it).
template CantonDebtPosition
  with
    operator          : Party
    borrower          : Party
    principalDebt     : Money       -- Original borrowed amount
    accruedInterest   : Money       -- Interest accumulated since last accrual
    lastAccrualTime   : Time        -- Last interest accrual timestamp
    interestRateBps   : Bps         -- Current annual interest rate
    privacyObservers  : [Party]     -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory operator, borrower
    observer privacyObservers

    ensure principalDebt >= 0.0 && accruedInterest >= 0.0

    key (operator, borrower) : (Party, Party)
    maintainer key._1

    -- | Update observers from user's privacy settings
    choice Debt_UpdateObservers : ContractId CantonDebtPosition
      with
        newObservers : [Party]
      controller borrower
      do create this with privacyObservers = newObservers

    -- | Calculate total debt (principal + accrued + new interest)
    nonconsuming choice Debt_GetTotalDebt : Money
      with
        requester : Party
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester == borrower || requester == operator)
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastAccrualTime)
        let secondsElapsed : Money = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        return (principalDebt + accruedInterest + newInterest)

    -- | Accrue interest and increase debt (called before borrow/repay/liquidate)
    choice Debt_AccrueInterest : ContractId CantonDebtPosition
      with
        caller : Party
      controller operator
      do
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastAccrualTime)
        let secondsElapsed : Money = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        create this with
          accruedInterest = accruedInterest + newInterest
          lastAccrualTime = now

    -- | Add to principal (new borrow)
    choice Debt_IncreasePrincipal : ContractId CantonDebtPosition
      with
        additionalBorrow : Money
      controller operator
      do
        assertMsg "BORROW_POSITIVE" (additionalBorrow > 0.0)
        create this with
          principalDebt = principalDebt + additionalBorrow

    -- | Repay debt: interest first, then principal
    choice Debt_Repay : (ContractId CantonDebtPosition, Money)
      with
        repayAmount : Money
      controller operator
      do
        assertMsg "REPAY_POSITIVE" (repayAmount > 0.0)
        let totalDebt = principalDebt + accruedInterest
        assertMsg "REPAY_EXCEEDS_DEBT" (repayAmount <= totalDebt)
        -- Pay interest first, then principal
        let (remainingRepay, newAccrued) =
              if repayAmount >= accruedInterest
                then (repayAmount - accruedInterest, 0.0)
                else (0.0, accruedInterest - repayAmount)
        let newPrincipal = if remainingRepay > principalDebt
                           then 0.0
                           else principalDebt - remainingRepay
        let interestPaid = accruedInterest - newAccrued
        newDebt <- create this with
          principalDebt = newPrincipal
          accruedInterest = newAccrued
        return (newDebt, interestPaid)

    -- | Reduce debt after liquidation (operator-controlled)
    choice Debt_ReduceForLiquidation : ContractId CantonDebtPosition
      with
        reductionAmount : Money
      controller operator
      do
        let totalDebt = principalDebt + accruedInterest
        assertMsg "REDUCTION_EXCEEDS_DEBT" (reductionAmount <= totalDebt)
        let (remainingReduction, newAccrued) =
              if reductionAmount >= accruedInterest
                then (reductionAmount - accruedInterest, 0.0)
                else (0.0, accruedInterest - reductionAmount)
        let newPrincipal = if remainingReduction > principalDebt
                           then 0.0
                           else principalDebt - remainingReduction
        create this with
          principalDebt = newPrincipal
          accruedInterest = newAccrued

    -- | Update interest rate (synced from InterestRateService)
    choice Debt_UpdateRate : ContractId CantonDebtPosition
      with
        newRateBps : Bps
      controller operator
      do
        assertMsg "RATE_NON_NEGATIVE" (newRateBps >= 0)
        assertMsg "RATE_MAX_100_PERCENT" (newRateBps <= 10000)
        create this with interestRateBps = newRateBps

-- ============================================================
--                     SECTION 5: LENDING SERVICE
-- ============================================================

-- | CantonLendingService — Central coordinator for Canton-native lending.
-- Manages collateral configs, orchestrates deposits/borrows/liquidations.
-- Operator syncs prices from Tradecraft (primary) / Temple (fallback) DEX APIs.
template CantonLendingService
  with
    operator           : Party
    configs            : [CollateralConfig]     -- Per-asset configs
    totalBorrows       : Money                  -- Global total borrowed
    -- Lending mUSD supply cap (prevents unbounded minting outside global cap)
    lendingSupplyCap   : Money                  -- Max mUSD mintable via lending
    interestRateBps    : Bps                    -- Current global borrow rate
    reserveFactorBps   : Bps                    -- Protocol reserve cut (e.g. 1000 = 10%)
    protocolReserves   : Money                  -- Accumulated protocol reserves
    minBorrow          : Money                  -- Minimum borrow amount (anti-dust)
    closeFactorBps     : Bps                    -- Max % of debt liquidatable per call
    paused             : Bool
    -- Keeper bond requirement for liquidations
    minKeeperBond      : Money                  -- Minimum bond required to liquidate
    -- Master Participation Agreement (for minted mUSD)
    mpaHash            : Text
    mpaUri             : Text
    -- Compliance integration for blacklist/freeze checks
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    observers          : [Party]
  where
    signatory operator
    observer observers

    ensure totalBorrows >= 0.0
        && lendingSupplyCap > 0.0
        && reserveFactorBps >= 0 && reserveFactorBps <= 5000
        && closeFactorBps > 0 && closeFactorBps <= 10000
        && minBorrow > 0.0
        && minKeeperBond >= 0.0
        && DA.Text.length mpaHash == 64
        && DA.Text.length mpaUri > 0

    -- ──────────────────────────────────────────────────────
    --  DEPOSIT COLLATERAL
    -- ──────────────────────────────────────────────────────

    -- | Deposit CantonCoin as collateral (escrows the actual token)
    choice Lending_DepositCTN : (ContractId CantonLendingService, ContractId EscrowedCollateral)
      with
        user    : Party
        coinCid : ContractId CantonCoin
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        -- Compliance check before deposit
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()
        coin <- fetch coinCid
        assertMsg "NOT_OWNER" (coin.owner == user)
        -- Explicit issuer validation (defence-in-depth beyond DAML's archive semantics)
        assertMsg "CTN_ISSUER_MISMATCH" (coin.issuer == operator)
        let cfg = getConfig CTN_Coin configs
        assertMsg "CTN_NOT_ENABLED" cfg.enabled

        -- Consume the actual token (escrow it)
        archive coinCid

        -- Look up existing escrow by key; merge if found, create if not
        now <- getTime
        userObs <- lookupUserObservers operator user
        existingEscrowOpt <- lookupByKey @EscrowedCollateral (operator, user, CTN_Coin)
        escrowCid <- case existingEscrowOpt of
          Some existCid -> exercise existCid Escrow_AddCollateral with
            addAmount = coin.amount
          None -> create EscrowedCollateral with
            operator
            owner = user
            collateralType = CTN_Coin
            amount = coin.amount
            depositedAt = now
            lastUpdatedAt = now
            originalSourceChain = None
            originalCctpNonce = None
            privacyObservers = userObs

        newService <- create this with {}
        return (newService, escrowCid)

    -- | Deposit CantonUSDC as collateral
    choice Lending_DepositUSDC : (ContractId CantonLendingService, ContractId EscrowedCollateral)
      with
        user    : Party
        usdcCid : ContractId CantonUSDC
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        -- Compliance check before deposit
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()
        usdc <- fetch usdcCid
        assertMsg "NOT_OWNER" (usdc.owner == user)
        -- Explicit issuer validation (defence-in-depth beyond DAML's archive semantics)
        assertMsg "USDC_ISSUER_MISMATCH" (usdc.issuer == operator)
        let cfg = getConfig CTN_USDC configs
        assertMsg "USDC_NOT_ENABLED" cfg.enabled

        archive usdcCid

        -- Look up existing escrow by key; merge if found
        now <- getTime
        userObs <- lookupUserObservers operator user
        existingEscrowOpt <- lookupByKey @EscrowedCollateral (operator, user, CTN_USDC)
        escrowCid <- case existingEscrowOpt of
          Some existCid -> exercise existCid Escrow_AddCollateral with
            addAmount = usdc.amount
          None -> create EscrowedCollateral with
            operator
            owner = user
            collateralType = CTN_USDC
            amount = usdc.amount
            depositedAt = now
            lastUpdatedAt = now
            originalSourceChain = None
            originalCctpNonce = None
            privacyObservers = userObs

        newService <- create this with {}
        return (newService, escrowCid)

    -- | Deposit USDCx as collateral
    choice Lending_DepositUSDCx : (ContractId CantonLendingService, ContractId EscrowedCollateral)
      with
        user     : Party
        usdcxCid : ContractId USDCx
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        -- Compliance check before deposit
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()
        usdcx <- fetch usdcxCid
        assertMsg "NOT_OWNER" (usdcx.owner == user)
        -- Explicit issuer validation. Note: in production, USDCx issuer may be
        -- the xReserve protocol operator rather than the lending operator. If these differ,
        -- add a configurable `expectedUsdcxIssuer` field to CantonLendingService.
        assertMsg "USDCx_ISSUER_MISMATCH" (usdcx.issuer == operator)
        let cfg = getConfig CTN_USDCx configs
        assertMsg "USDCx_NOT_ENABLED" cfg.enabled

        archive usdcxCid

        -- Look up existing escrow by key; merge if found
        now <- getTime
        userObs <- lookupUserObservers operator user
        existingEscrowOpt <- lookupByKey @EscrowedCollateral (operator, user, CTN_USDCx)
        escrowCid <- case existingEscrowOpt of
          Some existCid -> exercise existCid Escrow_AddCollateral with
            addAmount = usdcx.amount
          -- Store original USDCx provenance for restoration on withdrawal
          None -> create EscrowedCollateral with
            operator
            owner = user
            collateralType = CTN_USDCx
            amount = usdcx.amount
            depositedAt = now
            lastUpdatedAt = now
            originalSourceChain = Some usdcx.sourceChain
            originalCctpNonce = Some usdcx.cctpNonce
            privacyObservers = userObs

        newService <- create this with {}
        return (newService, escrowCid)

    -- | Deposit CantonSMUSD as collateral
    choice Lending_DepositSMUSD : (ContractId CantonLendingService, ContractId EscrowedCollateral)
      with
        user     : Party
        smusdCid : ContractId CantonSMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        -- Compliance check before deposit
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()
        smusd <- fetch smusdCid
        assertMsg "NOT_OWNER" (smusd.owner == user)
        -- Explicit issuer validation (defence-in-depth beyond DAML's archive semantics)
        assertMsg "SMUSD_ISSUER_MISMATCH" (smusd.issuer == operator)
        let cfg = getConfig CTN_SMUSD configs
        assertMsg "SMUSD_NOT_ENABLED" cfg.enabled

        archive smusdCid

        -- Look up existing escrow by key; merge if found
        now <- getTime
        -- sMUSD amount = shares (valued at share price via price feed)
        userObs <- lookupUserObservers operator user
        existingEscrowOpt <- lookupByKey @EscrowedCollateral (operator, user, CTN_SMUSD)
        escrowCid <- case existingEscrowOpt of
          Some existCid -> exercise existCid Escrow_AddCollateral with
            addAmount = smusd.shares
          None -> create EscrowedCollateral with
            operator
            owner = user
            collateralType = CTN_SMUSD
            amount = smusd.shares
            depositedAt = now
            lastUpdatedAt = now
            originalSourceChain = None
            originalCctpNonce = None
            privacyObservers = userObs

        newService <- create this with {}
        return (newService, escrowCid)

    -- ──────────────────────────────────────────────────────
    --  BORROW mUSD
    -- ──────────────────────────────────────────────────────

    -- | Borrow mUSD against escrowed collateral.
    -- Requires all collateral positions + price feeds to compute health factor.
    choice Lending_Borrow : (ContractId CantonLendingService, ContractId CantonDebtPosition, ContractId CantonMUSD)
      with
        user             : Party
        borrowAmount     : Money
        escrowCids       : [ContractId EscrowedCollateral]  -- All user's collateral positions
        priceFeedCids    : [ContractId CantonPriceFeed]     -- Corresponding price feeds
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        -- Compliance check before borrow
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = operator; receiver = user
          None -> pure ()
        assertMsg "BORROW_POSITIVE" (borrowAmount > 0.0)
        assertMsg "BELOW_MIN_BORROW" (borrowAmount >= minBorrow)
        assertMsg "ESCROW_PRICE_MISMATCH" (length escrowCids == length priceFeedCids)

        -- Calculate total collateral value (weighted by collateralFactorBps)
        -- Pass user as expectedOwner to verify all escrows belong to this user
        totalWeightedValue <- computeWeightedCollateralValue operator user configs escrowCids priceFeedCids True

        -- Look up existing debt, accrue interest, then increase principal
        existingDebtOpt <- lookupByKey @CantonDebtPosition (operator, user)
        (existingDebt, accruedDebtCid) <- case existingDebtOpt of
          None -> return (0.0, None)
          Some debtCid -> do
            -- Accrue interest BEFORE reading total debt
            accrued <- exercise debtCid Debt_AccrueInterest with caller = user
            debt <- fetch accrued
            return (debt.principalDebt + debt.accruedInterest, Some accrued)

        -- Health check: totalWeightedValue must cover existing + new debt
        let totalDebtAfter = existingDebt + borrowAmount
        assertMsg "INSUFFICIENT_COLLATERAL_VALUE" (totalWeightedValue >= totalDebtAfter)

        -- Enforce lending supply cap (prevents unbounded mUSD minting)
        assertMsg "EXCEEDS_LENDING_SUPPLY_CAP" (totalBorrows + borrowAmount <= lendingSupplyCap)

        -- Mint mUSD to borrower
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = borrowAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        -- Increase existing debt principal (preserving accrued interest) or create new
        now <- getTime
        debtCid <- case accruedDebtCid of
          Some existCid -> exercise existCid Debt_IncreasePrincipal with
            additionalBorrow = borrowAmount
          None -> create CantonDebtPosition with
            operator
            borrower = user
            principalDebt = borrowAmount
            accruedInterest = 0.0
            lastAccrualTime = now
            interestRateBps
            privacyObservers = userObs

        -- Update service
        newService <- create this with
          totalBorrows = totalBorrows + borrowAmount
        return (newService, debtCid, musdCid)

    -- ──────────────────────────────────────────────────────
    --  REPAY DEBT
    -- ──────────────────────────────────────────────────────

    -- | Repay mUSD debt. Burns the mUSD token and reduces debt position.
    -- Repayment is intentionally allowed even when service is paused.
    -- Blocking repayment during pause would trap users in accruing-interest positions,
    -- which is harmful. Liquidation is also allowed during pause for the same reason.
    choice Lending_Repay : (ContractId CantonLendingService, ContractId CantonDebtPosition)
      with
        user      : Party
        musdCid   : ContractId CantonMUSD
        debtCid   : ContractId CantonDebtPosition
      controller user
      do
        -- Verify ownership
        musd <- fetch musdCid
        assertMsg "NOT_MUSD_OWNER" (musd.owner == user)
        debt <- fetch debtCid
        assertMsg "NOT_DEBT_OWNER" (debt.borrower == user)

        -- Accrue interest first
        accruedDebtCid <- exercise debtCid Debt_AccrueInterest with caller = user

        -- Atomically couple BurnRateLimiter with CantonMUSD_Burn.
        -- Both execute in same DAML transaction — if rate limit exceeded, burn rolls back.
        _ <- exerciseByKey @BurnRateLimiter operator BurnLimit_RecordBurn with
          burnAmount = musd.amount
        -- Burn the mUSD (repayment)
        exercise musdCid CantonMUSD_Burn

        -- Reduce debt
        (newDebtCid, interestPaid) <- exercise accruedDebtCid Debt_Repay with
          repayAmount = musd.amount

        -- Calculate reserve portion of interest
        let reserveAmount = interestPaid * intToNumeric reserveFactorBps / 10000.0
        let repayFromBorrows = min musd.amount totalBorrows

        newService <- create this with
          totalBorrows = totalBorrows - repayFromBorrows
          protocolReserves = protocolReserves + reserveAmount

        return (newService, newDebtCid)

    -- ──────────────────────────────────────────────────────
    --  WITHDRAW COLLATERAL
    -- ──────────────────────────────────────────────────────

    -- | Withdraw collateral. Must pass health check after withdrawal.
    -- Returns the recreated token to the user.
    choice Lending_WithdrawCTN : (ContractId CantonLendingService, ContractId CantonCoin)
      with
        user           : Party
        escrowCid      : ContractId EscrowedCollateral
        withdrawAmount : Money
        -- All remaining escrow positions + feeds for health check
        otherEscrowCids   : [ContractId EscrowedCollateral]
        priceFeedCids     : [ContractId CantonPriceFeed]
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        escrow <- fetch escrowCid
        assertMsg "NOT_OWNER" (escrow.owner == user)
        assertMsg "WRONG_TYPE" (escrow.collateralType == CTN_Coin)
        -- Validate withdraw amount does not exceed escrowed balance
        assertMsg "WITHDRAW_EXCEEDS_BALANCE" (withdrawAmount > 0.0 && withdrawAmount <= escrow.amount)

        -- Check health AFTER withdrawal
        -- Accrue interest on-ledger for consistent state
        existingDebt <- getExistingDebtAndAccrue operator user
        if existingDebt > 0.0 then do
          -- Filter out escrowCid from otherEscrowCids to prevent double-counting
          let filteredOtherEscrows = filter (/= escrowCid) otherEscrowCids
          -- Pass user as expectedOwner
          remainingValue <- computeWeightedCollateralValue operator user configs filteredOtherEscrows priceFeedCids True
          -- Add value of remaining portion of this escrow (if partial withdrawal)
          let remainingThisEscrow = escrow.amount - withdrawAmount
          remainingThisValue <- if remainingThisEscrow > 0.0 then do
            let cfg = getConfig CTN_Coin configs
            -- Get CTN price
            ctnPrice <- getCtxPrice operator "CTN" priceFeedCids True
            return (remainingThisEscrow * ctnPrice * intToNumeric cfg.collateralFactorBps / 10000.0)
          else return 0.0
          assertMsg "UNHEALTHY_AFTER_WITHDRAW" (remainingValue + remainingThisValue >= existingDebt)
        else pure ()

        -- Execute withdrawal
        if withdrawAmount >= escrow.amount then do
          _ <- exercise escrowCid Escrow_WithdrawAll
          pure ()
        else do
          _ <- exercise escrowCid Escrow_WithdrawPartial with withdrawAmount
          pure ()

        -- Recreate the CantonCoin token for the user
        userObs <- lookupUserObservers operator user
        coinCid <- create CantonCoin with
          issuer = operator
          owner = user
          amount = withdrawAmount
          privacyObservers = userObs

        newService <- create this with {}
        return (newService, coinCid)

    -- ──────────────────────────────────────────────────────
    --  WITHDRAW USDC / USDCx / sMUSD COLLATERAL
    -- ──────────────────────────────────────────────────────

    -- | Withdraw USDC collateral. Must pass health check after withdrawal.
    choice Lending_WithdrawUSDC : (ContractId CantonLendingService, ContractId CantonUSDC)
      with
        user           : Party
        escrowCid      : ContractId EscrowedCollateral
        withdrawAmount : Money
        otherEscrowCids   : [ContractId EscrowedCollateral]
        priceFeedCids     : [ContractId CantonPriceFeed]
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        escrow <- fetch escrowCid
        assertMsg "NOT_OWNER" (escrow.owner == user)
        assertMsg "WRONG_TYPE" (escrow.collateralType == CTN_USDC)
        -- Validate withdraw amount does not exceed escrowed balance
        assertMsg "WITHDRAW_EXCEEDS_BALANCE" (withdrawAmount > 0.0 && withdrawAmount <= escrow.amount)

        -- Accrue interest on-ledger
        existingDebt <- getExistingDebtAndAccrue operator user
        if existingDebt > 0.0 then do
          -- Filter out escrowCid from otherEscrowCids
          let filteredOtherEscrows = filter (/= escrowCid) otherEscrowCids
          remainingValue <- computeWeightedCollateralValue operator user configs filteredOtherEscrows priceFeedCids True
          let remainingThisEscrow = escrow.amount - withdrawAmount
          remainingThisValue <- if remainingThisEscrow > 0.0 then do
            let cfg = getConfig CTN_USDC configs
            usdcPrice <- getCtxPrice operator "USDC" priceFeedCids True
            return (remainingThisEscrow * usdcPrice * intToNumeric cfg.collateralFactorBps / 10000.0)
          else return 0.0
          assertMsg "UNHEALTHY_AFTER_WITHDRAW" (remainingValue + remainingThisValue >= existingDebt)
        else pure ()

        if withdrawAmount >= escrow.amount then do
          _ <- exercise escrowCid Escrow_WithdrawAll
          pure ()
        else do
          _ <- exercise escrowCid Escrow_WithdrawPartial with withdrawAmount
          pure ()

        userObs <- lookupUserObservers operator user
        usdcCid <- create CantonUSDC with
          issuer = operator
          owner = user
          amount = withdrawAmount
          privacyObservers = userObs

        newService <- create this with {}
        return (newService, usdcCid)

    -- | Withdraw USDCx collateral.
    choice Lending_WithdrawUSDCx : (ContractId CantonLendingService, ContractId USDCx)
      with
        user           : Party
        escrowCid      : ContractId EscrowedCollateral
        withdrawAmount : Money
        otherEscrowCids   : [ContractId EscrowedCollateral]
        priceFeedCids     : [ContractId CantonPriceFeed]
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        escrow <- fetch escrowCid
        assertMsg "NOT_OWNER" (escrow.owner == user)
        assertMsg "WRONG_TYPE" (escrow.collateralType == CTN_USDCx)
        -- Validate withdraw amount does not exceed escrowed balance
        assertMsg "WITHDRAW_EXCEEDS_BALANCE" (withdrawAmount > 0.0 && withdrawAmount <= escrow.amount)

        -- Accrue interest on-ledger
        existingDebt <- getExistingDebtAndAccrue operator user
        if existingDebt > 0.0 then do
          -- Filter out escrowCid from otherEscrowCids
          let filteredOtherEscrows = filter (/= escrowCid) otherEscrowCids
          remainingValue <- computeWeightedCollateralValue operator user configs filteredOtherEscrows priceFeedCids True
          let remainingThisEscrow = escrow.amount - withdrawAmount
          remainingThisValue <- if remainingThisEscrow > 0.0 then do
            let cfg = getConfig CTN_USDCx configs
            usdcxPrice <- getCtxPrice operator "USDCx" priceFeedCids True
            return (remainingThisEscrow * usdcxPrice * intToNumeric cfg.collateralFactorBps / 10000.0)
          else return 0.0
          assertMsg "UNHEALTHY_AFTER_WITHDRAW" (remainingValue + remainingThisValue >= existingDebt)
        else pure ()

        if withdrawAmount >= escrow.amount then do
          _ <- exercise escrowCid Escrow_WithdrawAll
          pure ()
        else do
          _ <- exercise escrowCid Escrow_WithdrawPartial with withdrawAmount
          pure ()

        -- Restore original USDCx provenance from escrowed metadata.
        -- Note: issuer must remain `operator` due to DAML signatory constraints —
        -- the lending service cannot create contracts signed by the original xReserve issuer.
        -- sourceChain and cctpNonce ARE restored to preserve provenance trail.
        userObs <- lookupUserObservers operator user
        usdcxCid <- create USDCx with
          issuer = operator
          owner = user
          amount = withdrawAmount
          sourceChain = fromOptional "canton-lending-withdrawal" escrow.originalSourceChain
          cctpNonce = fromOptional 0 escrow.originalCctpNonce
          privacyObservers = userObs

        newService <- create this with {}
        return (newService, usdcxCid)

    -- | Withdraw CantonSMUSD collateral.
    choice Lending_WithdrawSMUSD : (ContractId CantonLendingService, ContractId CantonSMUSD)
      with
        user           : Party
        escrowCid      : ContractId EscrowedCollateral
        withdrawAmount : Money
        otherEscrowCids   : [ContractId EscrowedCollateral]
        priceFeedCids     : [ContractId CantonPriceFeed]
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        escrow <- fetch escrowCid
        assertMsg "NOT_OWNER" (escrow.owner == user)
        assertMsg "WRONG_TYPE" (escrow.collateralType == CTN_SMUSD)
        -- Validate withdraw amount does not exceed escrowed balance
        assertMsg "WITHDRAW_EXCEEDS_BALANCE" (withdrawAmount > 0.0 && withdrawAmount <= escrow.amount)

        -- Accrue interest on-ledger
        existingDebt <- getExistingDebtAndAccrue operator user
        if existingDebt > 0.0 then do
          -- Filter out escrowCid from otherEscrowCids
          let filteredOtherEscrows = filter (/= escrowCid) otherEscrowCids
          remainingValue <- computeWeightedCollateralValue operator user configs filteredOtherEscrows priceFeedCids True
          let remainingThisEscrow = escrow.amount - withdrawAmount
          remainingThisValue <- if remainingThisEscrow > 0.0 then do
            let cfg = getConfig CTN_SMUSD configs
            smusdPrice <- getCtxPrice operator "sMUSD" priceFeedCids True
            return (remainingThisEscrow * smusdPrice * intToNumeric cfg.collateralFactorBps / 10000.0)
          else return 0.0
          assertMsg "UNHEALTHY_AFTER_WITHDRAW" (remainingValue + remainingThisValue >= existingDebt)
        else pure ()

        if withdrawAmount >= escrow.amount then do
          _ <- exercise escrowCid Escrow_WithdrawAll
          pure ()
        else do
          _ <- exercise escrowCid Escrow_WithdrawPartial with withdrawAmount
          pure ()

        -- Preserve original escrow deposit timestamp; use escrow depositedAt
        -- rather than resetting to now (which would unfairly restart cooldown timers)
        userObs <- lookupUserObservers operator user
        smusdCid <- create CantonSMUSD with
          issuer = operator
          owner = user
          shares = withdrawAmount
          entrySharePrice = 1.0  -- Placeholder; real share price is tracked by CantonStakingService
          stakedAt = escrow.depositedAt
          privacyObservers = userObs

        newService <- create this with {}
        return (newService, smusdCid)

    -- ──────────────────────────────────────────────────────
    --  LIQUIDATION
    -- ──────────────────────────────────────────────────────

    -- | Liquidate an undercollateralized position.
    -- Liquidator repays part of the borrower's debt and receives
    -- seized collateral at a discount (penalty).
    -- Requires keeper bond registration and revalidates health factor on-ledger.
    -- Uses unsafe price (no staleness check) — liquidations must always proceed.
    choice Lending_Liquidate : (ContractId CantonLendingService, ContractId CantonLiquidationReceipt)
      with
        liquidator       : Party
        borrower         : Party
        repayAmount      : Money
        targetEscrowCid  : ContractId EscrowedCollateral  -- Which collateral to seize
        debtCid          : ContractId CantonDebtPosition
        musdCid          : ContractId CantonMUSD           -- Liquidator's mUSD for repayment
        escrowCids       : [ContractId EscrowedCollateral] -- All borrower's collateral
        priceFeedCids    : [ContractId CantonPriceFeed]
        keeperBondCid    : ContractId KeeperBond           -- Keeper's bond proof
      controller liquidator
      do
        -- Block self-liquidation (borrower cannot liquidate own position for bonus extraction)
        assertMsg "CANNOT_SELF_LIQUIDATE" (liquidator /= borrower)

        -- Verify keeper is registered with sufficient bond
        keeperBond <- fetch keeperBondCid
        assertMsg "KEEPER_BOND_OWNER_MISMATCH" (keeperBond.keeper == liquidator)
        assertMsg "KEEPER_BOND_OPERATOR_MISMATCH" (keeperBond.operator == operator)
        assertMsg "KEEPER_NOT_ACTIVE" keeperBond.active
        assertMsg "KEEPER_BOND_INSUFFICIENT" (keeperBond.bondAmount >= minKeeperBond)

        -- Verify liquidator owns the repayment mUSD
        musd <- fetch musdCid
        assertMsg "NOT_MUSD_OWNER" (musd.owner == liquidator)
        assertMsg "REPAY_AMOUNT_MISMATCH" (musd.amount >= repayAmount)

        -- Fetch debt and accrue interest
        debt <- fetch debtCid
        assertMsg "DEBT_OWNER_MISMATCH" (debt.borrower == borrower)
        accruedDebtCid <- exercise debtCid Debt_AccrueInterest with caller = liquidator

        -- On-ledger health factor revalidation using fresh price reads
        -- This ensures the position is ACTUALLY undercollateralized at execution time,
        -- not just when the liquidator submitted the transaction.
        totalRawValue <- computeRawCollateralValue operator borrower configs escrowCids priceFeedCids False
        accruedDebt <- fetch accruedDebtCid
        let totalDebt = accruedDebt.principalDebt + accruedDebt.accruedInterest

        -- Health factor: rawValue weighted by liquidationThreshold / totalDebt
        totalLiqValue <- computeLiquidationThresholdValue operator borrower configs escrowCids priceFeedCids False
        let healthFactor = if totalDebt > 0.0 then totalLiqValue / totalDebt else 999.0

        -- Revalidate health factor ON-LEDGER at execution time
        -- Position must be genuinely undercollateralized (health factor < 1.0)
        assertMsg "POSITION_HEALTHY" (healthFactor < 1.0)

        -- Close factor limits
        let maxRepay = totalDebt * intToNumeric closeFactorBps / 10000.0
        let actualRepay = min repayAmount maxRepay

        -- Seize collateral with penalty
        targetEscrow <- fetch targetEscrowCid
        let cfg = getConfig targetEscrow.collateralType configs
        colPrice <- getCtxPriceByType operator targetEscrow.collateralType priceFeedCids False

        let seizeValueUsd = actualRepay * (10000.0 + intToNumeric cfg.liquidationPenaltyBps) / 10000.0
        let seizeAmount = seizeValueUsd / colPrice
        let actualSeize = min seizeAmount targetEscrow.amount

        -- Execute seizure
        (remainingEscrow, seized) <- exercise targetEscrowCid Escrow_Seize with
          seizeAmount = actualSeize

        -- Reduce debt
        newDebtCid <- exercise accruedDebtCid Debt_ReduceForLiquidation with
          reductionAmount = actualRepay

        -- Atomically couple BurnRateLimiter with CantonMUSD_Burn
        _ <- exerciseByKey @BurnRateLimiter operator BurnLimit_RecordBurn with
          burnAmount = actualRepay
        -- Split mUSD if liquidator provided more than actualRepay, refund change
        if musd.amount > actualRepay then do
          (burnCid, changeCid) <- exercise musdCid CantonMUSD_Split with
            splitAmount = actualRepay
          exercise burnCid CantonMUSD_Burn
          -- changeCid goes back to liquidator (already owned by them)
          pure ()
        else
          exercise musdCid CantonMUSD_Burn

        -- Transfer seized collateral to liquidator as the appropriate token type
        -- (Seized amount is now minted as a new token for the liquidator)
        userObs <- lookupUserObservers operator liquidator
        case targetEscrow.collateralType of
          CTN_Coin -> do
            create CantonCoin with
              issuer = operator
              owner = liquidator
              amount = actualSeize
              privacyObservers = userObs
            pure ()
          CTN_USDC -> do
            create CantonUSDC with
              issuer = operator
              owner = liquidator
              amount = actualSeize
              privacyObservers = userObs
            pure ()
          CTN_USDCx -> do
            -- Restore original USDCx provenance from escrowed metadata.
            -- issuer remains operator due to DAML signatory constraints.
            create USDCx with
              issuer = operator
              owner = liquidator
              amount = actualSeize
              sourceChain = fromOptional "canton-lending-seizure" targetEscrow.originalSourceChain
              cctpNonce = fromOptional 0 targetEscrow.originalCctpNonce
              privacyObservers = userObs
            pure ()
          CTN_SMUSD -> do
            now2 <- getTime
            create CantonSMUSD with
              issuer = operator
              owner = liquidator
              shares = actualSeize
              entrySharePrice = colPrice
              stakedAt = now2
              privacyObservers = userObs
            pure ()

        -- Calculate keeper bonus vs protocol fee
        let penaltyValue = actualSeize * colPrice - actualRepay
        let keeperBonus = penaltyValue * intToNumeric cfg.liquidationBonusBps / intToNumeric cfg.liquidationPenaltyBps
        let protocolFee = penaltyValue - keeperBonus

        now <- getTime
        -- Create immutable receipt
        receiptCid <- create CantonLiquidationReceipt with
          operator
          borrower
          liquidator
          collateralType = targetEscrow.collateralType
          debtRepaid = actualRepay
          collateralSeized = actualSeize
          collateralPrice = colPrice
          penalty = penaltyValue
          keeperBonus
          protocolFee
          healthFactorBefore = healthFactor
          timestamp = now

        let repayFromBorrows = min actualRepay totalBorrows
        newService <- create this with
          totalBorrows = totalBorrows - repayFromBorrows
          protocolReserves = protocolReserves + protocolFee

        return (newService, receiptCid)

    -- ──────────────────────────────────────────────────────
    --  ADMIN
    -- ──────────────────────────────────────────────────────

    -- | Update collateral config
    -- Validate config bounds to prevent operator misconfiguration
    -- Governance-gated
    choice Lending_UpdateConfig : ContractId CantonLendingService
      with
        newConfig : CollateralConfig
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "COLLATERAL_FACTOR_RANGE" (newConfig.collateralFactorBps >= 0 && newConfig.collateralFactorBps <= 9900)
        assertMsg "LIQ_THRESHOLD_RANGE" (newConfig.liquidationThresholdBps >= 0 && newConfig.liquidationThresholdBps <= 9900)
        assertMsg "THRESHOLD_GT_FACTOR" (newConfig.liquidationThresholdBps >= newConfig.collateralFactorBps)
        assertMsg "LIQ_PENALTY_RANGE" (newConfig.liquidationPenaltyBps >= 0 && newConfig.liquidationPenaltyBps <= 2000)
        assertMsg "LIQ_BONUS_RANGE" (newConfig.liquidationBonusBps >= 0 && newConfig.liquidationBonusBps <= newConfig.liquidationPenaltyBps)
        let updatedConfigs = map (\c -> if c.collateralType == newConfig.collateralType then newConfig else c) configs
        create this with configs = updatedConfigs

    -- | Update interest rate (synced from InterestRateService)
    -- Governance-gated
    choice Lending_UpdateRate : ContractId CantonLendingService
      with
        newRateBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "RATE_NON_NEGATIVE" (newRateBps >= 0)
        assertMsg "RATE_MAX_100_PERCENT" (newRateBps <= 10000)
        create this with interestRateBps = newRateBps

    -- | Pause / unpause
    -- Governance-gated
    choice Lending_SetPaused : ContractId CantonLendingService
      with
        newPaused : Bool
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        create this with paused = newPaused

    -- Admin choices for operational parameters
    -- Governance-gated
    choice Lending_UpdateMinBorrow : ContractId CantonLendingService
      with
        newMinBorrow : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "MIN_BORROW_POSITIVE" (newMinBorrow > 0.0)
        create this with minBorrow = newMinBorrow

    -- Governance-gated
    choice Lending_UpdateReserveFactor : ContractId CantonLendingService
      with
        newReserveFactorBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "RESERVE_FACTOR_RANGE" (newReserveFactorBps >= 0 && newReserveFactorBps <= 5000)
        create this with reserveFactorBps = newReserveFactorBps

    -- Governance-gated
    choice Lending_UpdateCloseFactor : ContractId CantonLendingService
      with
        newCloseFactorBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "CLOSE_FACTOR_RANGE" (newCloseFactorBps > 0 && newCloseFactorBps <= 10000)
        create this with closeFactorBps = newCloseFactorBps

    -- | Withdraw protocol reserves
    -- Governance-gated
    choice Lending_WithdrawReserves : (ContractId CantonLendingService, ContractId CantonMUSD)
      with
        amount : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        -- Use TreasuryWithdrawal (not ParameterUpdate) for reserve withdrawals
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == TreasuryWithdrawal)
        -- Verify proof is scoped to this module
        assertMsg "WRONG_TARGET_MODULE" (proof.targetModule == "CantonLending")
        assertMsg "INSUFFICIENT_RESERVES" (amount <= protocolReserves)
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = operator
          amount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = []  -- Protocol reserves, fully private
        newService <- create this with
          protocolReserves = protocolReserves - amount
        return (newService, musdCid)

-- ============================================================
--                     SECTION 6: LIQUIDATION RECEIPT
-- ============================================================

-- | CantonLiquidationReceipt — Immutable audit trail per liquidation.
template CantonLiquidationReceipt
  with
    operator         : Party
    borrower         : Party
    liquidator       : Party
    collateralType   : CollateralType
    debtRepaid       : Money
    collateralSeized : Money
    collateralPrice  : Money
    penalty          : Money
    keeperBonus      : Money
    protocolFee      : Money
    healthFactorBefore : Money
    timestamp        : Time
  where
    signatory operator
    observer borrower, liquidator

    ensure debtRepaid > 0.0 && collateralSeized > 0.0

-- ============================================================
--                     HELPER FUNCTIONS
-- ============================================================

-- | Look up config for a given collateral type
getConfig : CollateralType -> [CollateralConfig] -> CollateralConfig
getConfig ct [] = error ("CONFIG_NOT_FOUND: " <> show ct)
getConfig ct (c :: cs) = if c.collateralType == ct then c else getConfig ct cs

-- | Get existing debt for a user (returns 0 if no position)
-- Accrue interest before reading so health checks use current values
getExistingDebt : Party -> Party -> Update Money
getExistingDebt operator user = do
  debtOpt <- lookupByKey @CantonDebtPosition (operator, user)
  case debtOpt of
    None -> return 0.0
    Some debtCid -> do
      debt <- fetch debtCid
      now <- getTime
      let elapsed = convertRelTimeToMicroseconds (subTime now debt.lastAccrualTime)
      let secondsElapsed : Money = intToNumeric (elapsed / 1000000)
      let yearSeconds = 31536000.0 : Money
      let newInterest = debt.principalDebt * intToNumeric debt.interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
      return (debt.principalDebt + debt.accruedInterest + newInterest)

-- | Get existing debt AND persist the accrual on-ledger.
-- Used by withdrawal paths to keep on-ledger state consistent.
getExistingDebtAndAccrue : Party -> Party -> Update Money
getExistingDebtAndAccrue operator user = do
  debtOpt <- lookupByKey @CantonDebtPosition (operator, user)
  case debtOpt of
    None -> return 0.0
    Some debtCid -> do
      accruedCid <- exercise debtCid Debt_AccrueInterest with caller = user
      debt <- fetch accruedCid
      return (debt.principalDebt + debt.accruedInterest)

-- | Get price from feed list by symbol (with staleness check option)
getCtxPrice : Party -> Text -> [ContractId CantonPriceFeed] -> Bool -> Update Money
getCtxPrice _ symbol [] _ = error ("PRICE_FEED_NOT_FOUND: " <> symbol)
getCtxPrice operator symbol (fCid :: rest) safe = do
  feed <- fetch fCid
  if feed.symbol == symbol
    then if safe
      then exercise fCid PriceFeed_GetPrice with
        requester = operator
        maxStaleness = hours 1
      else exercise fCid PriceFeed_GetPriceUnsafe with
        requester = operator
    else getCtxPrice operator symbol rest safe

-- | Get price by collateral type
getCtxPriceByType : Party -> CollateralType -> [ContractId CantonPriceFeed] -> Bool -> Update Money
getCtxPriceByType operator CTN_Coin feeds safe = getCtxPrice operator "CTN" feeds safe
getCtxPriceByType operator CTN_USDC feeds safe = getCtxPrice operator "USDC" feeds safe
getCtxPriceByType operator CTN_USDCx feeds safe = getCtxPrice operator "USDCx" feeds safe
getCtxPriceByType operator CTN_SMUSD feeds safe = getCtxPrice operator "sMUSD" feeds safe

-- | Compute total collateral value weighted by collateralFactorBps
-- Added expectedOwner param — each escrow is verified to belong to the expected user
computeWeightedCollateralValue : Party -> Party -> [CollateralConfig] -> [ContractId EscrowedCollateral] -> [ContractId CantonPriceFeed] -> Bool -> Update Money
computeWeightedCollateralValue _ _ _ [] _ _ = return 0.0
computeWeightedCollateralValue operator expectedOwner cfgs (eCid :: eRest) feeds safe = do
  escrow <- fetch eCid
  assertMsg "ESCROW_OWNER_MISMATCH" (escrow.owner == expectedOwner)
  let cfg = getConfig escrow.collateralType cfgs
  -- Disabled collateral types contribute 0 value to weighted collateral
  -- This prevents borrowing against collateral that has been disabled by the operator
  price <- getCtxPriceByType operator escrow.collateralType feeds safe
  let value = if cfg.enabled
        then escrow.amount * price * intToNumeric cfg.collateralFactorBps / 10000.0
        else 0.0
  rest <- computeWeightedCollateralValue operator expectedOwner cfgs eRest feeds safe
  return (value + rest)

-- | Compute total raw collateral value (no LTV weighting)
-- Added expectedOwner param
computeRawCollateralValue : Party -> Party -> [CollateralConfig] -> [ContractId EscrowedCollateral] -> [ContractId CantonPriceFeed] -> Bool -> Update Money
computeRawCollateralValue _ _ _ [] _ _ = return 0.0
computeRawCollateralValue operator expectedOwner cfgs (eCid :: eRest) feeds safe = do
  escrow <- fetch eCid
  assertMsg "ESCROW_OWNER_MISMATCH" (escrow.owner == expectedOwner)
  price <- getCtxPriceByType operator escrow.collateralType feeds safe
  let value = escrow.amount * price
  rest <- computeRawCollateralValue operator expectedOwner cfgs eRest feeds safe
  return (value + rest)

-- | Compute total collateral value weighted by liquidationThresholdBps
-- Added expectedOwner param
computeLiquidationThresholdValue : Party -> Party -> [CollateralConfig] -> [ContractId EscrowedCollateral] -> [ContractId CantonPriceFeed] -> Bool -> Update Money
computeLiquidationThresholdValue _ _ _ [] _ _ = return 0.0
computeLiquidationThresholdValue operator expectedOwner cfgs (eCid :: eRest) feeds safe = do
  escrow <- fetch eCid
  assertMsg "ESCROW_OWNER_MISMATCH" (escrow.owner == expectedOwner)
  let cfg = getConfig escrow.collateralType cfgs
  price <- getCtxPriceByType operator escrow.collateralType feeds safe
  let value = escrow.amount * price * intToNumeric cfg.liquidationThresholdBps / 10000.0
  rest <- computeLiquidationThresholdValue operator expectedOwner cfgs eRest feeds safe
  return (value + rest)
