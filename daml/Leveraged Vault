module Minted.Protocol.V3 where
import DA.Time
import DA.Optional (fromOptional)
import DA.Action (foldlA)
import DA.Math (round)
-- 1. ASSET LAYER (UTXO)
template Asset
  with
    issuer : Party
    owner : Party
    symbol : Text
    amount : Decimal
  where
    signatory issuer, owner
    choice Asset_Transfer : ContractId Asset
      with newOwner : Party
      controller owner
      do create this with owner = newOwner
    choice Asset_Split : (ContractId Asset, ContractId Asset)
      with splitAmount : Decimal
      controller owner
      do
        assert (amount >= splitAmount)
        remaining <- create this with amount = amount - splitAmount
        split <- create this with amount = splitAmount
        return (remaining, split)
-- 2. ORACLE LAYER
template PriceOracle
  with
    provider : Party
    symbol : Text
    priceInUsd : Decimal
    lastUpdated : Time
  where
    signatory provider
    key (provider, symbol) : (Party, Text)
    maintainer key._1
-- 3. LIQUIDITY LAYER (DEX)
template LiquidityPool
  with
    operator : Party
    collateralSymbol : Text
    musdSymbol : Text
    pricePerCollateral : Decimal -- Simple price for demo
  where
    signatory operator
    -- Swaps mUSD (Debt Asset) for Collateral (Vault Asset)
    choice Swap_mUSD_For_Collateral : ContractId Asset
      with
        musdCid : ContractId Asset
        user : Party
      controller user
      do
        musd <- fetch musdCid
        assert (musd.symbol == musdSymbol)
        let collateralAmount = musd.amount / pricePerCollateral
        archive musdCid
        -- Mint/Transfer collateral to user (Simplified for logic)
        create Asset with issuer = operator, owner = user, symbol = collateralSymbol, amount = collateralAmount
-- 4. VAULT LAYER (The CDP)
template Vault
  with
    provider : Party
    owner : Party
    token : Text
    collateralAmount : Decimal
    principalDebt : Decimal
    accruedInterest : Decimal
    lastAccrualTime : Time
    config : VaultConfig
  where
    signatory provider
    observer owner
    let 
      -- Precision-safe Interest Math
      calcInterest (currentTime : Time) =
        let 
          elapsedSeconds = intToDecimal (round (convertTimeToMicroseconds (subTime currentTime lastAccrualTime) / 1000000))
          yearInSeconds = 31536000.0
          interest = (principalDebt * config.interestRateBps * elapsedSeconds) / (10000.0 * yearInSeconds)
        in interest
      getTotalDebt (currentTime : Time) = 
        principalDebt + accruedInterest + calcInterest currentTime
    -- ATOMIC LEVERAGE CHOICE
    choice AdjustLeverage : (ContractId Vault, Optional (ContractId Asset))
      with
        initialCollateralCid : Optional (ContractId Asset) -- New funds from user
        extraBorrowAmount : Decimal                       -- How much to loop
        poolCid : ContractId LiquidityPool                -- DEX to use
        currentTime : Time
        oracleCid : ContractId PriceOracle                -- Price source
      controller owner
      do
        oracle <- fetch oracleCid
        assert (oracle.symbol == token && oracle.provider == provider)
        -- A. Accrue existing interest
        let totalDebtBefore = getTotalDebt currentTime
        -- B. Handle incoming collateral (if any)
        addedAmt <- case initialCollateralCid of
          Some cid -> do
            asset <- fetch cid
            assert (asset.symbol == token && asset.owner == owner)
            archive cid
            return asset.amount
          None -> return 0.0
        -- C. Execute Leverage Loop (Borrow -> Swap -> Re-deposit)
        (finalCollateral, finalDebt) <- if extraBorrowAmount > 0.0 
          then do
            -- 1. Create mUSD Debt Asset
            mUSDCid <- create Asset with 
                issuer = provider, owner = owner, symbol = "mUSD", amount = extraBorrowAmount
            -- 2. Swap mUSD for Collateral via Pool
            newCollateralCid <- exercise poolCid Swap_mUSD_For_Collateral with 
                musdCid = mUSDCid, user = owner
            newCol <- fetch newCollateralCid
            archive newCollateralCid
            return (collateralAmount + addedAmt + newCol.amount, principalDebt + extraBorrowAmount)
          else 
            return (collateralAmount + addedAmt, principalDebt)
        -- D. Final Health Check
        let 
          totalValue = finalCollateral * oracle.priceInUsd
          minRequiredValue = (finalDebt + totalDebtBefore - principalDebt) / config.liquidationThreshold
        assertMsg "Insolvent: Leverage too high" (totalValue >= minRequiredValue)
        newVault <- create this with
          collateralAmount = finalCollateral
          principalDebt = finalDebt
          accruedInterest = totalDebtBefore - principalDebt -- Save accrued
          lastAccrualTime = currentTime
        return (newVault, None)
-- DATA RECORD for Config
data VaultConfig = VaultConfig with
  liquidationThreshold : Decimal
  interestRateBps : Decimal
    deriving (Eq, Show)
-- 5. FACTORY (The Rule Pattern)
-- The Provider signs this once, allowing Alice to create her own Vault.
template VaultManager
  with
    provider : Party
  where
    signatory provider
    nonconsuming choice OpenVault : ContractId Vault
      with
        owner : Party
        token : Text
        config : VaultConfig
      controller owner
      do
        create Vault with
          provider; owner; token; config
          collateralAmount = 0.0
          principalDebt = 0.0
          accruedInterest = 0.0
          lastAccrualTime = currentTime -- Note: In real life, use getTime
