-- | CantonETHPool
-- Canton-native ETH Pool — USDC-first staking with Fluid strategy yield.
-- No mUSD minting or burning on deposit. USDC flows directly to Ethereum Treasury.
--
-- Architecture:
--   Every deposit transfers stables to operator and emits a BridgeOutRequest.
--   The relay deposits USDC to Ethereum Treasury → deployed to MetaVault #3 (Fluid T2/T4).
--   mUSD is NEVER involved in the deposit path — capital flows directly.
--
--   Accepted entry assets (all result in USDC bridged to Ethereum):
--   1. CantonUSDC  — USDC transferred to operator → BridgeOutRequest
--   2. USDCx       — USDCx transferred to operator → BridgeOutRequest (relay redeems → USDC)
--   3. CantonCoin  — Coin burned, operator provides USDCx (swap) → BridgeOutRequest
--
--   On unstake: user receives newly minted CantonMUSD (backed by Fluid strategy returns).
--   If they want USDC back, they use DirectMint_Redeem separately.
--
-- Yield:
--   Fluid Protocol smart debt/collateral on Ethereum (T2/T4 vaults).
--   Yield arrives as mUSD via ETHPool_ReceiveYield → pooledUsdc grows → share price rises.
--   The yield mUSD is archived (accounted via counter, not held).
--
-- Lending/Borrowing:
--   CantonSMUSD_E can be deposited as collateral in CantonLending.

module CantonETHPool where

import DA.Time
import DA.Text qualified as DA.Text
import CantonDirectMint
  ( CantonMUSD(..), CantonMUSD_Burn(..)
  , CantonUSDC(..), CantonUSDC_Transfer(..), CantonUSDCTransferProposal(..), CantonUSDCTransferProposal_Accept(..)
  , USDCx(..), USDCx_Transfer(..), USDCx_Split(..)
  , USDCxTransferProposal(..), USDCxTransferProposal_Accept(..)
  , BridgeOutRequest(..)
  , Money, Bps
  )
import CantonCoinToken (CantonCoin(..), CantonCoin_Burn(..))
import Compliance (ComplianceRegistry(..), ValidateMint(..), ValidateRedemption(..), ValidateTransfer(..))
import UserPrivacySettings (lookupUserObservers, UserPrivacySettings)

-- ============================================================
--                     SECTION 1: TIME-LOCK TIERS
-- ============================================================

-- | Time-lock tier for yield multiplier boost.
-- Mirrors Solidity ETHPool.TimeLockTier enum.
data TimeLockTier
  = NoLock       -- No lock, 1.0x multiplier
  | ShortLock    -- 30 days, 1.25x multiplier
  | MediumLock   -- 90 days, 1.5x multiplier
  | LongLock     -- 180 days, 2.0x multiplier
  deriving (Eq, Show, Ord)

-- | Get lock duration in seconds for a tier
tierDurationSecs : TimeLockTier -> Int
tierDurationSecs NoLock     = 0
tierDurationSecs ShortLock  = 2592000    -- 30 days
tierDurationSecs MediumLock = 7776000    -- 90 days
tierDurationSecs LongLock   = 15552000   -- 180 days

-- | Get yield multiplier in basis points for a tier
tierMultiplierBps : TimeLockTier -> Bps
tierMultiplierBps NoLock     = 10000   -- 1.0x
tierMultiplierBps ShortLock  = 12500   -- 1.25x
tierMultiplierBps MediumLock = 15000   -- 1.5x
tierMultiplierBps LongLock   = 20000   -- 2.0x

-- ============================================================
--                     SECTION 2: smUSD-E TOKEN
-- ============================================================

-- | CantonSMUSD_E — Canton-native smUSD-E (ETH Pool variant).
--
-- Pure mUSD staking receipt. Every position was created by staking mUSD.
-- On unstake, user always receives mUSD at current share price.
template CantonSMUSD_E
  with
    issuer : Party
    owner : Party
    shares : Money                -- Number of smUSD-E shares (boosted by multiplier)
    entrySharePrice : Money       -- Share price when staked (for tracking PnL)
    musdStaked : Money            -- mUSD amount that was staked
    tier : TimeLockTier           -- Selected time-lock tier
    stakedAt : Time               -- Timestamp when staked
    unlockAt : Optional Time      -- When position unlocks (None = no lock)
    privacyObservers : [Party]    -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure shares > 0.0

    -- | Update observers from user privacy settings
    -- DAML-H-02 FIX: User provides their settings CID explicitly (LF 2.x compatible)
    choice SMUSDE_UpdateObservers : ContractId CantonSMUSD_E
      with
        settingsCid : Optional (ContractId UserPrivacySettings)
      controller owner
      do
        newObservers <- lookupUserObservers issuer owner settingsCid
        create this with privacyObservers = newObservers

    -- | Transfer smUSD-E (for lending/borrowing collateral use).
    -- Freely transferable via propose-accept pattern.
    -- Time-lock travels with the token.
    choice SMUSDE_Transfer : ContractId CantonSMUSD_ETransferProposal
      with
        newOwner : Party
        complianceRegistryCid : ContractId ComplianceRegistry
      controller owner
      do
        exercise complianceRegistryCid ValidateTransfer with
          sender = owner
          receiver = newOwner
        create CantonSMUSD_ETransferProposal with
          smusde = this
          newOwner
          complianceRegistryCid

    -- | Split shares (for partial collateral deposit or transfer)
    choice SMUSDE_Split : (ContractId CantonSMUSD_E, ContractId CantonSMUSD_E)
      with
        splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_SHARES_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_SHARES_LESS_THAN_TOTAL" (splitShares < shares)
        let ratio = splitShares / shares
        let splitMusd = musdStaked * ratio
        c1 <- create this with
          shares = splitShares
          musdStaked = splitMusd
        c2 <- create this with
          shares = shares - splitShares
          musdStaked = musdStaked - splitMusd
        return (c1, c2)

    -- | Merge two smUSD-E positions (must match tier and owner)
    choice SMUSDE_Merge : ContractId CantonSMUSD_E
      with
        otherCid : ContractId CantonSMUSD_E
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        assertMsg "TIER_MISMATCH" (other.tier == tier)
        archive otherCid
        let mergedUnlock = case (unlockAt, other.unlockAt) of
              (Some t1, Some t2) -> Some (if t1 > t2 then t1 else t2)
              (Some t1, None)    -> Some t1
              (None, Some t2)    -> Some t2
              (None, None)       -> None
        create this with
          shares = shares + other.shares
          musdStaked = musdStaked + other.musdStaked
          unlockAt = mergedUnlock

-- | Transfer proposal for CantonSMUSD_E (dual-signatory safe).
template CantonSMUSD_ETransferProposal
  with
    smusde : CantonSMUSD_E
    newOwner : Party
    complianceRegistryCid : ContractId ComplianceRegistry
  where
    signatory smusde.issuer, smusde.owner
    observer newOwner

    choice CantonSMUSD_ETransferProposal_Accept : ContractId CantonSMUSD_E
      controller newOwner
      do
        exercise complianceRegistryCid ValidateMint with minter = newOwner
        create smusde with owner = newOwner

    choice CantonSMUSD_ETransferProposal_Reject : ContractId CantonSMUSD_E
      controller newOwner
      do create smusde

    choice CantonSMUSD_ETransferProposal_Cancel : ContractId CantonSMUSD_E
      controller smusde.owner
      do create smusde

-- ============================================================
--                     SECTION 3: ETH POOL SERVICE
-- ============================================================

-- | CantonETHPoolService — USDC-first ETH Pool staking on Canton.
--
-- Design principle: USDC flows directly to Ethereum Treasury (no mUSD intermediary).
-- mUSD is never minted or burned on the deposit path.
-- On exit, users receive CantonMUSD backed by Fluid strategy returns.
--
-- Yield source: Fluid Protocol smart debt/collateral on Ethereum (MetaVault #3).
template CantonETHPoolService
  with
    operator : Party
    governance : Party              -- Co-signer for critical ops
    totalShares : Money             -- Total smUSD-E shares issued on Canton (boosted by multipliers)
    totalUsdcStaked : Money         -- Total USDC originally deposited (excluding yield)
    pooledUsdc : Money              -- Total USDC backing in pool (deposits + received yield, counter)
    sharePrice : Money              -- Synced from Ethereum (informational — not used for stake/unstake)
    poolCap : Money                 -- Max USDC stakeable
    lastSyncEpoch : Int             -- Last synced epoch from Ethereum
    paused : Bool
    -- Bridge config (for BridgeOutRequest creation — no DirectMint dependency)
    usdcIssuer : Party              -- Canton USDC issuer for verification
    targetChainId : Int             -- Default: 1 (Ethereum mainnet)
    targetTreasury : Text           -- Ethereum Treasury address
    validators : [Party]            -- Bridge validators
    nextNonce : Int                 -- Auto-incrementing nonce for bridge requests
    -- Canton coin oracle price (USD per Canton coin)
    cantonCoinPrice : Money
    -- Compliance + legal
    complianceRegistryCid : ContractId ComplianceRegistry
    mpaHash : Text                  -- SHA-256 of Master Participation Agreement
    mpaUri : Text                   -- URI to MPA document
    observers : [Party]
  where
    signatory operator
    observer observers

    ensure totalShares >= 0.0
        && pooledUsdc >= 0.0
        && poolCap > 0.0
        && cantonCoinPrice > 0.0
        && DA.Text.length mpaHash == 64
        && DA.Text.length mpaUri > 0

    -- ──────────────────────────────────────────────────────
    --  STAKE: USDC → smUSD-E (no mUSD intermediary)
    -- ──────────────────────────────────────────────────────

    -- | Deposit USDC directly into ETH Pool.
    -- USDC transferred to operator → BridgeOutRequest → relay deposits to Treasury → Fluid.
    -- No mUSD minting or burning — capital flows directly to Ethereum strategies.
    choice ETHPool_StakeWithUSDC : (ContractId CantonETHPoolService, ContractId CantonSMUSD_E, ContractId BridgeOutRequest)
      with
        user : Party
        usdcCid : ContractId CantonUSDC
        selectedTier : TimeLockTier
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        exercise complianceRegistryCid ValidateMint with minter = user

        usdc <- fetch usdcCid
        assertMsg "USDC_ISSUER_MISMATCH" (usdc.issuer == usdcIssuer)
        assertMsg "OWNER_MISMATCH" (usdc.owner == user)
        assertMsg "EXCEEDS_POOL_CAP" (totalUsdcStaked + usdc.amount <= poolCap)

        let localPrice = if totalShares > 0.0 then pooledUsdc / totalShares else sharePrice
        let baseShares = usdc.amount / localPrice
        let multiplier = tierMultiplierBps selectedTier
        let boostedShares = baseShares * intToNumeric multiplier / 10000.0
        assertMsg "ZERO_SHARES" (boostedShares > 0.0)

        -- Transfer USDC to operator (staging for bridge-out)
        usdcProposal <- exercise usdcCid CantonUSDC_Transfer with
          newOwner = operator
          complianceRegistryCid
        exercise usdcProposal CantonUSDCTransferProposal_Accept

        -- BridgeOutRequest: relay deposits USDC to Ethereum Treasury → MetaVault #3 (Fluid)
        now <- getTime
        bridgeReq <- create BridgeOutRequest with
          operator; user; amount = usdc.amount
          targetChainId; targetTreasury; nonce = nextNonce
          createdAt = now; status = "pending"; source = "ethpool"; validators

        (newPoolService, smusdeCid) <- _mintSmUsdE
          (this with nextNonce = nextNonce + 1)
          user usdc.amount boostedShares selectedTier

        return (newPoolService, smusdeCid, bridgeReq)

    -- ──────────────────────────────────────────────────────
    --  STAKE: USDCx → smUSD-E (no mUSD intermediary)
    -- ──────────────────────────────────────────────────────

    -- | Deposit USDCx directly into ETH Pool.
    -- USDCx transferred to operator → BridgeOutRequest → relay redeems USDCx → USDC → Treasury.
    choice ETHPool_StakeWithUSDCx : (ContractId CantonETHPoolService, ContractId CantonSMUSD_E, ContractId BridgeOutRequest)
      with
        user : Party
        usdcxCid : ContractId USDCx
        selectedTier : TimeLockTier
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        exercise complianceRegistryCid ValidateMint with minter = user

        usdcx <- fetch usdcxCid
        assertMsg "OWNER_MISMATCH" (usdcx.owner == user)
        assertMsg "EXCEEDS_POOL_CAP" (totalUsdcStaked + usdcx.amount <= poolCap)

        let localPrice = if totalShares > 0.0 then pooledUsdc / totalShares else sharePrice
        let baseShares = usdcx.amount / localPrice
        let multiplier = tierMultiplierBps selectedTier
        let boostedShares = baseShares * intToNumeric multiplier / 10000.0
        assertMsg "ZERO_SHARES" (boostedShares > 0.0)

        -- Transfer USDCx to operator (staging for bridge-out)
        usdcxProposal <- exercise usdcxCid USDCx_Transfer with
          newOwner = operator
          complianceRegistryCid
        exercise usdcxProposal USDCxTransferProposal_Accept with complianceRegistryCid

        -- BridgeOutRequest: relay redeems USDCx → USDC → Treasury → MetaVault #3 (Fluid)
        now <- getTime
        bridgeReq <- create BridgeOutRequest with
          operator; user; amount = usdcx.amount
          targetChainId; targetTreasury; nonce = nextNonce
          createdAt = now; status = "pending"; source = "ethpool"; validators

        (newPoolService, smusdeCid) <- _mintSmUsdE
          (this with nextNonce = nextNonce + 1)
          user usdcx.amount boostedShares selectedTier

        return (newPoolService, smusdeCid, bridgeReq)

    -- ──────────────────────────────────────────────────────
    --  STAKE: CantonCoin → USDCx swap → smUSD-E
    -- ──────────────────────────────────────────────────────

    -- | Deposit Canton coin: coin burned at oracle price → operator's USDCx bridged to USDC.
    -- No round-trip: coin burn proves user paid, operator's USDCx backs the bridge directly.
    choice ETHPool_StakeWithCantonCoin : (ContractId CantonETHPoolService, ContractId CantonSMUSD_E, ContractId BridgeOutRequest)
      with
        user : Party
        coinCid : ContractId CantonCoin
        operatorUsdcxCid : ContractId USDCx  -- Operator's USDCx consumed for bridge backing
        selectedTier : TimeLockTier
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        exercise complianceRegistryCid ValidateMint with minter = user

        coin <- fetch coinCid
        assertMsg "COIN_ISSUER_MISMATCH" (coin.issuer == operator)
        assertMsg "COIN_OWNER_MISMATCH" (coin.owner == user)

        let usdcValue = coin.amount * cantonCoinPrice
        assertMsg "ZERO_VALUE" (usdcValue > 0.0)
        assertMsg "EXCEEDS_POOL_CAP" (totalUsdcStaked + usdcValue <= poolCap)

        -- Verify operator has enough USDCx to back the bridge
        usdcx <- fetch operatorUsdcxCid
        assertMsg "USDCX_OWNER_MISMATCH" (usdcx.owner == operator)
        assertMsg "USDCX_INSUFFICIENT" (usdcx.amount >= usdcValue)

        let localPrice = if totalShares > 0.0 then pooledUsdc / totalShares else sharePrice
        let baseShares = usdcValue / localPrice
        let multiplier = tierMultiplierBps selectedTier
        let boostedShares = baseShares * intToNumeric multiplier / 10000.0
        assertMsg "ZERO_SHARES" (boostedShares > 0.0)

        -- Burn coin (user's value consumed)
        exercise coinCid CantonCoin_Burn

        -- Consume operator's USDCx (split if needed) — relay redeems to USDC on Ethereum
        if usdcx.amount == usdcValue
          then archive operatorUsdcxCid
          else do
            _ <- exercise operatorUsdcxCid USDCx_Split with splitAmount = usdcValue
            -- splitAmount portion archived, remainder returned to operator
            pure ()

        -- BridgeOutRequest: relay bridges USDC value to Treasury → MetaVault #3 (Fluid)
        now <- getTime
        bridgeReq <- create BridgeOutRequest with
          operator; user; amount = usdcValue
          targetChainId; targetTreasury; nonce = nextNonce
          createdAt = now; status = "pending"; source = "ethpool"; validators

        (newPoolService, smusdeCid) <- _mintSmUsdE
          (this with nextNonce = nextNonce + 1)
          user usdcValue boostedShares selectedTier

        return (newPoolService, smusdeCid, bridgeReq)

    -- ──────────────────────────────────────────────────────
    --  UNSTAKE: smUSD-E → CantonMUSD (backed by Fluid returns)
    -- ──────────────────────────────────────────────────────

    -- | Unstake: smUSD-E shares → CantonMUSD.
    -- User receives proportional mUSD, newly created and backed by Fluid strategy returns.
    -- If user wants USDC, they use DirectMint_Redeem separately.
    choice ETHPool_Unstake : (ContractId CantonETHPoolService, ContractId CantonMUSD)
      with
        user : Party
        smusdeCid : ContractId CantonSMUSD_E
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        exercise complianceRegistryCid ValidateRedemption with redeemer = user

        smusde <- fetch smusdeCid
        assertMsg "OWNER_MISMATCH" (smusde.owner == user)

        -- Check time-lock expired
        now <- getTime
        case smusde.unlockAt of
          Some unlockTime -> assertMsg "POSITION_LOCKED" (now >= unlockTime)
          None -> pure ()

        -- Calculate withdrawal: pro-rata share of pooledUsdc (Fluid-backed)
        let musdAmount = if totalShares > 0.0
              then pooledUsdc * smusde.shares / totalShares
              else 0.0
        assertMsg "INSUFFICIENT_POOL_BALANCE" (musdAmount <= pooledUsdc)
        assertMsg "ZERO_WITHDRAWAL" (musdAmount > 0.0)

        -- Archive smUSD-E position
        archive smusdeCid

        -- Mint CantonMUSD to user (backed by USDC in Fluid strategy on Ethereum)
        userObs <- lookupUserObservers operator user None
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = musdAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        newService <- create this with
          totalShares = totalShares - smusde.shares
          totalUsdcStaked = if totalUsdcStaked >= smusde.musdStaked
                           then totalUsdcStaked - smusde.musdStaked
                           else 0.0
          pooledUsdc = pooledUsdc - musdAmount

        return (newService, musdCid)

    -- ──────────────────────────────────────────────────────
    --  SHARE PRICE SYNC (informational — from Fluid strategy on Ethereum)
    --  The actual stake/unstake price is derived from pooledUsdc / totalShares.
    --  This sync serves as a cross-chain consistency check and for display.
    -- ──────────────────────────────────────────────────────

    choice ETHPool_SyncSharePrice : ContractId CantonETHPoolService
      with
        newSharePrice : Money
        epochNumber : Int
        attestationHash : Text
        validatorCount : Int
      controller operator, governance
      do
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastSyncEpoch)
        assertMsg "SHARE_PRICE_POSITIVE" (newSharePrice > 0.0)
        assertMsg "ATTESTATION_REQUIRED" (attestationHash /= "")
        assertMsg "INSUFFICIENT_VALIDATORS" (validatorCount >= 3)
        let maxPrice = sharePrice * 1.1
        let minPrice = sharePrice * 0.9
        assertMsg "PRICE_INCREASE_TOO_LARGE" (newSharePrice <= maxPrice)
        assertMsg "PRICE_DECREASE_TOO_LARGE" (newSharePrice >= minPrice)
        create this with
          sharePrice = newSharePrice
          lastSyncEpoch = epochNumber

    -- ──────────────────────────────────────────────────────
    --  ADMIN
    -- ──────────────────────────────────────────────────────

    choice ETHPool_SetCantonCoinPrice : ContractId CantonETHPoolService
      with
        newPrice : Money
      controller operator, governance
      do
        assertMsg "PRICE_POSITIVE" (newPrice > 0.0)
        let maxPrice = cantonCoinPrice * 1.25
        let minPrice = cantonCoinPrice * 0.75
        assertMsg "CANTON_COIN_PRICE_CHANGE_TOO_LARGE" (newPrice <= maxPrice && newPrice >= minPrice)
        create this with cantonCoinPrice = newPrice

    choice ETHPool_SetPoolCap : ContractId CantonETHPoolService
      with
        newCap : Money
      controller operator, governance
      do
        assertMsg "CAP_POSITIVE" (newCap > 0.0)
        create this with poolCap = newCap

    choice ETHPool_SetPaused : ContractId CantonETHPoolService
      with
        newPaused : Bool
      controller operator
      do create this with paused = newPaused

    choice ETHPool_SetComplianceRegistry : ContractId CantonETHPoolService
      with
        newRegistryCid : ContractId ComplianceRegistry
      controller operator, governance
      do create this with complianceRegistryCid = newRegistryCid

    -- | Update bridge configuration
    choice ETHPool_SetBridgeConfig : ContractId CantonETHPoolService
      with
        newTargetChainId : Int
        newTargetTreasury : Text
        newValidators : [Party]
      controller operator, governance
      do create this with
          targetChainId = newTargetChainId
          targetTreasury = newTargetTreasury
          validators = newValidators

    -- | Receive yield from Ethereum bridge into the pool.
    -- Called by operator+governance after bridged yield CantonMUSD arrives on Canton.
    -- The yield mUSD is archived (accounted via counter) → pooledUsdc increases.
    -- Yield cap: max 10% of pool per call (matches Ethereum MAX_YIELD_BPS).
    choice ETHPool_ReceiveYield : ContractId CantonETHPoolService
      with
        yieldMusdCid : ContractId CantonMUSD
      controller operator, governance
      do
        assertMsg "SERVICE_PAUSED" (not paused)
        musd <- fetch yieldMusdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == operator)
        assertMsg "ZERO_YIELD" (musd.amount > 0.0)
        -- Cap yield per call at 10% of current pool (prevents manipulation)
        let maxYield = if pooledUsdc > 0.0 then pooledUsdc * 0.1 else musd.amount
        assertMsg "YIELD_EXCEEDS_MAX" (musd.amount <= maxYield)
        -- Archive yield mUSD → pool counter grows → share price rises
        exercise yieldMusdCid CantonMUSD_Burn
        create this with
          pooledUsdc = pooledUsdc + musd.amount


-- ============================================================
--                     INTERNAL HELPER
-- ============================================================

-- | Mint smUSD-E and update pool state. Used by all stake choices.
_mintSmUsdE : CantonETHPoolService -> Party -> Money -> Money -> TimeLockTier
            -> Update (ContractId CantonETHPoolService, ContractId CantonSMUSD_E)
_mintSmUsdE service user usdcValue boostedShares selectedTier = do
  now <- getTime
  let lockDuration = tierDurationSecs selectedTier
  let unlock = if lockDuration > 0
               then Some (addRelTime now (seconds lockDuration))
               else None

  let localPrice = if service.totalShares > 0.0
        then service.pooledUsdc / service.totalShares
        else service.sharePrice

  userObs <- lookupUserObservers service.operator user None
  smusdeCid <- create CantonSMUSD_E with
    issuer = service.operator
    owner = user
    shares = boostedShares
    entrySharePrice = localPrice
    musdStaked = usdcValue
    tier = selectedTier
    stakedAt = now
    unlockAt = unlock
    privacyObservers = userObs

  newService <- create service with
    totalShares = service.totalShares + boostedShares
    totalUsdcStaked = service.totalUsdcStaked + usdcValue
    pooledUsdc = service.pooledUsdc + usdcValue

  return (newService, smusdeCid)
