-- | CantonBoostPool
-- Canton-only Validator Reward Pool — qualified by sMUSD stake
--
-- Architecture:
--   Users deposit Canton coin ONLY into this pool.
--   Eligibility and deposit cap determined by their existing sMUSD position:
--     maxCantonDeposit (in mUSD value) = sMUSD value × 0.25
--   This enforces an effective 80/20 ratio without holding mUSD in this pool.
--
--   The user earns BOTH yields simultaneously:
--     1. sMUSD yield — from TreasuryV2 strategies (via CantonStakingService)
--     2. Validator rewards — from this pool (60% of Canton validator revenue)
--
-- Revenue Model:
--   Validator rewards split 60/40 (LP / Protocol)
--   Entry/exit fees (25-50 bps)
--   Protocol accumulates Canton for governance weight
--
-- Lifecycle:
--   Limited-time TVL driver. Sunset by pausing deposits,
--   letting LPs withdraw Canton. sMUSD positions are completely unaffected.

module CantonBoostPool where

import DA.Time
import CantonDirectMint (Money, Bps)
import CantonSMUSD (CantonSMUSD(..))
import UserPrivacySettings (lookupUserObservers)

-- ============================================================
--                     SECTION 1: CANTON COIN TOKEN
-- ============================================================

-- | Represents Canton coin held on Canton Network.
-- In production, this wraps the native Canton validator token.
template CantonCoin
  with
    issuer : Party
    owner  : Party
    amount : Money
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers
    ensure amount > 0.0

    -- | Update observers from user's privacy settings
    choice CantonCoin_UpdateObservers : ContractId CantonCoin
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice CantonCoin_Transfer : ContractId CantonCoinTransferProposal
      with newOwner : Party
      controller owner
      do create CantonCoinTransferProposal with coin = this; newOwner

    choice CantonCoin_Split : (ContractId CantonCoin, ContractId CantonCoin)
      with splitAmount : Money
      controller owner
      do
        assertMsg "SPLIT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    choice CantonCoin_Burn : ()
      controller issuer
      do return ()

-- | Transfer proposal for CantonCoin (dual-signatory safe)
template CantonCoinTransferProposal
  with
    coin     : CantonCoin
    newOwner : Party
  where
    signatory coin.issuer, coin.owner
    observer newOwner

    choice CantonCoinTransferProposal_Accept : ContractId CantonCoin
      controller newOwner
      do create coin with owner = newOwner

    choice CantonCoinTransferProposal_Reject : ContractId CantonCoin
      controller newOwner
      do create coin

    choice CantonCoinTransferProposal_Cancel : ContractId CantonCoin
      controller coin.owner
      do create coin

-- ============================================================
--                     SECTION 2: BOOST LP TOKEN
-- ============================================================

-- | Boost Pool LP token — represents a share of the Canton reward pool.
-- Redeemable for Canton coin proportional to pool balance.
template BoostPoolLP
  with
    issuer         : Party
    owner          : Party
    shares         : Money        -- LP share amount
    depositedAt    : Time         -- For cooldown enforcement
    privacyObservers : [Party]    -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers
    ensure shares > 0.0

    -- | Update observers from user's privacy settings
    choice BPLP_UpdateObservers : ContractId BoostPoolLP
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    choice BPLP_Transfer : ContractId BoostPoolLPTransferProposal
      with newOwner : Party
      controller owner
      do create BoostPoolLPTransferProposal with lp = this; newOwner

    choice BPLP_Split : (ContractId BoostPoolLP, ContractId BoostPoolLP)
      with splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_LESS_THAN_TOTAL" (splitShares < shares)
        c1 <- create this with shares = splitShares
        c2 <- create this with shares = shares - splitShares
        return (c1, c2)

-- | Transfer proposal for BoostPoolLP (dual-signatory safe)
template BoostPoolLPTransferProposal
  with
    lp       : BoostPoolLP
    newOwner : Party
  where
    signatory lp.issuer, lp.owner
    observer newOwner

    choice BPLPTransferProposal_Accept : ContractId BoostPoolLP
      controller newOwner
      do create lp with owner = newOwner

    choice BPLPTransferProposal_Reject : ContractId BoostPoolLP
      controller newOwner
      do create lp

    choice BPLPTransferProposal_Cancel : ContractId BoostPoolLP
      controller lp.owner
      do create lp

-- ============================================================
--                     SECTION 3: CANTON BOOST POOL SERVICE
-- ============================================================

-- | Canton-only validator reward pool, qualified by sMUSD stake.
--
-- How it works:
--   1. User must already hold CantonSMUSD (staked mUSD in the sMUSD pool)
--   2. Max Canton deposit = sMUSD value (shares × globalSharePrice) × 0.25
--      This enforces an effective 80/20 ratio by reference, not by holding mUSD
--   3. User deposits Canton → receives BoostPoolLP shares
--   4. Validator rewards distributed per-epoch: 60% to LPs, 40% to protocol
--   5. User withdraws → receives Canton (proportional to LP shares)
--   6. User's sMUSD position is completely independent and unaffected
template CantonBoostPoolService
  with
    operator               : Party
    -- Pool state
    totalCantonDeposited   : Money      -- Total Canton in pool
    totalLPShares          : Money      -- Total LP shares outstanding
    -- Canton pricing (for cap calculation)
    cantonPriceMusd        : Money      -- Canton coin price in mUSD terms
    -- sMUSD reference (for reading user eligibility)
    globalSharePrice       : Money      -- Synced from CantonStakingService for cap calc
    -- Validator rewards tracking
    totalValidatorRewards  : Money      -- Cumulative rewards earned
    protocolRewardsAccrued : Money      -- 40% kept by protocol
    lpRewardsDistributed   : Money      -- 60% distributed to LPs
    lastRewardEpoch        : Int        -- Last reward distribution epoch
    -- Pool parameters
    entryFeeBps            : Bps        -- Entry fee (default 25 = 0.25%)
    exitFeeBps             : Bps        -- Exit fee (default 50 = 0.50%)
    lpRewardShareBps       : Bps        -- LP share of validator rewards (default 6000 = 60%)
    cantonCapRatio         : Money      -- Max Canton value as ratio of sMUSD value (default 0.25 = 20/80)
    cooldownSeconds        : Int        -- Minimum lock before withdrawal
    paused                 : Bool
    observers              : [Party]
  where
    signatory operator
    observer observers

    ensure totalCantonDeposited >= 0.0
        && totalLPShares >= 0.0
        && cantonPriceMusd > 0.0
        && globalSharePrice > 0.0
        && entryFeeBps >= 0 && entryFeeBps <= 500
        && exitFeeBps >= 0 && exitFeeBps <= 500
        && lpRewardShareBps >= 0 && lpRewardShareBps <= 10000
        && cantonCapRatio > 0.0 && cantonCapRatio <= 1.0

    -- ──────────────────────────────────────────────
    --  DEPOSIT: Canton only, qualified by sMUSD stake
    -- ──────────────────────────────────────────────

    -- | Deposit Canton into the boost pool.
    -- User must hold CantonSMUSD. Max deposit = sMUSD value × cantonCapRatio.
    -- Canton deposited earns validator rewards. sMUSD continues earning Treasury yield independently.
    choice Deposit : (ContractId CantonBoostPoolService, ContractId BoostPoolLP)
      with
        user       : Party
        cantonCid  : ContractId CantonCoin      -- Canton being deposited
        smusdCid   : ContractId CantonSMUSD     -- Reference only — NOT consumed
      controller user
      do
        assertMsg "POOL_PAUSED" (not paused)

        canton <- fetch cantonCid
        assertMsg "CANTON_ISSUER_MISMATCH" (canton.issuer == operator)
        assertMsg "CANTON_OWNER_MISMATCH" (canton.owner == user)

        -- Read sMUSD position (fetch only — NOT archived/consumed)
        smusd <- fetch smusdCid
        assertMsg "SMUSD_OWNER_MISMATCH" (smusd.owner == user)
        assertMsg "SMUSD_ISSUER_MISMATCH" (smusd.issuer == operator)

        -- Calculate deposit cap from sMUSD value
        -- sMUSD value in mUSD terms = shares × globalSharePrice
        let smusdValueMusd = smusd.shares * globalSharePrice
        -- Max Canton value (in mUSD) = sMUSD value × 0.25 (enforces 80/20 by reference)
        let maxCantonValueMusd = smusdValueMusd * cantonCapRatio
        -- How much Canton (in mUSD terms) the user is depositing
        let cantonValueMusd = canton.amount * cantonPriceMusd
        assertMsg "EXCEEDS_SMUSD_QUALIFIED_CAP" (cantonValueMusd <= maxCantonValueMusd)

        -- Apply entry fee
        let feeAmount = canton.amount * intToNumeric entryFeeBps / 10000.0
        let netCantonIn = canton.amount - feeAmount

        -- Calculate LP shares: 1 share = 1 Canton at genesis, then proportional
        let newShares = if totalLPShares == 0.0
              then netCantonIn
              else netCantonIn * totalLPShares / totalCantonDeposited

        -- Lock Canton (burn from user, add to pool)
        exercise cantonCid CantonCoin_Burn

        -- Issue LP token
        now <- getTime
        userObs <- lookupUserObservers operator user
        lpCid <- create BoostPoolLP with
          issuer = operator
          owner = user
          shares = newShares
          depositedAt = now
          privacyObservers = userObs

        -- Update pool state (consuming choice auto-archives self)
        newService <- create this with
          totalCantonDeposited = totalCantonDeposited + netCantonIn
          totalLPShares = totalLPShares + newShares

        return (newService, lpCid)

    -- ──────────────────────────────────────────────
    --  WITHDRAW: LP shares → Canton
    -- ──────────────────────────────────────────────

    -- | Withdraw Canton from the pool by burning LP tokens.
    -- Returns proportional share of pool Canton balance.
    choice Withdraw : (ContractId CantonBoostPoolService, ContractId CantonCoin)
      with
        user  : Party
        lpCid : ContractId BoostPoolLP
      controller user
      do
        assertMsg "POOL_PAUSED" (not paused)

        lp <- fetch lpCid
        assertMsg "LP_OWNER_MISMATCH" (lp.owner == user)

        -- Enforce cooldown
        now <- getTime
        let cooldownRel = seconds cooldownSeconds
        let elapsed = subTime now lp.depositedAt
        assertMsg "COOLDOWN_NOT_ELAPSED" (elapsed >= cooldownRel)

        -- Calculate proportional Canton out
        let shareRatio = lp.shares / totalLPShares
        let rawCantonOut = totalCantonDeposited * shareRatio

        -- Apply exit fee
        let feeAmount = rawCantonOut * intToNumeric exitFeeBps / 10000.0
        let netCantonOut = rawCantonOut - feeAmount

        -- Burn LP token
        archive lpCid

        -- Mint Canton back to user
        userObs <- lookupUserObservers operator user
        cantonCid <- create CantonCoin with
          issuer = operator
          owner = user
          amount = netCantonOut
          privacyObservers = userObs

        -- Update pool state (consuming choice auto-archives self)
        newService <- create this with
          totalCantonDeposited = totalCantonDeposited - rawCantonOut
          totalLPShares = totalLPShares - lp.shares

        return (newService, cantonCid)

    -- ──────────────────────────────────────────────
    --  DISTRIBUTE VALIDATOR REWARDS
    -- ──────────────────────────────────────────────

    -- | Operator distributes Canton validator rewards to the pool.
    -- Split: 60% added to pool balance (increases LP share value)
    --        40% accrued to protocol (withdrawable separately)
    choice DistributeRewards : ContractId CantonBoostPoolService
      with
        rewardAmount : Money
        epochNumber  : Int
      controller operator
      do
        assertMsg "EPOCH_SEQUENTIAL" (epochNumber > lastRewardEpoch)
        assertMsg "REWARD_POSITIVE" (rewardAmount > 0.0)

        let lpShare = rewardAmount * intToNumeric lpRewardShareBps / 10000.0
        let protocolShare = rewardAmount - lpShare

        -- LP share goes into pool Canton balance (share price increases)
        create this with
          totalCantonDeposited = totalCantonDeposited + lpShare
          totalValidatorRewards = totalValidatorRewards + rewardAmount
          protocolRewardsAccrued = protocolRewardsAccrued + protocolShare
          lpRewardsDistributed = lpRewardsDistributed + lpShare
          lastRewardEpoch = epochNumber

    -- ──────────────────────────────────────────────
    --  SYNC PRICES (operator updates from external sources)
    -- ──────────────────────────────────────────────

    -- | Update Canton/mUSD price (from oracle or market data).
    -- Used for deposit cap calculations.
    choice SyncCantonPrice : ContractId CantonBoostPoolService
      with
        newPriceMusd : Money
      controller operator
      do
        assertMsg "PRICE_POSITIVE" (newPriceMusd > 0.0)
        -- Cap price change at 20% per update
        let maxPrice = cantonPriceMusd * 1.2
        let minPrice = cantonPriceMusd * 0.8
        assertMsg "PRICE_CHANGE_TOO_LARGE" (newPriceMusd >= minPrice && newPriceMusd <= maxPrice)

        create this with cantonPriceMusd = newPriceMusd

    -- | Sync the global sMUSD share price (from CantonStakingService).
    -- Keeps deposit cap calculation current as sMUSD yield accrues.
    choice SyncSharePrice : ContractId CantonBoostPoolService
      with
        newGlobalSharePrice : Money
      controller operator
      do
        assertMsg "SHARE_PRICE_POSITIVE" (newGlobalSharePrice > 0.0)
        -- Cap at 10% decrease (same guard as CantonStakingService)
        let minAllowed = globalSharePrice * 0.9
        assertMsg "SHARE_PRICE_DECREASE_TOO_LARGE" (newGlobalSharePrice >= minAllowed)

        create this with globalSharePrice = newGlobalSharePrice

    -- ──────────────────────────────────────────────
    --  PROTOCOL REWARD WITHDRAWAL
    -- ──────────────────────────────────────────────

    -- | Operator withdraws accumulated protocol Canton rewards (the 40% share).
    choice WithdrawProtocolRewards : (ContractId CantonBoostPoolService, ContractId CantonCoin)
      with
        withdrawAmount : Money
      controller operator
      do
        assertMsg "AMOUNT_POSITIVE" (withdrawAmount > 0.0)
        assertMsg "INSUFFICIENT_PROTOCOL_REWARDS" (withdrawAmount <= protocolRewardsAccrued)

        cantonCid <- create CantonCoin with
          issuer = operator
          owner = operator
          amount = withdrawAmount
          privacyObservers = []  -- Protocol wallet, fully private

        newService <- create this with
          protocolRewardsAccrued = protocolRewardsAccrued - withdrawAmount

        return (newService, cantonCid)

    -- ──────────────────────────────────────────────
    --  ADMIN
    -- ──────────────────────────────────────────────

    choice BoostPool_SetPaused : ContractId CantonBoostPoolService
      with newPaused : Bool
      controller operator
      do
        create this with paused = newPaused

    choice BoostPool_UpdateFees : ContractId CantonBoostPoolService
      with
        newEntryFeeBps : Bps
        newExitFeeBps  : Bps
      controller operator
      do
        assertMsg "ENTRY_FEE_VALID" (newEntryFeeBps >= 0 && newEntryFeeBps <= 500)
        assertMsg "EXIT_FEE_VALID" (newExitFeeBps >= 0 && newExitFeeBps <= 500)
        create this with
          entryFeeBps = newEntryFeeBps
          exitFeeBps = newExitFeeBps

    choice BoostPool_UpdateCapRatio : ContractId CantonBoostPoolService
      with
        newCapRatio : Money
      controller operator
      do
        assertMsg "CAP_RATIO_VALID" (newCapRatio > 0.0 && newCapRatio <= 1.0)
        create this with cantonCapRatio = newCapRatio

    choice BoostPool_UpdateObservers : ContractId CantonBoostPoolService
      with newObservers : [Party]
      controller operator
      do
        create this with observers = newObservers
