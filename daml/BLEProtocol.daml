-- BLE Protocol - Fixed Version
-- Fixes: D-01 (TOCTOU), D-02 (Signature Uniqueness), D-03 (Timestamp Validation)

module BLEProtocol where

import DA.Time
import DA.List (dedup)
import DA.Text qualified as T
import DA.Set qualified as Set
import DA.Foldable hiding (elem, length, all)

-- 18-decimal precision for 1:1 mapping with Ethereum Wei
type Money = Numeric 18

-- 1. INSTITUTIONAL EQUITY POSITION
-- Maintained by participating banks. Validator Group observes the aggregate value.
template InstitutionalEquityPosition
  with
    bank: Party
    validatorGroup: [Party]
    aggregator: Party
    totalValue: Money     -- Total USD Equity Value verified on this node
    referenceId: Text     -- Unique ID for the bank's internal ledger
    lastUpdated: Time
  where
    signatory bank
    observer aggregator, validatorGroup

    -- FIX D-M03: Require strictly positive totalValue
    ensure totalValue > 0.0

    key (bank, aggregator) : (Party, Party)
    maintainer key._1

    choice UpdateEquity : ContractId InstitutionalEquityPosition
      with newValue: Money
      controller bank
      do
        -- FIX 5C-M07: Validate positive value to prevent zero/negative equity positions
        assertMsg "VALUE_MUST_BE_POSITIVE" (newValue > 0.0)
        now <- getTime
        create this with totalValue = newValue, lastUpdated = now


-- 2. GLOBAL ATTESTATION PAYLOAD
-- FIX D-03: Added expiresAt for timestamp validation
data AttestationPayload = AttestationPayload with
    attestationId: Text
    globalCantonAssets: Money
    targetAddress: Text
    amount: Money
    isMint: Bool
    nonce: Int
    chainId: Int
    expiresAt: Time        -- FIX D-03: Expiration timestamp
  deriving (Eq, Show)


-- 3. THE GLOBAL ATTESTATION REQUEST
-- FIX D-01: Changed to consuming choice with position locking
-- FIX D-02: Added signature tracking set
template AttestationRequest
  with
    aggregator: Party
    validatorGroup: [Party]
    payload: AttestationPayload
    positionCids: [ContractId InstitutionalEquityPosition]
    collectedSignatures: Set.Set Party  -- FIX D-02: Track who has signed
  where
    signatory aggregator
    observer validatorGroup

    -- FIX H-6: Bound validator group size to prevent DoS via O(n^2) dedup
    ensure length validatorGroup > 0 && length validatorGroup <= 100

    -- FIX D-01: Consuming choice to prevent TOCTOU
    -- Positions are locked when attestation begins
    choice ProvideSignature : (ContractId AttestationRequest, ContractId ValidatorSignature)
      with
        validator: Party
        ecdsaSignature: Text
      controller validator
      do
        -- FIX D-02: Ensure validator hasn't already signed
        assertMsg "VALIDATOR_ALREADY_SIGNED" (not (Set.member validator collectedSignatures))
        assertMsg "UNAUTHORIZED_VALIDATOR" (validator `elem` validatorGroup)
        -- FIX M-24: Basic signature format validation
        assertMsg "INVALID_SIGNATURE_FORMAT" (T.length ecdsaSignature > 0)
        assertMsg "SIGNATURE_TOO_SHORT" (T.length ecdsaSignature >= 130)

        -- FIX D-03: Check expiration
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)

        -- ATOMIC FETCH: Verify linked positions
        positions <- mapA fetch positionCids
        let totalGlobalValue = sum [p.totalValue | p <- positions]

        -- VERIFICATION: Enforce 110% Collateral Ratio
        assertMsg "INSUFFICIENT_GLOBAL_COLLATERAL" (totalGlobalValue >= payload.amount * 1.1)
        -- FIX D-H08: Use tolerance-based comparison for Numeric 18 (1 USD tolerance)
        let valueDiff = if totalGlobalValue > payload.globalCantonAssets
                        then totalGlobalValue - payload.globalCantonAssets
                        else payload.globalCantonAssets - totalGlobalValue
        assertMsg "PAYLOAD_VALUE_MISMATCH" (valueDiff < 1.0)

        -- FIX D-02: Update signature tracking
        let newSignatures = Set.insert validator collectedSignatures

        -- Archive and recreate with updated signatures
        newRequest <- create this with collectedSignatures = newSignatures

        sig <- create ValidatorSignature with
            requestId = newRequest
            validator
            aggregator
            ecdsaSignature
            nonce = payload.nonce

        return (newRequest, sig)

    -- FIX D-01: Choice to finalize and consume positions atomically
    -- FIX C-12: requiredSignatures is now derived from validatorGroup, not caller-supplied
    -- FIX H-17: Signature uniqueness enforced via dedup check
    choice FinalizeAttestation : [ContractId ValidatorSignature]
      with
        signatureCids: [ContractId ValidatorSignature]
      controller aggregator
      do
        -- FIX C-12: Derive quorum from validator group size (supermajority).
        -- FIX H-3: Intentionally SUPERMAJORITY (>50%+1) for stronger security:
        --   5 validators -> 4 required (80%), 7 validators -> 5 required (71%)
        let requiredSignatures = (length validatorGroup + 1) / 2 + 1
        -- Verify we have enough signatures
        assertMsg "INSUFFICIENT_SIGNATURES" (length signatureCids >= requiredSignatures)

        -- FIX D-03: Check expiration
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)

        -- Verify all signatures are valid and from authorized validators
        sigs <- mapA fetch signatureCids
        let sigValidators = map (.validator) sigs

        -- FIX H-17: Enforce signature uniqueness
        let uniqueValidators = Set.fromList sigValidators
        assertMsg "DUPLICATE_VALIDATOR_SIGNATURES" (Set.size uniqueValidators == length sigValidators)

        assertMsg "INVALID_SIGNATURE_VALIDATORS" (all (`elem` validatorGroup) sigValidators)

        -- FIX C-08: Consume and recreate positions to lock the collateral value
        -- This prevents the TOCTOU race condition
        positions <- mapA fetch positionCids
        let totalGlobalValue = sum [p.totalValue | p <- positions]

        -- Final verification before attestation is considered valid
        assertMsg "INSUFFICIENT_GLOBAL_COLLATERAL" (totalGlobalValue >= payload.amount * 1.1)

        -- FIX D-M05: Archive signature contracts after finalization to prevent reuse
        mapA archive signatureCids

        return signatureCids


-- 4. THE SIGNATURE RECORD
template ValidatorSignature
  with
    requestId: ContractId AttestationRequest
    validator: Party
    aggregator: Party
    ecdsaSignature: Text
    nonce: Int
  where
    signatory validator
    observer aggregator


-- 5. HELPER: Create new attestation request
createAttestationRequest : Party -> [Party] -> AttestationPayload -> [ContractId InstitutionalEquityPosition] -> Update (ContractId AttestationRequest)
createAttestationRequest aggregator validators payload positions = do
  create AttestationRequest with
    aggregator
    validatorGroup = validators
    payload
    positionCids = positions
    collectedSignatures = Set.empty  -- FIX D-02: Initialize empty set
