-- BLE Protocol - Fixed Version
-- Fixes: D-01 (TOCTOU), D-02 (Signature Uniqueness), D-03 (Timestamp Validation)

module BLEProtocol where

import DA.Time
import DA.List (dedup)
import DA.Text qualified as T
import DA.Set qualified as Set
import DA.Foldable hiding (elem, length, all, sum)

-- 18-decimal precision for 1:1 mapping with Ethereum Wei
type Money = Numeric 18

-- 1. INSTITUTIONAL EQUITY POSITION
-- Maintained by participating banks. Validator Group observes the aggregate value.
template InstitutionalEquityPosition
  with
    bank: Party
    validatorGroup: [Party]
    aggregator: Party
    totalValue: Money     -- Total USD Equity Value verified on this node
    referenceId: Text     -- Unique ID for the bank's internal ledger
    lastUpdated: Time
  where
    signatory bank
    observer aggregator, validatorGroup

    -- Require strictly positive totalValue
    ensure totalValue > 0.0

    key (bank, aggregator) : (Party, Party)
    maintainer key._1

    choice UpdateEquity : ContractId InstitutionalEquityPosition
      with newValue: Money
      controller bank
      do
        -- Validate positive value to prevent zero/negative equity positions
        assertMsg "VALUE_MUST_BE_POSITIVE" (newValue > 0.0)
        now <- getTime
        create this with totalValue = newValue, lastUpdated = now


-- 2. GLOBAL ATTESTATION PAYLOAD
-- Added expiresAt for timestamp validation
data AttestationPayload = AttestationPayload with
    attestationId: Text
    globalCantonAssets: Money
    targetAddress: Text
    amount: Money
    isMint: Bool
    nonce: Int
    chainId: Int
    expiresAt: Time        -- Expiration timestamp
  deriving (Eq, Show)


-- 3. THE GLOBAL ATTESTATION REQUEST
-- Changed to consuming choice with position locking
-- Added signature tracking set
template AttestationRequest
  with
    aggregator: Party
    validatorGroup: [Party]
    payload: AttestationPayload
    positionCids: [ContractId InstitutionalEquityPosition]
    collectedSignatures: Set.Set Party  -- Track who has signed
  where
    signatory aggregator
    observer validatorGroup

    -- Bound validator group size to prevent DoS via O(n^2) dedup
    ensure length validatorGroup > 0 && length validatorGroup <= 100

    -- Consuming choice to prevent TOCTOU
    -- Positions are locked when attestation begins
    choice ProvideSignature : (ContractId AttestationRequest, ContractId ValidatorSignature)
      with
        validator: Party
        ecdsaSignature: Text
      controller validator
      do
        -- Ensure validator hasn't already signed
        assertMsg "VALIDATOR_ALREADY_SIGNED" (not (Set.member validator collectedSignatures))
        assertMsg "UNAUTHORIZED_VALIDATOR" (validator `elem` validatorGroup)
        -- Basic signature format validation
        assertMsg "INVALID_SIGNATURE_FORMAT" (T.length ecdsaSignature > 0)
        assertMsg "SIGNATURE_TOO_SHORT" (T.length ecdsaSignature >= 130)

        -- Check expiration
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)

        -- ATOMIC FETCH: Verify linked positions
        positions <- mapA fetch positionCids
        let totalGlobalValue = sum [p.totalValue | p <- positions]

        -- VERIFICATION: Enforce 110% Collateral Ratio
        assertMsg "INSUFFICIENT_GLOBAL_COLLATERAL" (totalGlobalValue >= payload.amount * 1.1)
        -- Use tolerance-based comparison for Numeric 18 (1 USD tolerance)
        let valueDiff = if totalGlobalValue > payload.globalCantonAssets
                        then totalGlobalValue - payload.globalCantonAssets
                        else payload.globalCantonAssets - totalGlobalValue
        assertMsg "PAYLOAD_VALUE_MISMATCH" (valueDiff < 1.0)

        -- Update signature tracking
        let newSignatures = Set.insert validator collectedSignatures

        -- Archive and recreate with updated signatures
        newRequest <- create this with collectedSignatures = newSignatures

        sig <- create ValidatorSignature with
            requestId = newRequest
            validator
            aggregator
            ecdsaSignature
            nonce = payload.nonce

        return (newRequest, sig)

    -- Choice to finalize and consume positions atomically
    -- requiredSignatures is now derived from validatorGroup, not caller-supplied
    -- Signature uniqueness enforced via dedup check
    choice FinalizeAttestation : [ContractId ValidatorSignature]
      with
        signatureCids: [ContractId ValidatorSignature]
      controller aggregator
      do
        -- Supermajority quorum (67%) for Byzantine fault tolerance
        -- For 5 validators: ceil(3.33) = 4 required (80%)
        -- For 7 validators: ceil(4.67) = 5 required (71%)
        let n = length validatorGroup
        let requiredSignatures = (n * 2 + 2) / 3  -- ceil(2n/3) using integer arithmetic
        -- Verify we have enough signatures
        assertMsg "INSUFFICIENT_SIGNATURES" (length signatureCids >= requiredSignatures)

        -- Check expiration
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)

        -- Verify all signatures are valid and from authorized validators
        sigs <- mapA fetch signatureCids
        let sigValidators = map (.validator) sigs

        -- Enforce signature uniqueness
        let uniqueValidators = Set.fromList sigValidators
        assertMsg "DUPLICATE_VALIDATOR_SIGNATURES" (Set.size uniqueValidators == length sigValidators)

        assertMsg "INVALID_SIGNATURE_VALIDATORS" (all (`elem` validatorGroup) sigValidators)

        -- Consume and recreate positions to lock the collateral value
        -- This prevents the TOCTOU race condition
        positions <- mapA fetch positionCids
        let totalGlobalValue = sum [p.totalValue | p <- positions]

        -- Final verification before attestation is considered valid
        assertMsg "INSUFFICIENT_GLOBAL_COLLATERAL" (totalGlobalValue >= payload.amount * 1.1)

        -- Archive signature contracts after finalization to prevent reuse
        mapA archive signatureCids

        return signatureCids


-- 4. THE SIGNATURE RECORD
-- Both aggregator AND validator are signatories.
-- The ProvideSignature choice (controller validator) provides the validator's authorization.
-- This prevents the aggregator from forging any validator's signature.
template ValidatorSignature
  with
    requestId: ContractId AttestationRequest
    validator: Party
    aggregator: Party
    ecdsaSignature: Text
    nonce: Int
  where
    signatory aggregator, validator


-- 5. HELPER: Create new attestation request
createAttestationRequest : Party -> [Party] -> AttestationPayload -> [ContractId InstitutionalEquityPosition] -> Update (ContractId AttestationRequest)
createAttestationRequest aggregator validators payload positions = do
  create AttestationRequest with
    aggregator
    validatorGroup = validators
    payload
    positionCids = positions
    collectedSignatures = Set.empty  -- Initialize empty set
