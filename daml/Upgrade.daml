-- | Upgrade.daml - Contract Upgrade and Data Migration Framework
--
-- This module provides a safe, auditable mechanism for migrating contract state
-- when upgrading from one template version to another. It follows Canton best
-- practices for contract upgrades:
--
--   1. Operator proposes an upgrade with a migration script hash
--   2. Governance approves the upgrade (multi-sig threshold)
--   3. Asset holders explicitly opt-in to migrate their holdings
--   4. All migrations are logged for audit trail
--
-- Design decisions:
--   - No automatic migration: Users must consent to upgrade their holdings
--   - Batch limits prevent gas-like exhaustion on Canton
--   - Rollback window allows reverting if issues discovered post-migration
--   - All state transitions logged via UpgradeMigrationLog

module Upgrade where

import DA.Time
import DA.Set qualified as Set
import DA.List (dedup)
import DA.Optional (isSome, fromSome)
import DA.Text qualified as T
import DA.Action (forA)

-- ============================================================
--                     TYPE DEFINITIONS
-- ============================================================

-- | Upgrade status lifecycle
data UpgradeStatus
  = Proposed      -- Initial proposal awaiting approvals
  | Approved      -- Governance threshold met
  | Active        -- Migration window open
  | Completed     -- All migrations finalized
  | Cancelled     -- Upgrade aborted
  | RolledBack    -- Upgrade reverted after issues
  deriving (Eq, Show)

-- | Migration direction for rollback support
data MigrationDirection
  = Forward       -- V(n) -> V(n+1)
  | Backward      -- V(n+1) -> V(n) rollback
  deriving (Eq, Show)

-- ============================================================
--                     1. UPGRADE PROPOSAL
-- ============================================================

-- | UpgradeProposal - Governance proposal for contract upgrade.
-- Requires threshold approvals from governance signers before activation.
template UpgradeProposal
  with
    operator : Party              -- Protocol operator initiating upgrade
    governance : [Party]          -- List of governance signers
    approvalThreshold : Int       -- Number of approvals required (e.g., 2-of-3)
    approvals : Set.Set Party     -- Collected approvals
    sourceVersion : Text          -- Current version (e.g., "V2")
    targetVersion : Text          -- New version (e.g., "V3")
    migrationScriptHash : Text    -- SHA-256 of migration logic for verification
    changelogUri : Text           -- Link to upgrade documentation
    proposedAt : Time
    activationDelay : RelTime     -- Time between approval and activation
    migrationWindowDays : Int     -- How long users have to migrate
    rollbackWindowDays : Int      -- How long rollback is available post-migration
    status : UpgradeStatus
  where
    signatory operator
    observer governance

    ensure approvalThreshold > 0
        && approvalThreshold <= length governance
        && T.length sourceVersion > 0
        && T.length targetVersion > 0
        && T.length migrationScriptHash == 64  -- SHA-256 hex
        && migrationWindowDays > 0
        && rollbackWindowDays >= 0

    key (operator, sourceVersion, targetVersion) : (Party, Text, Text)
    maintainer key._1

    -- | Governance member approves the upgrade
    choice UpgradeProposal_Approve : ContractId UpgradeProposal
      with
        approver : Party
      controller approver
      do
        assertMsg "NOT_GOVERNANCE_MEMBER" (approver `elem` governance)
        assertMsg "ALREADY_APPROVED" (not (Set.member approver approvals))
        assertMsg "INVALID_STATUS" (status == Proposed)
        
        let newApprovals = Set.insert approver approvals
        let isApproved = Set.size newApprovals >= approvalThreshold
        
        create this with
          approvals = newApprovals
          status = if isApproved then Approved else Proposed

    -- | Activate the upgrade after approval and delay
    choice UpgradeProposal_Activate : ContractId UpgradeRegistry
      with
        activator : Party
      controller operator
      do
        assertMsg "NOT_APPROVED" (status == Approved)
        now <- getTime
        let activationTime = addRelTime proposedAt activationDelay
        assertMsg "ACTIVATION_DELAY_NOT_MET" (now >= activationTime)
        
        -- Create the active registry for migrations
        create UpgradeRegistry with
          operator
          governance
          approvalThreshold  -- BLOCK-3: Carry forward for rollback threshold
          sourceVersion
          targetVersion
          migrationScriptHash
          activatedAt = now
          migrationDeadline = addRelTime now (days migrationWindowDays)
          rollbackDeadline = addRelTime now (days (migrationWindowDays + rollbackWindowDays))
          totalMigrated = 0
          totalRolledBack = 0
          status = Active

    -- | Cancel the upgrade proposal
    choice UpgradeProposal_Cancel : ()
      with
        reason : Text
      controller operator
      do
        assertMsg "CANNOT_CANCEL_ACTIVE" (status == Proposed || status == Approved)
        assertMsg "REASON_REQUIRED" (T.length reason > 0)
        return ()

-- ============================================================
--                     2. UPGRADE REGISTRY
-- ============================================================

-- | UpgradeRegistry - Active upgrade tracking and migration coordination.
-- Created after proposal approval, tracks all migrations.
template UpgradeRegistry
  with
    operator : Party
    governance : [Party]
    approvalThreshold : Int     -- BLOCK-3: Stored for EmergencyRollback threshold symmetry
    sourceVersion : Text
    targetVersion : Text
    migrationScriptHash : Text
    activatedAt : Time
    migrationDeadline : Time
    rollbackDeadline : Time
    totalMigrated : Int
    totalRolledBack : Int
    status : UpgradeStatus
  where
    signatory operator
    observer governance

    ensure totalMigrated >= 0 && totalRolledBack >= 0

    key (operator, sourceVersion, targetVersion) : (Party, Text, Text)
    maintainer key._1

    -- | Record a successful migration (called by MigrationTicket)
    choice UpgradeRegistry_RecordMigration : ContractId UpgradeRegistry
      with
        count : Int
        direction : MigrationDirection
      controller operator
      do
        now <- getTime
        case direction of
          Forward -> do
            assertMsg "MIGRATION_WINDOW_CLOSED" (now <= migrationDeadline)
            create this with totalMigrated = totalMigrated + count
          Backward -> do
            assertMsg "ROLLBACK_WINDOW_CLOSED" (now <= rollbackDeadline)
            create this with totalRolledBack = totalRolledBack + count

    -- | Complete the upgrade (closes migration window)
    choice UpgradeRegistry_Complete : ContractId UpgradeRegistry
      controller operator
      do
        now <- getTime
        assertMsg "MIGRATION_WINDOW_NOT_ENDED" (now > migrationDeadline)
        create this with status = Completed

    -- | Emergency rollback (governance triggered)
    -- BLOCK-3: Requires approvalThreshold governance members (not just 1) for symmetry
    -- with the approval process. A single-member rollback is asymmetric and dangerous.
    choice UpgradeRegistry_EmergencyRollback : ContractId UpgradeRegistry
      with
        reason : Text
        authorizers : [Party]  -- BLOCK-3: Multiple governance members required
      controller authorizers
      do
        -- BLOCK-3: All authorizers must be governance members
        let allGov = all (`elem` governance) authorizers
        assertMsg "NOT_ALL_GOVERNANCE" allGov
        -- BLOCK-3: Require same threshold as approval (symmetric security)
        let uniqueAuth = Set.size (Set.fromList authorizers)
        assertMsg "INSUFFICIENT_ROLLBACK_APPROVALS" (uniqueAuth >= approvalThreshold)
        assertMsg "REASON_REQUIRED" (T.length reason > 0)
        now <- getTime
        assertMsg "ROLLBACK_WINDOW_CLOSED" (now <= rollbackDeadline)
        create this with status = RolledBack

-- ============================================================
--                     3. MIGRATION TICKET
-- ============================================================

-- | MigrationTicket - User's opt-in to migrate their holdings.
-- Each user must explicitly request migration of their assets.
template MigrationTicket
  with
    operator : Party
    holder : Party                -- Asset owner requesting migration
    upgradeKey : (Party, Text, Text)  -- Reference to UpgradeRegistry
    contractsToMigrate : [Text]   -- Contract IDs to migrate (serialized)
    requestedAt : Time
    batchSize : Int               -- Max contracts per migration tx
    direction : MigrationDirection
  where
    signatory operator, holder

    ensure length contractsToMigrate > 0
        && batchSize > 0
        && batchSize <= 100  -- Prevent DoS

    -- | Execute the migration (operator processes after validation)
    -- BLOCK-3: Migration now requires completed MigrationStep contracts as proof
    -- of actual archive+create work. The ticket verifies steps were performed
    -- and creates an immutable audit log.
    choice MigrationTicket_Execute : ContractId UpgradeMigrationLog
      with
        migrationStepCids : [ContractId MigrationStep]  -- BLOCK-3: Proof of actual migration work
      controller operator
      do
        now <- getTime
        
        -- Verify upgrade is still active
        (registryCid, registry) <- fetchByKey @UpgradeRegistry upgradeKey
        assertMsg "UPGRADE_NOT_ACTIVE" (registry.status == Active)
        
        -- BLOCK-3: Verify each migration step was completed for this ticket's contracts
        assertMsg "STEP_COUNT_MISMATCH" (length migrationStepCids == length contractsToMigrate)
        _ <- forA migrationStepCids $ \stepCid -> do
          step <- fetch stepCid
          assertMsg "STEP_NOT_COMPLETED" step.completed
          assertMsg "STEP_HOLDER_MISMATCH" (step.holder == holder)
          assertMsg "STEP_OPERATOR_MISMATCH" (step.operator == operator)
          -- Archive the consumed step (proof was verified)
          archive stepCid
        
        -- Record migration count
        exercise registryCid UpgradeRegistry_RecordMigration with
          count = length contractsToMigrate
          direction
        
        -- Create audit log
        create UpgradeMigrationLog with
          operator
          holder
          sourceVersion = upgradeKey._2
          targetVersion = upgradeKey._3
          contractsMigrated = contractsToMigrate
          migratedAt = now
          direction
          txHash = ""  -- Populated by ledger

    -- | Cancel migration request
    choice MigrationTicket_Cancel : ()
      controller holder
      do return ()

-- ============================================================
--                     4. MIGRATION STEP (BLOCK-3)
-- ============================================================

-- | MigrationStep - Proof that an actual contract migration was performed.
-- Created by template-specific migration executors after archiving the source
-- contract and creating the target contract. The MigrationTicket_Execute
-- choice verifies these steps before recording the migration.
--
-- BLOCK-3 Architecture Note:
--   DAML's type system prevents generic contract migration (you can't archive
--   a ContractId without knowing its template type). Migration is therefore
--   a two-phase process:
--
--   Phase 1: Template-specific executor archives old contract, creates new contract,
--            produces a MigrationStep as proof.
--   Phase 2: MigrationTicket_Execute verifies all steps are completed and
--            records the migration in the UpgradeRegistry + audit log.
--
--   For Canton 2.x native upgrades, Phase 1 uses Canton's built-in upgrade
--   mechanism. The MigrationStep still serves as the governance coordination
--   and audit trail layer.
template MigrationStep
  with
    operator : Party
    holder : Party              -- Asset owner whose contract was migrated
    sourceContractId : Text     -- Serialized source ContractId (archived)
    targetContractId : Text     -- Serialized target ContractId (created)
    sourceVersion : Text
    targetVersion : Text
    templateName : Text         -- e.g., "MintedMUSD", "CantonMUSD", "Vault"
    completed : Bool            -- Set to True after archive+create
    migratedAt : Time
  where
    signatory operator, holder

    ensure T.length sourceContractId > 0
        && T.length templateName > 0

-- ============================================================
--                     5. MIGRATION AUDIT LOG
-- ============================================================

-- | UpgradeMigrationLog - Immutable record of each migration.
-- Cannot be archived, provides permanent audit trail.
template UpgradeMigrationLog
  with
    operator : Party
    holder : Party
    sourceVersion : Text
    targetVersion : Text
    contractsMigrated : [Text]
    migratedAt : Time
    direction : MigrationDirection
    txHash : Text
  where
    signatory operator, holder

    -- No choices - immutable audit record
    -- This contract remains on the ledger permanently for compliance

-- ============================================================
--                     5. NOTES
-- ============================================================

-- Helper functions for creating migration tickets are implemented
-- in NegativeTests.daml using Daml Script for testing purposes.
-- In production, these would be triggered via the JSON API or
-- custom middleware.
