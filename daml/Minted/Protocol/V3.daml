-- | Minted.Protocol.V3 - Unified Canton Protocol Module
-- 
-- This module consolidates all Canton-side templates for the Minted mUSD Protocol.
-- Frontend expects specific choice names prefixed with template context.
--
-- Templates:
--   1. MintedMUSD          - Canton mUSD token with compliance + bridge-to-ETH
--   2. PriceOracle         - Provider-signed price feeds
--   3. LiquidityPool       - On-chain DEX for atomic leverage operations
--   4. Vault               - Collateralized debt position (CDP)
--   5. VaultManager        - Factory for creating vaults
--   6. LiquidationReceipt  - Immutable audit trail per liquidation
--   7. LiquidationOrder    - Keeper coordination for liquidations
--   8. CantonDirectMint    - Deposit stables → mint mUSD → auto bridge-out
--   9. CantonSMUSD         - Yield vault synced from Ethereum attestations
--  10. CooldownTicket      - Tracks stake time for withdrawal cooldown
--  11. BridgeService       - Coordinates all bridge operations
--  12. AttestationRequest  - Multi-party validation for bridge operations
--  13. BridgeOutRequest    - Canton → ETH transfer
--  14. BridgeInRequest     - ETH → Canton transfer
--
-- Choice naming convention: TemplateName_ChoiceName (e.g., MUSD_Transfer, CantonMint_Mint)

module Minted.Protocol.V3 where

import DA.Time
import DA.Set qualified as Set
import DA.Text qualified as T
import DA.Action (foldlA)
import DA.Optional (fromOptional)
import DA.Foldable hiding (elem, length, all, sum)

-- ============================================================
--                     TYPE DEFINITIONS
-- ============================================================

-- | 18-decimal precision for 1:1 mapping with Ethereum Wei
type Money = Numeric 18
type Bps = Int

-- ============================================================
--                     0. CANTON USDC (Deposit Asset)
-- ============================================================

-- | CantonUSDC - Represents USDC deposited on Canton side.
-- FIX H-01: Added to V3 for deposit verification in CantonMint_Mint
template CantonUSDC
  with
    issuer : Party
    owner : Party
    amount : Money
  where
    signatory issuer, owner
    ensure amount > 0.0

-- ============================================================
--                     0c. COLLATERAL DEPOSIT PROOF
-- ============================================================

-- | CollateralDepositProof - Verifies external collateral deposits for pool swaps.
-- FIX DC-03: Added to prevent Swap_Collateral_For_mUSD from creating mUSD without
-- actual backing. The relay or validator must create this proof after verifying
-- the on-chain deposit event (e.g., ERC20 transfer to bridge contract).
template CollateralDepositProof
  with
    verifier : Party             -- Validator that verified the deposit
    depositor : Party            -- User who made the deposit
    collateralSymbol : Text      -- e.g., "WBTC", "ETH"
    amount : Money               -- Amount deposited (in collateral units)
    ethTxHash : Text             -- Ethereum transaction hash for audit trail
    blockNumber : Int            -- Block number where deposit occurred
    blockTimestamp : Time        -- When deposit was confirmed
    used : Bool                  -- Whether this proof has been consumed
  where
    signatory verifier
    observer depositor

    ensure amount > 0.0
        && T.length ethTxHash == 66  -- "0x" + 64 hex chars
        && blockNumber > 0
        && not used

    -- | Consume this proof in a pool swap (one-time use)
    choice CollateralProof_Consume : ContractId CollateralDepositProof
      with
        consumer : Party
      controller verifier  -- Only verifier can mark as consumed
      do
        assertMsg "WRONG_DEPOSITOR" (consumer == depositor)
        assertMsg "ALREADY_USED" (not used)
        create this with used = True

-- ============================================================
--                     0b. MUSD SUPPLY SERVICE (Supply Cap Tracking)
-- ============================================================

-- | MUSDSupplyService - Global supply cap tracking for vault borrows.
-- FIX DL-C03: Ensures Vault.AdjustLeverage respects global supply limits.
-- FIX DL-C01: Added governance co-signer for institutional-grade access control.
--   - Large mints (above largeMintThreshold) require governance pre-approval
--   - Supply cap updates require governance approval
--   - Operator handles day-to-day operations within approved limits
template MUSDSupplyService
  with
    operator : Party              -- Day-to-day operator (e.g., relay service)
    governance : Party            -- FIX DL-C01: Governance multi-sig/DAO
    supplyCap : Money
    currentSupply : Money
    largeMintThreshold : Money    -- FIX DL-C01: Mints above this require approval
    pendingLargeMints : [(Party, Money)]  -- FIX DL-C01: Pre-approved large mints
    observers : [Party]
  where
    signatory operator, governance  -- FIX DL-C01: Both must sign
    observer observers

    ensure supplyCap >= currentSupply
        && largeMintThreshold > 0.0

    -- | Vault borrow mint: Used by Vault.AdjustLeverage for supply-cap-tracked minting
    -- FIX DL-C03: This enables vault leverage to respect global supply caps
    -- FIX DL-C01: Large mints require pre-approval from governance
    choice SupplyService_VaultMint : (ContractId MUSDSupplyService, ContractId MintedMUSD)
      with
        borrower : Party
        borrowAmount : Money
        agreementHash : Text
        agreementUri : Text
      controller operator
      do
        assertMsg "Borrow amount must be positive." (borrowAmount > 0.0)
        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + borrowAmount <= supplyCap)
        
        -- FIX DL-C01: Check if this is a large mint requiring pre-approval
        let isLargeMint = borrowAmount >= largeMintThreshold
        let hasApproval = Prelude.any (\(p, amt) -> p == borrower && amt >= borrowAmount) pendingLargeMints
        assertMsg "LARGE_MINT_REQUIRES_GOVERNANCE_APPROVAL" (not isLargeMint || hasApproval)
        
        musdCid <- create MintedMUSD with
          issuer = operator
          owner = borrower
          amount = borrowAmount
          blacklisted = False
          agreementHash = agreementHash
          agreementUri = agreementUri
          observers = []
        
        -- FIX H-02: Reduce approval by consumed amount (not remove entirely)
        -- This allows a $10M approval to be used across multiple mints
        let reduceApproval (p, amt) = 
              if p == borrower && amt >= borrowAmount
              then (p, amt - borrowAmount)  -- Reduce by consumed amount
              else (p, amt)
        let newPendingMints = if isLargeMint && hasApproval
              then filter (\(_, amt) -> amt >= largeMintThreshold) (map reduceApproval pendingLargeMints)
              else pendingLargeMints
        
        newService <- create this with
          currentSupply = currentSupply + borrowAmount
          pendingLargeMints = newPendingMints
        return (newService, musdCid)

    -- | FIX DL-C01: Governance pre-approves a large mint for a specific borrower
    -- This allows governance to authorize large mints in advance
    choice SupplyService_ApproveLargeMint : ContractId MUSDSupplyService
      with
        borrower : Party
        maxAmount : Money
      controller governance
      do
        assertMsg "AMOUNT_MUST_BE_POSITIVE" (maxAmount > 0.0)
        assertMsg "AMOUNT_BELOW_THRESHOLD" (maxAmount >= largeMintThreshold)
        create this with
          pendingLargeMints = (borrower, maxAmount) :: pendingLargeMints

    -- | FIX DL-C01: Revoke a pending large mint approval
    choice SupplyService_RevokeLargeMint : ContractId MUSDSupplyService
      with
        borrower : Party
      controller governance
      do
        create this with
          pendingLargeMints = filter (\(p, _) -> p /= borrower) pendingLargeMints

    -- | Update the supply cap (FIX DL-C01: requires governance, not just operator)
    choice SupplyService_UpdateCap : ContractId MUSDSupplyService
      with
        newCap : Money
      controller governance  -- FIX DL-C01: Only governance can update cap
      do
        assertMsg "CAP_BELOW_CURRENT_SUPPLY" (newCap >= currentSupply)
        create this with supplyCap = newCap

    -- | FIX DL-C01: Update the large mint threshold (governance only)
    choice SupplyService_UpdateThreshold : ContractId MUSDSupplyService
      with
        newThreshold : Money
      controller governance
      do
        assertMsg "THRESHOLD_MUST_BE_POSITIVE" (newThreshold > 0.0)
        create this with largeMintThreshold = newThreshold

-- ============================================================
--                     1. MINTED MUSD TOKEN
-- ============================================================

-- | MintedMUSD - Canton-side mUSD token with compliance and bridge capability.
-- The primary mUSD token on Canton Network.
template MintedMUSD
  with
    issuer : Party
    owner : Party
    amount : Money
    blacklisted : Bool            -- Compliance: frozen if true
    agreementHash : Text          -- SHA-256 of Master Participation Agreement
    agreementUri : Text           -- URI to legal terms
    observers : [Party]
  where
    signatory issuer, owner
    observer observers

    ensure amount > 0.0
      && T.length agreementHash == 64
      && T.length agreementUri > 0

    agreement
      "By holding or transferring this MintedMUSD token, the owner acknowledges "
      <> "they are bound by the Master Participation Agreement. "
      <> "Agreement hash: " <> agreementHash
      <> " | URI: " <> agreementUri

    -- | Transfer mUSD to another party (FIX C-2: Proposal pattern for proper authorization)
    -- Creates a TransferProposal that the newOwner must accept
    choice MUSD_Transfer : ContractId MUSDTransferProposal
      with
        newOwner : Party
      controller owner
      do
        assertMsg "TOKEN_BLACKLISTED" (not blacklisted)
        assertMsg "CANNOT_TRANSFER_TO_SELF" (newOwner /= owner)
        create MUSDTransferProposal with
          issuer
          sender = owner
          receiver = newOwner
          amount
          blacklisted
          agreementHash
          agreementUri
          observers

    -- | Split into two contracts
    -- FIX CRIT-09: Added compliance check — issuer must authorize split operations
    choice MUSD_Split : (ContractId MintedMUSD, ContractId MintedMUSD)
      with
        splitAmount : Money
        operator : Party
      controller issuer, owner
      do
        assertMsg "TOKEN_BLACKLISTED" (not blacklisted)
        assertMsg "Only issuer can split" (issuer == operator)
        assertMsg "SPLIT_AMOUNT_POSITIVE" (splitAmount > 0.0)
        assertMsg "SPLIT_AMOUNT_LESS_THAN_TOTAL" (splitAmount < amount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

    -- | Merge two contracts
    -- FIX CRIT-09: Added compliance check — issuer must authorize merge operations
    choice MUSD_Merge : ContractId MintedMUSD
      with
        otherCid : ContractId MintedMUSD
        operator : Party
      controller issuer, owner
      do
        assertMsg "TOKEN_BLACKLISTED" (not blacklisted)
        assertMsg "Only issuer can merge" (issuer == operator)
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        assertMsg "OTHER_BLACKLISTED" (not other.blacklisted)
        archive otherCid
        create this with amount = amount + other.amount

    -- | Bridge mUSD to Ethereum - burns Canton token and creates attestation request
    choice MUSD_BridgeToEthereum : ContractId AttestationRequest
      with
        ethAddress : Text         -- Target Ethereum address
        chainId : Int             -- Target chain (1 = mainnet)
        validators : [Party]      -- Validator group for attestation
        aggregator : Party        -- Attestation aggregator
        nonce : Int
        expiresAt : Time
      controller owner
      do
        assertMsg "TOKEN_BLACKLISTED" (not blacklisted)
        assertMsg "INVALID_ETH_ADDRESS" (T.length ethAddress == 42)
        
        -- Token is consumed (burned) on Canton
        create AttestationRequest with
          aggregator
          validatorGroup = validators
          payload = AttestationPayload with
            attestationId = "bridge-" <> show nonce
            globalCantonAssets = amount
            targetAddress = ethAddress
            amount = amount
            isMint = True  -- Mint on Ethereum side
            nonce
            chainId
            expiresAt
          collectedSignatures = Set.empty
          direction = CantonToEthereum

    -- | Set blacklist status (issuer only)
    choice MUSD_SetBlacklist : ContractId MintedMUSD
      with
        newStatus : Bool
      controller issuer
      do
        create this with blacklisted = newStatus

-- | FIX C-2: MUSDTransferProposal - Proposal pattern for proper authorization
-- Receiver must explicitly accept the transfer, providing proper signatory structure
template MUSDTransferProposal
  with
    issuer : Party
    sender : Party
    receiver : Party
    amount : Money
    blacklisted : Bool
    agreementHash : Text
    agreementUri : Text
    observers : [Party]
  where
    signatory issuer, sender
    observer receiver :: observers
    
    ensure amount > 0.0

    -- | Receiver accepts the transfer, becoming owner
    choice TransferProposal_Accept : ContractId MintedMUSD
      controller receiver
      do
        create MintedMUSD with
          issuer
          owner = receiver
          amount
          blacklisted
          agreementHash
          agreementUri
          observers

    -- | Sender cancels the proposal
    -- FIX C-12: Return tokens to sender instead of destroying them
    choice TransferProposal_Cancel : ContractId MintedMUSD
      controller sender
      do
        create MintedMUSD with
          issuer
          owner = sender
          amount
          blacklisted
          agreementHash
          agreementUri
          observers
    
    -- | Issuer can reject for compliance
    choice TransferProposal_Reject : ()
      controller issuer
      do
        -- Return tokens to sender
        create MintedMUSD with
          issuer
          owner = sender
          amount
          blacklisted
          agreementHash
          agreementUri
          observers
        return ()

-- ============================================================
--                     2. PRICE ORACLE
-- ============================================================

-- | PriceOracle - Provider-signed price feeds with keyed lookup.
template PriceOracle
  with
    provider : Party
    symbol : Text
    price : Money
    lastUpdated : Time
    observers : [Party]
  where
    signatory provider
    observer observers

    key (provider, symbol) : (Party, Text)
    maintainer key._1

    ensure price > 0.0

    -- FIX M-26: Explicit controller for nonconsuming choice
    -- FIX H-01: Added maxAge parameter for staleness check
    -- Any observer can query the price (read-only operation)
    nonconsuming choice Oracle_GetPrice : Money
      with
        requester : Party
        maxStaleness : RelTime  -- FIX H-01: Maximum acceptable age of price data
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester `elem` observers || requester == provider)
        -- FIX H-01: Check price staleness
        now <- getTime
        let age = subTime now lastUpdated
        assertMsg "PRICE_STALE" (age <= maxStaleness)
        return price

    choice Oracle_UpdatePrice : ContractId PriceOracle
      with
        newPrice : Money
      controller provider
      do
        assertMsg "PRICE_MUST_BE_POSITIVE" (newPrice > 0.0)
        now <- getTime
        create this with 
          price = newPrice
          lastUpdated = now

-- ============================================================
--                     3. LIQUIDITY POOL (DEX)
-- ============================================================

-- | LiquidityPool - On-chain DEX for atomic leverage operations.
-- FIX C-01: Swaps now require actual token contract IDs for verification
template LiquidityPool
  with
    operator : Party
    baseSymbol : Text           -- e.g., "mUSD"
    quoteSymbol : Text          -- e.g., "WBTC"
    baseReserve : Money
    quoteReserve : Money
    exchangeRate : Money        -- baseSymbol per quoteSymbol
  where
    signatory operator

    ensure baseReserve > 0.0 && quoteReserve > 0.0 && exchangeRate > 0.0

    -- | Swap mUSD for collateral (FIX C-01: requires actual token)
    choice Swap_mUSD_For_Collateral : (ContractId LiquidityPool, Money)
      with
        musdCid : ContractId MintedMUSD  -- Require actual token contract
        receiver : Party
      controller receiver
      do
        -- FIX C-01: Verify token ownership and consume it
        musd <- fetch musdCid
        assertMsg "NOT_OWNER" (musd.owner == receiver)
        assertMsg "TOKEN_BLACKLISTED" (not musd.blacklisted)
        let musdAmount = musd.amount
        let collateralOut = musdAmount / exchangeRate
        assertMsg "INSUFFICIENT_LIQUIDITY" (quoteReserve >= collateralOut)
        
        -- Archive (consume) the input token
        archive musdCid
        
        newPool <- create this with
          baseReserve = baseReserve + musdAmount
          quoteReserve = quoteReserve - collateralOut
        return (newPool, collateralOut)

    -- | Swap collateral for mUSD
    -- FIX DC-03: Requires CollateralDepositProof to prevent unbacked mUSD creation.
    -- The proof must be created by a validator after verifying the on-chain deposit.
    choice Swap_Collateral_For_mUSD : (ContractId LiquidityPool, Money, ContractId CollateralDepositProof)
      with
        depositProofCid : ContractId CollateralDepositProof  -- FIX DC-03: Proof of deposit
        receiver : Party
      controller operator
      do
        -- FIX DC-03: Fetch and validate the deposit proof
        proof <- fetch depositProofCid
        assertMsg "PROOF_ALREADY_USED" (not proof.used)
        assertMsg "WRONG_DEPOSITOR" (proof.depositor == receiver)
        assertMsg "WRONG_COLLATERAL" (proof.collateralSymbol == quoteSymbol)

        let collateralAmount = proof.amount
        let musdOut = collateralAmount * exchangeRate
        assertMsg "INSUFFICIENT_LIQUIDITY" (baseReserve >= musdOut)

        -- Consume the proof (mark as used)
        consumedProof <- exercise depositProofCid CollateralProof_Consume with consumer = receiver

        newPool <- create this with
          baseReserve = baseReserve - musdOut
          quoteReserve = quoteReserve + collateralAmount
        return (newPool, musdOut, consumedProof)

-- ============================================================
--                     4. VAULT (CDP)
-- ============================================================

-- | VaultConfig - Configuration for vault behavior
data VaultConfig = VaultConfig with
    liquidationThreshold : Money    -- e.g., 1.5 (150%)
    interestRateBps : Bps           -- Annual interest rate in basis points
    liquidationPenaltyBps : Bps     -- Penalty on seized collateral
    liquidationBonusBps : Bps       -- Keeper bonus from penalty
    closeFactorBps : Bps            -- Max debt per liquidation (e.g., 5000 = 50%)
    dustThreshold : Money           -- Force full liquidation below this
  deriving (Eq, Show)

-- | Vault - Collateralized debt position (CDP).
-- Supports atomic leverage: deposit → borrow → swap → add collateral in one tx.
template Vault
  with
    operator : Party
    owner : Party
    collateralSymbol : Text
    collateralAmount : Money
    principalDebt : Money
    accruedInterest : Money
    lastInterestUpdate : Time
    config : VaultConfig
    observers : [Party]
  where
    signatory operator, owner
    observer observers

    -- FIX C-03: Validate VaultConfig bounds to prevent malicious configuration
    ensure collateralAmount >= 0.0 
      && principalDebt >= 0.0
      && config.liquidationThreshold >= 1.0        -- At least 100% collateralization
      && config.liquidationThreshold <= 10.0       -- Max 1000% (reasonable upper bound)
      && config.closeFactorBps >= 0
      && config.closeFactorBps <= 10000            -- Max 100% per liquidation
      && config.liquidationPenaltyBps >= 0
      && config.liquidationPenaltyBps <= 2000      -- Max 20% penalty
      && config.liquidationBonusBps >= 0
      && config.liquidationBonusBps <= config.liquidationPenaltyBps  -- Bonus <= penalty
      && config.dustThreshold >= 0.0

    -- | Calculate current total debt including accrued interest
    -- FIX M-27: Explicit controller for nonconsuming choice
    nonconsuming choice Vault_GetTotalDebt : Money
      with
        requester : Party
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester == owner || requester == operator)
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastInterestUpdate)
        let secondsElapsed = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric config.interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        return (principalDebt + accruedInterest + newInterest)

    -- | Get current interest rate (for UI display)
    nonconsuming choice Vault_GetInterestRate : Bps
      with
        requester : Party
      controller requester
      do
        return config.interestRateBps

    -- | Sync interest rate from Ethereum (via attestation)
    -- Allows the vault to use dynamic utilization-based rates
    choice Vault_SyncInterestRate : ContractId Vault
      with
        newRateBps : Bps
        ethBlockNumber : Int     -- For audit trail
      controller operator
      do
        assertMsg "RATE_MUST_BE_NON_NEGATIVE" (newRateBps >= 0)
        assertMsg "RATE_TOO_HIGH" (newRateBps <= 10000)  -- Max 100% APR
        
        -- Accrue interest at old rate before updating
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastInterestUpdate)
        let secondsElapsed = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric config.interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        
        create this with
          config = config with interestRateBps = newRateBps
          accruedInterest = accruedInterest + newInterest
          lastInterestUpdate = now

    -- | FIX H-03: Update vault config (operator-controlled, consuming choice)
    -- Must live on Vault so that Vault's signatories {operator, owner} are in
    -- the authorization context when the contract is archived and recreated.
    choice Vault_UpdateConfig : ContractId Vault
      with
        newConfig : VaultConfig
      controller operator
      do
        create this with config = newConfig

    -- | AdjustLeverage - Atomic leverage loop
    -- deposit collateral + borrow mUSD + swap via DEX in one transaction
    -- FIX DL-C03: Now requires MUSDSupplyService CID for supply-cap-tracked minting
    choice AdjustLeverage : (ContractId Vault, ContractId MUSDSupplyService)
      with
        depositAmount : Money
        borrowAmount : Money
        poolCid : ContractId LiquidityPool
        oracleCid : ContractId PriceOracle
        supplyServiceCid : ContractId MUSDSupplyService  -- FIX DL-C03: Supply cap tracking
        agreementHash : Text        -- Required for MintedMUSD
        agreementUri : Text         -- Required for MintedMUSD
        loops : Int
      controller owner
      do
        assertMsg "MAX_LOOPS_10" (loops <= 10 && loops >= 0)
        
        -- Add deposited collateral
        let newCollateral = collateralAmount + depositAmount
        
        -- Get oracle price (FIX H-01: with staleness check - 1 hour max)
        price <- exercise oracleCid Oracle_GetPrice with 
          requester = owner
          maxStaleness = hours 1
        
        -- Recursive leverage loop (FIX C-01: mint via SupplyService for supply tracking)
        let loopFn (col, debt, pCid, svcCid) _ = do
              let colValue = col * price
              let maxDebt = colValue / config.liquidationThreshold
              let borrowable = maxDebt - debt
              if borrowable < 1.0 
                then return (col, debt, pCid, svcCid)
                else do
                  -- FIX DL-C03: Mint via MUSDSupplyService for supply cap enforcement
                  (newSvcCid, musdCid) <- exercise svcCid SupplyService_VaultMint with
                    borrower = owner
                    borrowAmount = borrowable
                    agreementHash = agreementHash
                    agreementUri = agreementUri
                  -- Swap actual mUSD token for collateral
                  (newPoolCid, colOut) <- exercise pCid Swap_mUSD_For_Collateral with
                    musdCid = musdCid
                    receiver = owner
                  return (col + colOut, debt + borrowable, newPoolCid, newSvcCid)
        
        (finalCol, finalDebt, _, finalSvcCid) <- foldlA loopFn (newCollateral, principalDebt + borrowAmount, poolCid, supplyServiceCid) [1..loops]
        
        -- Health check
        let finalValue = finalCol * price
        assertMsg "UNHEALTHY_AFTER_ADJUST" (finalValue >= finalDebt * config.liquidationThreshold)
        
        now <- getTime
        vaultCid <- create this with
          collateralAmount = finalCol
          principalDebt = finalDebt
          lastInterestUpdate = now
        
        return (vaultCid, finalSvcCid)

    -- | Repay debt
    -- FIX CRIT-10: Requires actual mUSD token to prevent phantom repayment
    choice Vault_Repay : ContractId Vault
      with
        repayAmount : Money
        musdCid : ContractId MintedMUSD
      controller owner
      do
        -- FIX CRIT-10: Fetch, verify, and consume the mUSD payment token
        musd <- fetch musdCid
        assertMsg "REPAY_MUSD_OWNER_MISMATCH" (musd.owner == owner)
        assertMsg "REPAY_MUSD_ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "REPAY_MUSD_INSUFFICIENT" (musd.amount >= repayAmount)
        -- Archive (consume) the mUSD token as payment
        archive musdCid
        -- Return change if mUSD amount exceeds repayAmount
        when (musd.amount > repayAmount) $ do
          _ <- create MintedMUSD with
            issuer = musd.issuer
            owner = owner
            amount = musd.amount - repayAmount
            blacklisted = musd.blacklisted
            agreementHash = musd.agreementHash
            agreementUri = musd.agreementUri
            observers = musd.observers
          return ()

        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastInterestUpdate)
        let secondsElapsed = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric config.interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        let totalInterest = accruedInterest + newInterest
        
        -- Pay interest first, then principal
        let (remainingRepay, newAccrued) = 
              if repayAmount >= totalInterest
                then (repayAmount - totalInterest, 0.0)
                else (0.0, totalInterest - repayAmount)
        let newPrincipal = if remainingRepay > principalDebt 
                           then 0.0 
                           else principalDebt - remainingRepay
        
        create this with
          principalDebt = newPrincipal
          accruedInterest = newAccrued
          lastInterestUpdate = now

    -- | Withdraw collateral (must maintain health)
    choice Vault_WithdrawCollateral : ContractId Vault
      with
        withdrawAmount : Money
        oracleCid : ContractId PriceOracle
      controller owner
      do
        assertMsg "INSUFFICIENT_COLLATERAL" (collateralAmount >= withdrawAmount)
        let newCollateral = collateralAmount - withdrawAmount
        
        -- Health check (FIX H-01: with staleness check)
        price <- exercise oracleCid Oracle_GetPrice with 
          requester = owner
          maxStaleness = hours 1
        let newValue = newCollateral * price
        let totalDebt = principalDebt + accruedInterest
        assertMsg "UNHEALTHY_AFTER_WITHDRAW" (totalDebt == 0.0 || newValue >= totalDebt * config.liquidationThreshold)
        
        create this with collateralAmount = newCollateral

    -- | Liquidate - Called by keepers when vault is undercollateralized
    choice Liquidate : (ContractId Vault, ContractId LiquidationReceipt)
      with
        liquidator : Party
        repayAmount : Money
        oracleCid : ContractId PriceOracle
      controller liquidator
      do
        -- FIX HIGH-17: Prevent vault owner from self-liquidating for bonus extraction
        assertMsg "CANNOT_SELF_LIQUIDATE" (liquidator /= owner)

        -- Calculate current debt with interest
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now lastInterestUpdate)
        let secondsElapsed = intToNumeric (elapsed / 1000000)
        let yearSeconds = 31536000.0 : Money
        let newInterest = principalDebt * intToNumeric config.interestRateBps * secondsElapsed / (10000.0 * yearSeconds)
        let totalDebt = principalDebt + accruedInterest + newInterest
        
        -- Check if vault is liquidatable (FIX H-01: with staleness check)
        price <- exercise oracleCid Oracle_GetPrice with 
          requester = liquidator
          maxStaleness = hours 1
        let colValue = collateralAmount * price
        let healthBefore = colValue / totalDebt
        assertMsg "VAULT_HEALTHY" (healthBefore < config.liquidationThreshold)
        
        -- Close factor limits max repayment
        let maxRepay = totalDebt * intToNumeric config.closeFactorBps / 10000.0
        let actualRepay = if totalDebt < config.dustThreshold 
                          then totalDebt  -- Full liquidation for dust
                          else min repayAmount maxRepay
        
        -- Calculate collateral seized with penalty
        let seizeValue = actualRepay * (10000.0 + intToNumeric config.liquidationPenaltyBps) / 10000.0
        let seizeAmount = seizeValue / price
        let actualSeize = min seizeAmount collateralAmount
        
        -- Calculate keeper bonus and protocol fee
        let penaltyValue = actualSeize * price - actualRepay
        let keeperBonus = penaltyValue * intToNumeric config.liquidationBonusBps / intToNumeric config.liquidationPenaltyBps
        let protocolFee = penaltyValue - keeperBonus
        
        -- Update vault
        let newCollateral = collateralAmount - actualSeize
        let newDebt = totalDebt - actualRepay
        let healthAfter = if newDebt == 0.0 then 999.0 else (newCollateral * price) / newDebt
        
        newVault <- create this with
          collateralAmount = newCollateral
          principalDebt = newDebt
          accruedInterest = 0.0
          lastInterestUpdate = now
        
        -- Create immutable receipt (FIX H-02: operator signs the receipt)
        receipt <- create LiquidationReceipt with
          operator  -- FIX H-02: Use vault's operator as receipt signer
          vaultOwner = owner
          liquidator
          debtRepaid = actualRepay
          collateralSeized = actualSeize
          penalty = penaltyValue
          keeperBonus
          protocolFee
          healthBefore
          healthAfter
          isFullLiquidation = newDebt == 0.0
          timestamp = now
        
        return (newVault, receipt)

-- ============================================================
--                     5. VAULT MANAGER
-- ============================================================

-- | VaultManager - Factory for creating vaults with default config.
template VaultManager
  with
    operator : Party
    defaultConfig : VaultConfig
    allowedCollaterals : [Text]   -- Whitelisted collateral symbols
    observers : [Party]
  where
    signatory operator
    observer observers

    -- | Create a new vault for a user
    choice OpenVault : ContractId Vault
      with
        owner : Party
        collateralSymbol : Text
      controller owner
      do
        assertMsg "COLLATERAL_NOT_ALLOWED" (collateralSymbol `elem` allowedCollaterals)
        now <- getTime
        create Vault with
          operator
          owner
          collateralSymbol
          collateralAmount = 0.0
          principalDebt = 0.0
          accruedInterest = 0.0
          lastInterestUpdate = now
          config = defaultConfig
          observers = [operator]

    -- | Update default config
    choice UpdateDefaultConfig : ContractId VaultManager
      with
        newConfig : VaultConfig
      controller operator
      do create this with defaultConfig = newConfig

    -- | Update vault config for a specific vault
    -- FIX H-03: Exercise Vault_UpdateConfig on the Vault contract directly.
    -- This brings Vault's signatories {operator, owner} into the authorization
    -- context, allowing the consuming choice to archive and recreate the Vault.
    -- Previously, manual archive from VaultManager failed because only {operator}
    -- was in scope but Vault requires {operator, owner} for archive.
    choice UpdateVaultConfig : ContractId Vault
      with
        vaultCid : ContractId Vault
        newConfig : VaultConfig
      controller operator
      do
        exercise vaultCid Vault_UpdateConfig with newConfig

-- ============================================================
--                     6. LIQUIDATION RECEIPT
-- ============================================================

-- | LiquidationReceipt - Immutable audit trail per liquidation.
-- FIX H-02: Changed to operator-signed pattern to make receipt creatable
-- The operator (protocol) signs the receipt, with both vaultOwner and liquidator as observers
-- This allows the receipt to be created within the Vault.Liquidate choice context
template LiquidationReceipt
  with
    operator : Party          -- FIX H-02: Protocol operator signs
    vaultOwner : Party
    liquidator : Party
    debtRepaid : Money
    collateralSeized : Money
    penalty : Money
    keeperBonus : Money
    protocolFee : Money
    healthBefore : Money
    healthAfter : Money
    isFullLiquidation : Bool
    timestamp : Time
  where
    signatory operator  -- FIX H-02: Only operator signs (can create in Vault context)
    observer vaultOwner, liquidator  -- Both parties can see the receipt

-- ============================================================
--                     7. LIQUIDATION ORDER
-- ============================================================

-- | LiquidationOrder status
data OrderStatus = Pending | Claimed | Executed | Cancelled
  deriving (Eq, Show)

-- | LiquidationOrder - Keeper coordination for liquidations.
template LiquidationOrder
  with
    operator : Party
    vaultCid : ContractId Vault
    vaultOwner : Party
    estimatedDebt : Money
    estimatedSeize : Money
    status : OrderStatus
    claimedBy : Optional Party
    createdAt : Time
    observers : [Party]
  where
    signatory operator
    observer observers

    -- | Keeper claims the order
    choice ClaimOrder : ContractId LiquidationOrder
      with
        keeper : Party
      controller keeper
      do
        assertMsg "ORDER_NOT_PENDING" (status == Pending)
        create this with 
          status = Claimed
          claimedBy = Some keeper

    -- | Complete the order after successful liquidation
    choice CompleteOrder : ContractId LiquidationOrder
      with
        keeper : Party
      controller keeper
      do
        assertMsg "ORDER_NOT_CLAIMED" (status == Claimed)
        assertMsg "NOT_CLAIMANT" (claimedBy == Some keeper)
        create this with status = Executed

    -- | Cancel the order
    choice CancelOrder : ContractId LiquidationOrder
      controller operator
      do
        create this with status = Cancelled

-- ============================================================
--                     8. CANTON DIRECT MINT
-- ============================================================

-- | MintServiceConfig - Configuration for mint/redeem service
data MintServiceConfig = MintServiceConfig with
    mintFeeBps : Bps
    redeemFeeBps : Bps
    minAmount : Money
    maxAmount : Money
    paused : Bool
  deriving (Eq, Show)

-- | CantonDirectMint - Deposit stables → mint mUSD → auto bridge-out to ETH Treasury.
template CantonDirectMint
  with
    operator : Party
    config : MintServiceConfig
    supplyCap : Money
    currentSupply : Money
    accumulatedFees : Money
    targetChainId : Int
    targetTreasury : Text
    nextNonce : Int
    dailyMintLimit : Money
    dailyMinted : Money
    lastRateLimitReset : Time
    mpaHash : Text
    mpaUri : Text
    validators : [Party]
    observers : [Party]
  where
    signatory operator
    observer observers

    -- | Mint mUSD by depositing stables
    -- FIX H-01: Now requires actual CantonUSDC token to verify deposit
    choice CantonMint_Mint : (ContractId CantonDirectMint, ContractId MintedMUSD, ContractId BridgeOutRequest)
      with
        user : Party
        depositCid : ContractId CantonUSDC  -- FIX H-01: Require actual token
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not config.paused)
        
        -- FIX H-01: Fetch and verify the deposit token
        deposit <- fetch depositCid
        assertMsg "DEPOSIT_OWNER_MISMATCH" (deposit.owner == user)
        let depositAmount = deposit.amount
        
        assertMsg "BELOW_MIN_AMOUNT" (depositAmount >= config.minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (depositAmount <= config.maxAmount)
        
        -- FIX H-01: Archive (consume) the deposit token
        archive depositCid
        
        let feeAmount = depositAmount * intToNumeric config.mintFeeBps / 10000.0
        let netAmount = depositAmount - feeAmount
        
        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + netAmount <= supplyCap)
        
        -- Rate limit check
        now <- getTime
        let windowElapsed = subTime now lastRateLimitReset
        let oneDayRel = hours 24
        let (resetMinted, resetTime) =
              if windowElapsed >= oneDayRel
              then (0.0, now)
              else (dailyMinted, lastRateLimitReset)
        assertMsg "DAILY_MINT_LIMIT" (resetMinted + netAmount <= dailyMintLimit)
        
        -- Mint mUSD to user
        musdCid <- create MintedMUSD with
          issuer = operator
          owner = user
          amount = netAmount
          blacklisted = False
          agreementHash = mpaHash
          agreementUri = mpaUri
          observers = []
        
        -- Create bridge-out request to pipe backing to Ethereum
        bridgeReq <- create BridgeOutRequest with
          operator
          user
          amount = depositAmount
          targetChainId
          targetTreasury
          nonce = nextNonce
          createdAt = now
          status = "pending"
        
        -- Update service state
        newService <- create this with
          currentSupply = currentSupply + netAmount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
          dailyMinted = resetMinted + netAmount
          lastRateLimitReset = resetTime
        
        return (newService, musdCid, bridgeReq)

    -- | Redeem mUSD for stables (creates bridge-in request from Ethereum)
    choice CantonMint_Redeem : (ContractId CantonDirectMint, ContractId BridgeInRequest)
      with
        user : Party
        musdCid : ContractId MintedMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not config.paused)
        
        musd <- fetch musdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_AMOUNT" (musd.amount >= config.minAmount)
        assertMsg "ABOVE_MAX_AMOUNT" (musd.amount <= config.maxAmount)
        
        let feeAmount = musd.amount * intToNumeric config.redeemFeeBps / 10000.0
        let netAmount = musd.amount - feeAmount
        
        -- Burn mUSD
        archive musdCid
        
        -- Create bridge-in request (pull stables from Ethereum)
        now <- getTime
        bridgeIn <- create BridgeInRequest with
          operator
          user
          amount = netAmount
          feeAmount
          sourceChainId = 1
          nonce = nextNonce
          createdAt = now
          status = "pending"
        
        newService <- create this with
          currentSupply = currentSupply - musd.amount
          accumulatedFees = accumulatedFees + feeAmount
          nextNonce = nextNonce + 1
        
        return (newService, bridgeIn)

    -- | Update service config
    choice CantonMint_UpdateConfig : ContractId CantonDirectMint
      with
        newConfig : MintServiceConfig
      controller operator
      do create this with config = newConfig

-- ============================================================
--                     9. CANTON SMUSD (Yield Vault)
-- ============================================================

-- | SmUSDConfig - Configuration for staking service
data SmUSDConfig = SmUSDConfig with
    cooldownSeconds : Int
    maxTotalDeposits : Money
  deriving (Eq, Show)

-- | CantonSMUSD - Yield vault synced from Ethereum attestations.
-- Share price = totalAssets / totalShares
template CantonSMUSD
  with
    operator : Party
    governance : Party          -- FIX H-D01: Governance co-signer for yield sync
    totalShares : Money
    totalAssets : Money
    lastYieldEpoch : Int
    config : SmUSDConfig
    mpaHash : Text
    mpaUri : Text
    observers : [Party]
  where
    signatory operator, governance  -- FIX H-D01: Both must sign
    observer observers

    ensure totalShares >= 0.0 && totalAssets >= 0.0

    -- | Get current share price
    -- FIX M-27: Explicit controller for nonconsuming choice
    -- FIX H-02: Uses virtual shares to prevent dilution attack
    nonconsuming choice SMUSD_GetSharePrice : Money
      with
        requester : Party
      controller requester
      do
        assertMsg "NOT_AUTHORIZED" (requester == operator || requester `elem` observers)
        -- FIX H-02: Virtual offset prevents dilution attack (similar to ERC-4626 fix)
        let virtualShares = totalShares + 1000.0
        let virtualAssets = totalAssets + 1000.0
        return (virtualAssets / virtualShares)

    -- | Deposit mUSD → receive smUSD shares
    choice SMUSD_Deposit : (ContractId CantonSMUSD, ContractId CooldownTicket)
      with
        user : Party
        musdCid : ContractId MintedMUSD
      controller user
      do
        musd <- fetch musdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == user)
        assertMsg "MAX_DEPOSITS_EXCEEDED" (totalAssets + musd.amount <= config.maxTotalDeposits)
        
        -- FIX H-02: Calculate shares using virtual offset to prevent dilution attack
        let virtualShares = totalShares + 1000.0
        let virtualAssets = totalAssets + 1000.0
        let sharePrice = virtualAssets / virtualShares
        let newShares = musd.amount / sharePrice
        
        -- Burn mUSD
        archive musdCid
        
        -- Issue cooldown ticket (tracks stake time)
        now <- getTime
        ticket <- create CooldownTicket with
          operator
          owner = user
          shares = newShares
          entrySharePrice = sharePrice
          stakedAt = now
          cooldownSeconds = config.cooldownSeconds
        
        -- Update pool
        newService <- create this with
          totalShares = totalShares + newShares
          totalAssets = totalAssets + musd.amount
        
        return (newService, ticket)

    -- | Withdraw smUSD shares → mUSD (after cooldown)
    choice SMUSD_Withdraw : (ContractId CantonSMUSD, ContractId MintedMUSD)
      with
        user : Party
        ticketCid : ContractId CooldownTicket
      controller user
      do
        ticket <- fetch ticketCid
        assertMsg "OWNER_MISMATCH" (ticket.owner == user)
        
        -- Check cooldown
        now <- getTime
        let elapsed = convertRelTimeToMicroseconds (subTime now ticket.stakedAt)
        let cooldownMicros = ticket.cooldownSeconds * 1000000
        assertMsg "COOLDOWN_NOT_ELAPSED" (elapsed >= cooldownMicros)
        
        -- Calculate mUSD value at current share price
        let sharePrice = if totalShares == 0.0 then 1.0 else totalAssets / totalShares
        let musdAmount = ticket.shares * sharePrice
        
        assertMsg "INSUFFICIENT_POOL_ASSETS" (totalAssets >= musdAmount)
        
        -- Burn ticket
        archive ticketCid
        
        -- Mint mUSD to user (includes yield)
        musdCid <- create MintedMUSD with
          issuer = operator
          owner = user
          amount = musdAmount
          blacklisted = False
          agreementHash = mpaHash
          agreementUri = mpaUri
          observers = []
        
        -- Update pool
        newService <- create this with
          totalShares = totalShares - ticket.shares
          totalAssets = totalAssets - musdAmount
        
        return (newService, musdCid)

    -- | Sync yield from Ethereum via attestation
    -- FIX H-D01: Requires governance co-approval to prevent unilateral yield inflation
    choice SMUSD_SyncYield : ContractId CantonSMUSD
      with
        yieldAccrued : Money
        epochNumber : Int
      controller operator, governance  -- FIX H-D01: Both operator and governance must approve
      do
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastYieldEpoch)
        assertMsg "YIELD_MUST_BE_NONNEG" (yieldAccrued >= 0.0)
        create this with
          totalAssets = totalAssets + yieldAccrued
          lastYieldEpoch = epochNumber

    -- | Update config
    -- FIX H-D01: Governance co-controls config updates
    choice SMUSD_UpdateConfig : ContractId CantonSMUSD
      with
        newConfig : SmUSDConfig
      controller operator, governance
      do create this with config = newConfig

-- ============================================================
--                     10. COOLDOWN TICKET
-- ============================================================

-- | CooldownTicket - Tracks stake time for withdrawal cooldown.
template CooldownTicket
  with
    operator : Party
    owner : Party
    shares : Money
    entrySharePrice : Money
    stakedAt : Time
    cooldownSeconds : Int
  where
    signatory operator, owner

    ensure shares > 0.0

    -- | Transfer ticket to another party (FIX C-3: Proposal pattern)
    -- Creates a TicketTransferProposal that the newOwner must accept
    choice Ticket_Transfer : ContractId TicketTransferProposal
      with
        newOwner : Party
      controller owner
      do
        assertMsg "CANNOT_TRANSFER_TO_SELF" (newOwner /= owner)
        create TicketTransferProposal with
          operator
          sender = owner
          receiver = newOwner
          shares
          entrySharePrice
          stakedAt
          cooldownSeconds

    -- | Split ticket
    choice Ticket_Split : (ContractId CooldownTicket, ContractId CooldownTicket)
      with
        splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_SHARES_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_SHARES_LESS_THAN_TOTAL" (splitShares < shares)
        c1 <- create this with shares = splitShares
        c2 <- create this with shares = shares - splitShares
        return (c1, c2)

-- | FIX C-3: TicketTransferProposal - Proposal pattern for proper authorization
-- Receiver must explicitly accept the ticket transfer
template TicketTransferProposal
  with
    operator : Party
    sender : Party
    receiver : Party
    shares : Money
    entrySharePrice : Money
    stakedAt : Time
    cooldownSeconds : Int
  where
    signatory operator, sender
    observer receiver

    ensure shares > 0.0

    -- | Receiver accepts the transfer
    choice TicketTransfer_Accept : ContractId CooldownTicket
      controller receiver
      do
        create CooldownTicket with
          operator
          owner = receiver
          shares
          entrySharePrice
          stakedAt
          cooldownSeconds

    -- | Sender cancels the proposal
    choice TicketTransfer_Cancel : ContractId CooldownTicket
      controller sender
      do
        -- Return ticket to sender
        create CooldownTicket with
          operator
          owner = sender
          shares
          entrySharePrice
          stakedAt
          cooldownSeconds

-- ============================================================
--                     11. BRIDGE SERVICE
-- ============================================================

-- | BridgeService - Coordinates all bridge operations.
-- FIX H-04: Added ensure clause for proper bounds validation
template BridgeService
  with
    operator : Party
    validators : [Party]
    requiredSignatures : Int
    totalBridgedIn : Money
    totalBridgedOut : Money
    lastNonce : Int
    paused : Bool
    observers : [Party]
  where
    signatory operator
    observer validators, observers

    -- FIX H-04: Ensure clause validates requiredSignatures bounds
    ensure requiredSignatures > 0
      && requiredSignatures <= length validators
      && length validators > 0
      && totalBridgedIn >= 0.0
      && totalBridgedOut >= 0.0
      && lastNonce >= 0

    -- | Receive mUSD from Ethereum (mints on Canton after attestation validation)
    -- FIX DL-C02: Added validator membership verification
    choice Bridge_ReceiveFromEthereum : (ContractId BridgeService, ContractId MintedMUSD)
      with
        attestationCid : ContractId AttestationRequest
        recipient : Party
        amount : Money
        mpaHash : Text
        mpaUri : Text
      controller operator
      do
        assertMsg "BRIDGE_PAUSED" (not paused)
        
        attestation <- fetch attestationCid
        assertMsg "WRONG_DIRECTION" (attestation.direction == EthereumToCanton)
        assertMsg "AMOUNT_MISMATCH" (attestation.payload.amount == amount)
        
        -- FIX DL-C02: Verify signers are authorized validators
        let sigParties = Set.toList attestation.collectedSignatures
        assertMsg "UNAUTHORIZED_SIGNERS" (all (`elem` validators) sigParties)
        
        -- Verify sufficient signatures
        let sigCount = Set.size attestation.collectedSignatures
        assertMsg "INSUFFICIENT_SIGNATURES" (sigCount >= requiredSignatures)
        
        -- Archive attestation (consumed)
        archive attestationCid
        
        -- Mint mUSD on Canton
        musdCid <- create MintedMUSD with
          issuer = operator
          owner = recipient
          amount
          blacklisted = False
          agreementHash = mpaHash
          agreementUri = mpaUri
          observers = []
        
        newService <- create this with
          totalBridgedIn = totalBridgedIn + amount
          lastNonce = attestation.payload.nonce
        
        return (newService, musdCid)

    -- | Assign nonce to a bridge-out request
    choice Bridge_AssignNonce : (ContractId BridgeService, Int)
      controller operator
      do
        let newNonce = lastNonce + 1
        newService <- create this with lastNonce = newNonce
        return (newService, newNonce)

    -- | Complete a bridge-out after Ethereum confirmation
    choice Bridge_CompleteBridgeOut : ContractId BridgeService
      with
        amount : Money
      controller operator
      do
        create this with totalBridgedOut = totalBridgedOut + amount

    -- | Pause bridge
    choice Bridge_Pause : ContractId BridgeService
      controller operator
      do create this with paused = True

    -- | Unpause bridge
    choice Bridge_Unpause : ContractId BridgeService
      controller operator
      do create this with paused = False

    -- | Update validators
    choice Bridge_UpdateValidators : ContractId BridgeService
      with
        newValidators : [Party]
        newRequiredSigs : Int
      controller operator
      do
        assertMsg "INVALID_REQUIRED_SIGS" (newRequiredSigs > 0 && newRequiredSigs <= length newValidators)
        create this with 
          validators = newValidators
          requiredSignatures = newRequiredSigs

-- ============================================================
--                     12. ATTESTATION REQUEST
-- ============================================================

-- | Bridge direction
data BridgeDirection = CantonToEthereum | EthereumToCanton
  deriving (Eq, Show)

-- | AttestationPayload - Data being attested
data AttestationPayload = AttestationPayload with
    attestationId : Text
    globalCantonAssets : Money
    targetAddress : Text
    amount : Money
    isMint : Bool
    nonce : Int
    chainId : Int
    expiresAt : Time
  deriving (Eq, Show)

-- | AttestationRequest - Multi-party validation for bridge operations.
template AttestationRequest
  with
    aggregator : Party
    validatorGroup : [Party]
    payload : AttestationPayload
    collectedSignatures : Set.Set Party
    direction : BridgeDirection
  where
    signatory aggregator
    observer validatorGroup

    ensure length validatorGroup > 0 && length validatorGroup <= 100

    -- | Validator signs the attestation
    choice Attestation_Sign : ContractId AttestationRequest
      with
        validator : Party
        ecdsaSignature : Text
      controller validator
      do
        assertMsg "VALIDATOR_ALREADY_SIGNED" (not (Set.member validator collectedSignatures))
        assertMsg "UNAUTHORIZED_VALIDATOR" (validator `elem` validatorGroup)
        assertMsg "INVALID_SIGNATURE_FORMAT" (T.length ecdsaSignature >= 130)
        
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)
        
        create this with collectedSignatures = Set.insert validator collectedSignatures

    -- | Complete attestation (called by aggregator after sufficient signatures)
    -- FIX DC-06: Supermajority quorum (67%) for Byzantine fault tolerance
    -- Previously used 50%+1, which is insufficient for BFT guarantees
    choice Attestation_Complete : ()
      controller aggregator
      do
        -- FIX DC-06: Supermajority threshold = ceil(2/3 * n)
        -- For 5 validators: ceil(3.33) = 4 required (80%)
        -- For 7 validators: ceil(4.67) = 5 required (71%)
        let n = length validatorGroup
        let requiredSignatures = (n * 2 + 2) / 3  -- ceil(2n/3) using integer arithmetic
        let sigCount = Set.size collectedSignatures
        assertMsg "INSUFFICIENT_SIGNATURES" (sigCount >= requiredSignatures)
        
        now <- getTime
        assertMsg "ATTESTATION_EXPIRED" (now < payload.expiresAt)
        
        return ()

    -- | Cancel attestation
    choice Attestation_Cancel : ()
      controller aggregator
      do return ()

-- ============================================================
--                     13. BRIDGE OUT REQUEST
-- ============================================================

-- | BridgeOutRequest - Canton → ETH transfer.
template BridgeOutRequest
  with
    operator : Party
    user : Party
    amount : Money
    targetChainId : Int
    targetTreasury : Text
    nonce : Int
    createdAt : Time
    status : Text
  where
    signatory operator
    observer user

    -- | User sets target ETH address
    choice BridgeOut_SetTarget : ContractId BridgeOutRequest
      with
        targetAddress : Text
      controller user
      do
        assertMsg "INVALID_ETH_ADDRESS" (T.length targetAddress == 42)
        create this with targetTreasury = targetAddress

    -- | Operator assigns nonce
    choice BridgeOut_AssignNonce : ContractId BridgeOutRequest
      with
        newNonce : Int
      controller operator
      do create this with nonce = newNonce

    -- | Complete after Ethereum confirmation
    choice BridgeOut_Complete : ContractId BridgeOutRequest
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "bridged"

    -- | Cancel request
    choice BridgeOut_Cancel : ContractId BridgeOutRequest
      controller operator
      do create this with status = "cancelled"

-- ============================================================
--                     14. BRIDGE IN REQUEST
-- ============================================================

-- | BridgeInRequest - ETH → Canton transfer.
template BridgeInRequest
  with
    operator : Party
    user : Party
    amount : Money
    feeAmount : Money
    sourceChainId : Int
    nonce : Int
    createdAt : Time
    status : Text
  where
    signatory operator
    observer user

    -- | Complete by minting stables to user
    choice BridgeIn_Complete : ContractId BridgeInRequest
      controller operator
      do
        assertMsg "MUST_BE_PENDING" (status == "pending")
        create this with status = "completed"

    -- | Cancel request
    choice BridgeIn_Cancel : ContractId BridgeInRequest
      controller operator
      do create this with status = "cancelled"

-- ============================================================
--                     HELPER FUNCTIONS
-- ============================================================

-- Note: intToNumeric is provided by Prelude, no need to redefine
