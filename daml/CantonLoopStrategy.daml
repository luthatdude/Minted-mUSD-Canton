-- | CantonLoopStrategy
-- Canton-native Loop Orchestrator — automated multi-step DeFi strategies
--
-- Architecture:
--   Orchestrates atomic multi-step workflows across Canton DAML modules:
--     1. CantonMaxiLoop: USDC → Mint mUSD → Stake sMUSD → Borrow mUSD → Deposit Canton → Loop
--     2. SMUSDMaxiLoop:  USDC → Mint mUSD → Stake sMUSD → Borrow mUSD → Re-stake → Loop
--
--   Each loop increases effective yield by leveraging sMUSD's high LTV (90%).
--   Maximum 5 loops to prevent excessive leverage/gas.
--
-- Safety Features:
--   - Max loop count (configurable, default 5)
--   - Min health factor check before each loop (1.15 = 115%)
--   - Stale price protection via CantonPriceFeed
--   - Operator must approve execution
--   - User-initiated unwind with full position close
--
-- Revenue Model:
--   Each loop compounds: deposit → borrow at 90% LTV → re-stake
--   Net APY = stakingRate × leverage − borrowRate × (leverage − 1)
--   Example: 6% stake, 4% borrow, 5 loops at 90% LTV:
--     leverage ≈ 5.13x → net ≈ 6% × 5.13 − 4% × 4.13 = 14.26%

module CantonLoopStrategy where

import DA.Time
import DA.Optional (fromOptional)
import DA.Foldable (forA_)
import CantonDirectMint (CantonUSDC(..), CantonMUSD(..), CantonMUSD_Burn(..), CantonMUSD_Split(..), Money, Bps, BurnRateLimiter(..), BurnLimit_RecordBurn(..))
import CantonSMUSD (CantonSMUSD(..))
import CantonBoostPool (CantonCoin(..))
import Governance (GovernanceActionLog(..), ActionType(..), ConsumeProof(..))
import Compliance (ComplianceRegistry, ValidateTransfer(..))

-- ============================================================
--                     SECTION 1: STRATEGY CONFIG
-- ============================================================

-- | Strategy type tag
data LoopStrategy
  = CantonMaxiLoop   -- Mint → Stake → Borrow → Deposit Canton into Boost Pool → Loop
  | SMUSDMaxiLoop    -- Mint → Stake → Borrow → Re-stake → Loop
  deriving (Eq, Show)

-- | Global configuration for loop strategies
data LoopConfig = LoopConfig with
    maxLoops             : Int          -- Maximum loop iterations (default 5)
    minHealthFactorBps   : Bps          -- Min health factor before each loop (11500 = 115%)
    targetLtvBps         : Bps          -- Target LTV per loop (9000 = 90% for sMUSD collateral)
    liquidationThresholdBps : Bps       -- FIX DAML-003: Configurable liquidation threshold (was hardcoded 9300)
    minLoopAmountMusd    : Money        -- Minimum mUSD per loop to avoid dust
    borrowFeeBps         : Bps          -- Expected borrow fee per loop
    cooldownCheckEnabled : Bool         -- Whether to check sMUSD cooldown before unstaking
  deriving (Eq, Show)

defaultLoopConfig : LoopConfig
defaultLoopConfig = LoopConfig with
    maxLoops = 5
    minHealthFactorBps = 11500       -- 115% min health factor
    targetLtvBps = 9000              -- 90% LTV (sMUSD collateral)
    liquidationThresholdBps = 9300   -- FIX DAML-003: 93% sMUSD liquidation threshold (from CollateralConfig)
    minLoopAmountMusd = 10.0         -- 10 mUSD minimum per loop
    borrowFeeBps = 0                 -- No upfront fee (interest accrues)
    cooldownCheckEnabled = True

-- | FIX LS-GOV: Governance-controlled loop strategy configuration.
-- All config changes require GovernanceActionLog proof.
-- Hard-coded safety ceilings prevent catastrophic misconfiguration.
template CantonLoopStrategyConfig
  with
    operator             : Party
    config               : LoopConfig
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    observers            : [Party]
  where
    signatory operator
    observer observers

    ensure config.maxLoops >= 1 && config.maxLoops <= 10
        && config.targetLtvBps >= 1000 && config.targetLtvBps <= 9500
        && config.liquidationThresholdBps >= 5000 && config.liquidationThresholdBps <= 9900  -- FIX DAML-003
        && config.minHealthFactorBps >= 11000 && config.minHealthFactorBps <= 30000
        && config.minLoopAmountMusd >= 1.0

    key operator : Party
    maintainer key

    -- | Update max loops (governance-gated)
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    choice LoopConfig_UpdateMaxLoops : ContractId CantonLoopStrategyConfig
      with
        newMaxLoops : Int
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "MAX_LOOPS_RANGE" (newMaxLoops >= 1 && newMaxLoops <= 10)
        create this with config = config with maxLoops = newMaxLoops

    -- | Update target LTV (governance-gated)
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    choice LoopConfig_UpdateTargetLtv : ContractId CantonLoopStrategyConfig
      with
        newTargetLtvBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "TARGET_LTV_RANGE" (newTargetLtvBps >= 1000 && newTargetLtvBps <= 9500)
        create this with config = config with targetLtvBps = newTargetLtvBps

    -- | Update min health factor (governance-gated)
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    choice LoopConfig_UpdateMinHealthFactor : ContractId CantonLoopStrategyConfig
      with
        newMinHealthFactorBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "MIN_HF_RANGE" (newMinHealthFactorBps >= 11000 && newMinHealthFactorBps <= 30000)
        create this with config = config with minHealthFactorBps = newMinHealthFactorBps

    -- | Update compliance registry (governance-gated)
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    choice LoopConfig_SetComplianceRegistry : ContractId CantonLoopStrategyConfig
      with
        newComplianceRegistryCid : Optional (ContractId ComplianceRegistry)
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        create this with complianceRegistryCid = newComplianceRegistryCid

    -- | Read config (nonconsuming, no governance needed)
    nonconsuming choice LoopConfig_GetConfig : LoopConfig
      with
        requester : Party
      controller requester
      do return config

-- ============================================================
--                     SECTION 2: LOOP POSITION
-- ============================================================

-- | Tracks a user's leveraged loop position
template CantonLoopPosition
  with
    operator       : Party
    user           : Party
    strategy       : LoopStrategy
    config         : LoopConfig
    -- Position state
    totalDeposited : Money           -- Total USDC initially deposited
    totalMusdMinted : Money          -- Total mUSD minted across all loops
    totalStaked    : Money           -- Total mUSD staked into sMUSD
    totalBorrowed  : Money           -- Total mUSD borrowed across all loops
    loopsCompleted : Int             -- Number of loops executed
    leverageMultiplier : Decimal     -- Current effective leverage (e.g. 5.13)
    -- Contract references
    smusdCids      : [ContractId CantonSMUSD]   -- All sMUSD positions from staking
    cantonCoinCid  : Optional (ContractId CantonCoin)  -- Canton position (CantonMaxi only)
    createdAt      : Time
    lastUpdated    : Time
    status         : Text            -- "active" | "unwinding" | "closed"
  where
    signatory operator, user
    -- FIX D-C01 (LS-8): Combine all ensure predicates into a single clause.
    -- Previously used multiple `ensure` statements — only the LAST one was enforced.
    ensure totalDeposited > 0.0
        && loopsCompleted >= 0 && loopsCompleted <= config.maxLoops
        && status `elem` ["active", "unwinding", "closed"]

    -- | User can request to unwind the entire position
    -- FIX LS-LIFECYCLE: Transition status to "unwinding" before creating unwind request
    choice LoopPosition_Unwind : (ContractId CantonLoopPosition, ContractId CantonLoopUnwindRequest)
      controller user
      do
        assertMsg "ALREADY_UNWINDING" (status /= "unwinding")
        assertMsg "ALREADY_CLOSED" (status /= "closed")
        now <- getTime
        -- FIX LS-LIFECYCLE: Create new position with "unwinding" status (archive old via consuming)
        unwindingPos <- create this with
          status = "unwinding"
          lastUpdated = now
        req <- create CantonLoopUnwindRequest with
          positionCid = unwindingPos
          position = this with status = "unwinding"
          requestedAt = now
        return (unwindingPos, req)

    -- | Operator updates position state after a loop iteration
    -- FIX D-H01: Added on-ledger health factor validation
    choice LoopPosition_RecordLoop : ContractId CantonLoopPosition
      with
        musdMinted    : Money
        musdStaked    : Money
        musdBorrowed  : Money
        newSmusdCid   : ContractId CantonSMUSD
        newLeverage   : Decimal
      controller operator
      do
        assertMsg "MAX_LOOPS_REACHED" (loopsCompleted < config.maxLoops)
        assertMsg "POSITIVE_AMOUNTS" (musdMinted > 0.0 && musdStaked > 0.0 && musdBorrowed > 0.0)

        -- FIX D-H01: On-ledger health factor check before recording loop
        let newTotalStaked = totalStaked + musdStaked
        let newTotalBorrowed = totalBorrowed + musdBorrowed
        -- FIX DAML-009: Use Money (Numeric 18) directly for full 18-decimal precision.
        -- Previous approach converted to Decimal (Numeric 10) via 10^10 scaling, losing 8 decimals.
        -- Now operates entirely in Money space — no truncation, no precision loss.
        -- FIX DAML-003: Use config-defined liquidation threshold instead of hardcoded 9300
        let healthFactor = calculateHealthFactorMoney newTotalStaked config.liquidationThresholdBps newTotalBorrowed
        let minHF : Money = intToNumeric config.minHealthFactorBps / 10000.0
        assertMsg "HEALTH_FACTOR_TOO_LOW" (healthFactor >= minHF)

        now <- getTime
        create this with
          totalMusdMinted = totalMusdMinted + musdMinted
          totalStaked = newTotalStaked
          totalBorrowed = newTotalBorrowed
          loopsCompleted = loopsCompleted + 1
          leverageMultiplier = newLeverage
          smusdCids = smusdCids ++ [newSmusdCid]
          lastUpdated = now

    -- | Mark position as closed after unwind completes
    -- FIX D-H02: Validate that status is "unwinding" and create a final "closed" record
    -- FIX LS-LIFECYCLE: This is now reachable because LoopPosition_Unwind sets status = "unwinding"
    choice LoopPosition_Close : ContractId CantonLoopPosition
      controller operator
      do
        assertMsg "NOT_UNWINDING" (status == "unwinding")
        now <- getTime
        create this with
          status = "closed"
          totalBorrowed = 0.0
          smusdCids = []
          cantonCoinCid = None
          lastUpdated = now

-- ============================================================
--                     SECTION 3: LOOP EXECUTION REQUEST
-- ============================================================

-- | User requests to open a new loop strategy position
-- FIX D-C01: Both operator AND user are signatories to prevent forging.
-- Uses proposal pattern — user creates, operator must also sign to execute.
-- FIX LS-GOV: References CantonLoopStrategyConfig for governance-approved parameters
-- FIX LS-COMP: Compliance check on execute + unwind
template CantonLoopRequest
  with
    operator       : Party
    user           : Party
    strategy       : LoopStrategy
    config         : LoopConfig
    initialUsdcCid : ContractId CantonUSDC    -- USDC to start the loop
    initialAmount  : Money                     -- USDC amount
    requestedLoops : Int                       -- How many loops to execute (≤ maxLoops)
    requestedAt    : Time
    configCid      : ContractId CantonLoopStrategyConfig  -- FIX LS-GOV: Reference to governance-approved config
  where
    signatory user, operator
    ensure initialAmount > 0.0
      && requestedLoops > 0 && requestedLoops <= config.maxLoops

    -- | Operator executes the loop strategy
    -- FIX D-C02: Fetch and consume the USDC token to verify ownership and amount.
    -- FIX LS-GOV: Validate config against governance-approved config
    -- FIX LS-COMP: Compliance check before execution
    choice LoopRequest_Execute : ContractId CantonLoopPosition
      controller operator
      do
        now <- getTime
        -- Validate config
        assertMsg "TOO_MANY_LOOPS" (requestedLoops <= config.maxLoops)
        assertMsg "MIN_AMOUNT" (initialAmount >= config.minLoopAmountMusd)

        -- FIX LS-GOV: Fetch governance-approved config and validate
        approvedCfg <- fetch configCid
        let approved = approvedCfg.config
        assertMsg "MAX_LOOPS_EXCEEDS_APPROVED" (config.maxLoops <= approved.maxLoops)
        assertMsg "TARGET_LTV_EXCEEDS_APPROVED" (config.targetLtvBps <= approved.targetLtvBps)
        assertMsg "MIN_HF_BELOW_APPROVED" (config.minHealthFactorBps >= approved.minHealthFactorBps)

        -- FIX LS-COMP: Compliance check — reject blacklisted/frozen users
        case approvedCfg.complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()

        -- FIX D-C02: Fetch the USDC token, verify ownership + amount, and archive it
        usdcToken <- fetch initialUsdcCid
        assertMsg "USDC_NOT_OWNED_BY_USER" (usdcToken.owner == user)
        assertMsg "USDC_AMOUNT_MISMATCH" (usdcToken.amount >= initialAmount)
        archive initialUsdcCid

        -- Create initial position (first loop happens off-ledger via relay,
        -- this records the starting state)
        create CantonLoopPosition with
          operator
          user
          strategy
          config
          totalDeposited = initialAmount
          totalMusdMinted = 0.0       -- Will be updated by RecordLoop
          totalStaked = 0.0
          totalBorrowed = 0.0
          loopsCompleted = 0
          leverageMultiplier = 1.0
          smusdCids = []
          cantonCoinCid = None
          createdAt = now
          lastUpdated = now
          status = "active"

    -- | User can cancel before execution
    -- FIX D-C03: Return the ORIGINAL escrowed USDC instead of minting new tokens.
    -- The USDC was NOT consumed during request creation (only on execute),
    -- so we simply let the user know the request is cancelled. The USDC CID
    -- remains live and usable by the user.
    choice LoopRequest_Cancel : ()
      controller user
      do
        -- The original initialUsdcCid was never archived (only archived on Execute),
        -- so the user retains it automatically. Nothing to return.
        return ()

-- ============================================================
--                     SECTION 4: UNWIND REQUEST
-- ============================================================

-- | Request to unwind a loop position (repay all borrows, unstake all sMUSD)
-- FIX LS-LIFECYCLE: Now holds positionCid for on-ledger lifecycle management
template CantonLoopUnwindRequest
  with
    positionCid : ContractId CantonLoopPosition  -- FIX LS-LIFECYCLE: Live contract reference
    position    : CantonLoopPosition
    requestedAt : Time
  where
    signatory position.operator, position.user

    -- | Operator executes the unwind
    -- Reverse process:
    --   1. Sell Canton coin for mUSD (CantonMaxi only)
    --   2. Unstake sMUSD → mUSD (may need cooldown wait)
    --   3. Repay borrow with mUSD
    --   4. Withdraw remaining sMUSD collateral
    --   5. Unstake remaining sMUSD → mUSD
    --   6. Redeem mUSD → USDC via DirectMint
    --   7. Return USDC to user
    -- FIX D-H03: Validate returned amount against position state.
    -- FIX LS-PROOF: Require collateral proof (sMUSD CIDs archived + mUSD burned)
    -- FIX LS-COMP: Compliance check on unwind
    choice UnwindRequest_Execute : ContractId CantonUSDC
      with
        usdcReturned      : Money    -- Final USDC amount after all fees/slippage
        smusdToArchive    : [ContractId CantonSMUSD]  -- FIX LS-PROOF: sMUSD positions to unstake
        musdToBurn        : Optional (ContractId CantonMUSD)  -- FIX LS-PROOF: mUSD for debt repayment
        configCid         : ContractId CantonLoopStrategyConfig  -- FIX LS-COMP: For compliance check
      controller position.operator
      do
        assertMsg "POSITIVE_RETURN" (usdcReturned > 0.0)

        -- FIX LS-COMP: Compliance check on unwind
        approvedCfg <- fetch configCid
        case approvedCfg.complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = position.operator; receiver = position.user
          None -> pure ()

        -- FIX LS-PROOF: Archive all sMUSD collateral as proof of unstaking
        -- Verify count matches position's recorded sMUSD CIDs
        assertMsg "SMUSD_COUNT_MISMATCH" (length smusdToArchive == length position.smusdCids)
        forA_ smusdToArchive (\cid -> do
          smusd <- fetch cid
          assertMsg "SMUSD_NOT_OPERATOR_ISSUED" (smusd.issuer == position.operator)
          archive cid
          )

        -- FIX LS-PROOF: Burn mUSD to prove debt repayment
        -- FIX DAML-002: Atomically couple BurnRateLimiter with CantonMUSD_Burn
        case musdToBurn of
          Some musdCid -> do
            musd <- fetch musdCid
            assertMsg "MUSD_OWNER_MISMATCH" (musd.owner == position.operator || musd.owner == position.user)
            _ <- exerciseByKey @BurnRateLimiter position.operator BurnLimit_RecordBurn with
              burnAmount = musd.amount
            exercise musdCid CantonMUSD_Burn
          None ->
            -- No mUSD to burn is only valid if there was no debt
            assertMsg "DEBT_EXISTS_BUT_NO_MUSD_BURN" (position.totalBorrowed <= 0.0)

        -- FIX D-H03: Cap max return to prevent unbounded minting.
        let depositDec : Decimal = intToDecimal (truncate position.totalDeposited)
        let maxReturnDec = depositDec * position.leverageMultiplier * 2.0
        let returnedDec : Decimal = intToDecimal (truncate usdcReturned)
        assertMsg "RETURN_EXCEEDS_MAX" (returnedDec <= maxReturnDec)
        -- FIX LS-PROOF: Minimum return floor — at least 10% of initial deposit
        let minReturnDec = depositDec * 0.1
        assertMsg "RETURN_BELOW_MIN" (returnedDec >= minReturnDec)

        -- FIX LS-LIFECYCLE: Close the position on-ledger
        exercise positionCid LoopPosition_Close

        -- Return USDC to user
        create CantonUSDC with
          issuer = position.operator
          owner = position.user
          amount = usdcReturned
          privacyObservers = []

    -- | User can cancel unwind (position returns to active)
    -- FIX LS-LIFECYCLE: Exercise LoopPosition on-ledger to revert status
    choice UnwindRequest_Cancel : ContractId CantonLoopPosition
      controller position.user
      do
        now <- getTime
        -- Archive the "unwinding" position and create a new "active" one
        archive positionCid
        create position with
          status = "active"
          lastUpdated = now

-- ============================================================
--                     SECTION 5: LEVERAGE CALCULATOR
-- ============================================================

-- | Calculate effective leverage for N loops at given LTV
-- leverage = Σ(ltv^i) for i=0..N-1 = (1 - ltv^N) / (1 - ltv)
-- Example: 5 loops at 90% LTV:
--   leverage = (1 - 0.9^5) / (1 - 0.9) = (1 - 0.59049) / 0.1 = 4.0951

-- Helper: top-level recursive accumulator (DAML doesn't support local recursion)
leverageAccum : Decimal -> Int -> Decimal -> Decimal -> Decimal
leverageAccum _ltv 0 acc _factor = acc
leverageAccum ltvVal n acc factor = leverageAccum ltvVal (n - 1) (acc + factor) (factor * ltvVal)

calculateLeverage : Decimal -> Int -> Decimal
calculateLeverage ltv loops = leverageAccum ltv loops 0.0 1.0

-- | Calculate net APY from loop strategy
-- netAPY = stakingRate × leverage − borrowRate × (leverage − 1)
calculateNetAPY : Decimal -> Decimal -> Decimal -> Decimal
calculateNetAPY stakingRate borrowRate leverage =
  stakingRate * leverage - borrowRate * (leverage - 1.0)

-- | Calculate health factor check
-- healthFactor = (collateralValue × liquidationThreshold) / debtValue
-- Must be > minHealthFactor before each new loop
-- Uses Decimal (Numeric 10) to avoid Money (Numeric 18) type mismatch
-- FIX DAML-009: Reordered to multiply before dividing, maximizing intermediate precision.
-- Previously: (collateralValue * (thresholdBps / 10000)) / debtValue — intermediate division loses bits
-- Now: (collateralValue * thresholdBps) / (debtValue * 10000) — multiplies first, divides last
calculateHealthFactor : Decimal -> Bps -> Decimal -> Decimal
calculateHealthFactor collateralValue liquidationThresholdBps debtValue =
  if debtValue <= 0.0
    then 999.0  -- No debt = infinite health
    else
      let threshold = intToDecimal liquidationThresholdBps
      in  (collateralValue * threshold) / (debtValue * 10000.0)

-- FIX DAML-009: Full 18-decimal precision health factor calculation using Money (Numeric 18).
-- Avoids lossy Money → Decimal (Numeric 10) conversion that truncates 8 decimal places.
-- Use this instead of calculateHealthFactor when operating on Money-typed collateral/debt values.
calculateHealthFactorMoney : Money -> Bps -> Money -> Money
calculateHealthFactorMoney collateralValue liquidationThresholdBps debtValue =
  if debtValue <= 0.0
    then 999.0  -- No debt = infinite health
    else
      let threshold : Money = intToNumeric liquidationThresholdBps
      in  (collateralValue * threshold) / (debtValue * 10000.0)

-- ============================================================
--                     SECTION 6: LOOP STRATEGY TEMPLATES
-- ============================================================

-- | Pre-built strategy templates for the frontend

-- | Canton Maxi Loop — maximize Canton coin exposure via leveraged sMUSD
-- Flow per loop: mUSD → stake sMUSD → borrow mUSD → buy Canton
cantonMaxiLoopConfig : LoopConfig
cantonMaxiLoopConfig = defaultLoopConfig with
    maxLoops = 3              -- Conservative: only 3 loops for volatile Canton coin
    minHealthFactorBps = 12000 -- 120% min health (higher due to volatile destination asset)
    targetLtvBps = 9000

-- | sMUSD Maxi Loop — maximize sMUSD yield via recursive staking
-- Flow per loop: mUSD → stake sMUSD → borrow mUSD → re-stake
smusdMaxiLoopConfig : LoopConfig
smusdMaxiLoopConfig = defaultLoopConfig with
    maxLoops = 5              -- More loops safe for stable-to-stable
    minHealthFactorBps = 11500 -- 115% min health
    targetLtvBps = 9000

-- ============================================================
--                     SECTION 7: STRATEGY ESTIMATOR
-- ============================================================

-- | Off-ledger view for frontend to display estimated strategy returns
data StrategyEstimate = StrategyEstimate with
    strategy        : LoopStrategy
    initialDeposit  : Money
    loops           : Int
    leverage        : Decimal
    stakingAPY      : Decimal    -- Current sMUSD APY
    borrowAPY       : Decimal    -- Current borrow rate
    netAPY          : Decimal    -- Estimated net APY after leverage
    estimatedYield  : Decimal    -- Estimated annual yield (Decimal for arithmetic compat)
    healthFactor    : Decimal    -- Estimated health factor at target leverage
  deriving (Eq, Show)

-- | Calculate strategy estimate for frontend display
-- FIX DAML-003: Accept LoopConfig parameter to avoid hardcoded default liquidation threshold
estimateStrategy : LoopStrategy -> LoopConfig -> Money -> Int -> Decimal -> Decimal -> StrategyEstimate
estimateStrategy strat cfg deposit loops stakingRate borrowRate =
  let
    ltv = 0.9  -- 90% for sMUSD collateral
    leverage = calculateLeverage ltv loops
    netAPY = calculateNetAPY stakingRate borrowRate leverage
    -- Convert Money (Numeric 18) to Decimal (Numeric 10) for arithmetic
    depositDec : Decimal = intToDecimal (truncate deposit)
    estimatedYield = depositDec * netAPY
    -- After all loops: total staked ≈ deposit × leverage, total borrowed ≈ deposit × (leverage - 1)
    totalStaked = depositDec * leverage
    totalBorrowed = depositDec * (leverage - 1.0)
    -- FIX DAML-003: Use config-defined liquidation threshold from provided LoopConfig
    healthFactor = calculateHealthFactor totalStaked cfg.liquidationThresholdBps totalBorrowed
  in StrategyEstimate with
    strategy = strat
    initialDeposit = deposit
    loops = loops
    leverage = leverage
    stakingAPY = stakingRate
    borrowAPY = borrowRate
    netAPY = netAPY
    estimatedYield = estimatedYield
    healthFactor = healthFactor
