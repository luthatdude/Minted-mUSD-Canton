-- | CantonLoopStrategy (H-04)
-- Canton-side loop leverage strategy with mandatory compliance checks.
--
-- Architecture:
--   Mirrors the on-chain LeverageVault.sol loop strategy on Canton.
--   Users deposit collateral, borrow mUSD in a loop to amplify exposure.
--   Each operation is compliance-gated via ComplianceRegistry checks.
--
-- Compliance:
--   - Blacklisted users cannot open, extend, or close positions
--   - Frozen users cannot withdraw or reduce positions
--   - All choices call ComplianceRegistry.IsCompliant before execution
--
-- Lifecycle:
--   1. User opens a loop position with initial collateral
--   2. System borrows mUSD → swaps → deposits collateral → repeats N loops
--   3. User can extend (add collateral) or partially unwind
--   4. Full close: unwind all loops, repay debt, return remainder

module CantonLoopStrategy where

import DA.Time
import CantonDirectMint (Money, Bps)
import CantonLending (CantonLendingService(..), EscrowedCollateral(..), CollateralType(..))
import Compliance (ComplianceRegistry(..), IsCompliant(..), ValidateMint(..), ValidateRedemption(..))
import UserPrivacySettings (lookupUserObservers)

-- ============================================================
--                     SECTION 1: LOOP POSITION
-- ============================================================

-- | Represents an active leveraged loop position on Canton.
template CantonLoopPosition
  with
    operator           : Party
    user               : Party
    collateralType     : CollateralType     -- Token used as collateral
    initialDeposit     : Money              -- Original user deposit
    totalCollateral    : Money              -- Total collateral after all loops
    totalDebt          : Money              -- Total mUSD debt accumulated
    loopCount          : Int                -- Number of loops executed
    maxLeverage        : Money              -- Max leverage allowed (e.g., 3.0 = 3x)
    openedAt           : Time               -- Position open timestamp
    lastUpdated        : Time               -- Last interaction timestamp
    privacyObservers   : [Party]            -- Opt-in transparency
  where
    signatory operator, user
    observer privacyObservers

    ensure initialDeposit > 0.0
        && totalCollateral >= initialDeposit
        && totalDebt >= 0.0
        && loopCount >= 0
        && maxLeverage > 1.0

    -- | Update observers from user's privacy settings
    choice LoopPosition_UpdateObservers : ContractId CantonLoopPosition
      with
        newObservers : [Party]
      controller user
      do create this with privacyObservers = newObservers

-- ============================================================
--                     SECTION 2: LOOP STRATEGY SERVICE
-- ============================================================

-- | Canton loop strategy service — manages leveraged positions.
-- All choices are compliance-gated via ComplianceRegistry.
template CantonLoopStrategyService
  with
    operator               : Party
    -- Strategy parameters
    maxLoops               : Int            -- Maximum number of leverage loops (e.g., 10)
    maxLeverageX10         : Int            -- Max leverage × 10 (e.g., 30 = 3.0x)
    minBorrowPerLoop       : Money          -- Minimum borrow per loop iteration
    totalPositions         : Int            -- Count of active positions
    totalCollateralLocked  : Money          -- Aggregate collateral across all positions
    totalDebtIssued        : Money          -- Aggregate debt across all positions
    -- Fees
    entryFeeBps            : Bps            -- Fee on initial deposit (default 0)
    exitFeeBps             : Bps            -- Fee on position close (default 25 = 0.25%)
    protocolFeesAccrued    : Money          -- Accumulated protocol fees
    -- State
    paused                 : Bool
    -- H-04: Mandatory compliance — all users must pass blacklist/freeze checks
    complianceRegistryCid  : ContractId ComplianceRegistry
    lendingServiceCid      : ContractId CantonLendingService
    serviceName            : Text
    observers              : [Party]
  where
    signatory operator
    observer observers

    key (operator, serviceName) : (Party, Text)
    maintainer key._1

    ensure maxLoops > 0 && maxLoops <= 20
        && maxLeverageX10 >= 10 && maxLeverageX10 <= 40
        && minBorrowPerLoop > 0.0
        && totalPositions >= 0
        && totalCollateralLocked >= 0.0
        && totalDebtIssued >= 0.0
        && entryFeeBps >= 0 && entryFeeBps <= 500
        && exitFeeBps >= 0 && exitFeeBps <= 500
        && protocolFeesAccrued >= 0.0

    -- ──────────────────────────────────────────────
    --  OPEN POSITION: Deposit + loop leverage
    -- ──────────────────────────────────────────────

    -- | Open a new leveraged loop position.
    -- Deposits initial collateral, then borrows-and-deposits in a loop.
    choice Loop_Open : (ContractId CantonLoopStrategyService, ContractId CantonLoopPosition)
      with
        user              : Party
        collateral        : CollateralType
        depositAmount     : Money             -- Initial collateral deposit
        requestedLoops    : Int               -- Number of loops to execute
        oraclePrice       : Money             -- Current collateral price in mUSD
        slippageTolerance : Bps               -- Max slippage in bps (H-09)
      controller user
      do
        assertMsg "STRATEGY_PAUSED" (not paused)
        assertMsg "TOO_MANY_LOOPS" (requestedLoops > 0 && requestedLoops <= maxLoops)
        assertMsg "DEPOSIT_POSITIVE" (depositAmount > 0.0)
        assertMsg "INVALID_SLIPPAGE" (slippageTolerance >= 0 && slippageTolerance <= 500)

        -- FIX C-2: Use ValidateMint instead of IsCompliant.
        -- IsCompliant returns Bool but the return value was discarded, making the check a no-op.
        -- ValidateMint uses assertMsg internally and reverts on blacklisted parties.
        exercise complianceRegistryCid ValidateMint
          with minter = user

        now <- getTime

        -- Calculate entry fee
        let entryFee = depositAmount * intToDecimal entryFeeBps / 10000.0
        let netDeposit = depositAmount - entryFee

        -- Simulate loop: each iteration borrows up to collateral factor, swaps, deposits
        -- In production this would interact with the lending service
        let effectiveLeverage = min (intToDecimal maxLeverageX10 / 10.0) (intToDecimal (requestedLoops + 1))
        let totalCollat = netDeposit * effectiveLeverage
        let totalBorrowed = totalCollat - netDeposit

        assertMsg "BORROW_TOO_SMALL" (totalBorrowed >= minBorrowPerLoop)

        -- Create position
        posCid <- create CantonLoopPosition with
          operator = operator
          user = user
          collateralType = collateral
          initialDeposit = netDeposit
          totalCollateral = totalCollat
          totalDebt = totalBorrowed
          loopCount = requestedLoops
          maxLeverage = intToDecimal maxLeverageX10 / 10.0
          openedAt = now
          lastUpdated = now
          privacyObservers = []

        -- Update service state
        svcCid <- create this with
          totalPositions = totalPositions + 1
          totalCollateralLocked = totalCollateralLocked + totalCollat
          totalDebtIssued = totalDebtIssued + totalBorrowed
          protocolFeesAccrued = protocolFeesAccrued + entryFee

        return (svcCid, posCid)

    -- ──────────────────────────────────────────────
    --  CLOSE POSITION: Unwind loops, repay debt
    -- ──────────────────────────────────────────────

    -- | Close an existing leveraged position.
    -- Unwinds all loops, repays debt, returns remainder to user.
    choice Loop_Close : ContractId CantonLoopStrategyService
      with
        user       : Party
        positionCid : ContractId CantonLoopPosition
      controller user
      do
        assertMsg "STRATEGY_PAUSED" (not paused)

        -- FIX C-2: Use ValidateRedemption instead of IsCompliant.
        -- ValidateRedemption asserts on blacklisted AND frozen parties.
        -- IsCompliant was a passive Bool query whose return value was discarded.
        exercise complianceRegistryCid ValidateRedemption
          with redeemer = user

        pos <- fetch positionCid
        assertMsg "NOT_POSITION_OWNER" (pos.user == user)
        assertMsg "POSITION_OPERATOR_MISMATCH" (pos.operator == operator)

        archive positionCid

        -- Calculate exit fee on remaining collateral value after debt repay
        let remainder = pos.totalCollateral - pos.totalDebt
        let exitFee = remainder * intToDecimal exitFeeBps / 10000.0

        -- Update service state
        create this with
          totalPositions = totalPositions - 1
          totalCollateralLocked = totalCollateralLocked - pos.totalCollateral
          totalDebtIssued = totalDebtIssued - pos.totalDebt
          protocolFeesAccrued = protocolFeesAccrued + exitFee

    -- ──────────────────────────────────────────────
    --  EMERGENCY CLOSE: Admin unwind
    -- ──────────────────────────────────────────────

    -- | Emergency close a user's position (admin only).
    choice Loop_EmergencyClose : ContractId CantonLoopStrategyService
      with
        positionCid : ContractId CantonLoopPosition
      controller operator
      do
        pos <- fetch positionCid
        archive positionCid

        create this with
          totalPositions = totalPositions - 1
          totalCollateralLocked = totalCollateralLocked - pos.totalCollateral
          totalDebtIssued = totalDebtIssued - pos.totalDebt

    -- ──────────────────────────────────────────────
    --  ADMIN: Update parameters
    -- ──────────────────────────────────────────────

    -- | Update strategy parameters (operator only).
    choice Loop_UpdateParams : ContractId CantonLoopStrategyService
      with
        newMaxLoops        : Int
        newMaxLeverageX10  : Int
        newMinBorrowPerLoop : Money
      controller operator
      do
        assertMsg "INVALID_MAX_LOOPS" (newMaxLoops > 0 && newMaxLoops <= 20)
        assertMsg "INVALID_MAX_LEVERAGE" (newMaxLeverageX10 >= 10 && newMaxLeverageX10 <= 40)
        assertMsg "INVALID_MIN_BORROW" (newMinBorrowPerLoop > 0.0)

        create this with
          maxLoops = newMaxLoops
          maxLeverageX10 = newMaxLeverageX10
          minBorrowPerLoop = newMinBorrowPerLoop

    -- | Pause/unpause the strategy.
    choice Loop_SetPaused : ContractId CantonLoopStrategyService
      with
        newPaused : Bool
      controller operator
      do create this with paused = newPaused

    -- | Withdraw accumulated protocol fees.
    choice Loop_WithdrawFees : ContractId CantonLoopStrategyService
      with
        amount : Money
      controller operator
      do
        assertMsg "INSUFFICIENT_FEES" (amount <= protocolFeesAccrued)
        create this with protocolFeesAccrued = protocolFeesAccrued - amount
