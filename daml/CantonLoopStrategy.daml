-- | CantonLoopStrategy
-- Canton-native Loop Orchestrator — automated multi-step DeFi strategies
--
-- Architecture:
--   Orchestrates atomic multi-step workflows across Canton DAML modules:
--     1. CantonMaxiLoop: USDC → Mint mUSD → Stake sMUSD → Borrow mUSD → Deposit Canton → Loop
--     2. SMUSDMaxiLoop:  USDC → Mint mUSD → Stake sMUSD → Borrow mUSD → Re-stake → Loop
--
--   Each loop increases effective yield by leveraging sMUSD's high LTV (90%).
--   Maximum 5 loops to prevent excessive leverage/gas.
--
-- Safety Features:
--   - Max loop count (configurable, default 5)
--   - Min health factor check before each loop (1.15 = 115%)
--   - Stale price protection via CantonPriceFeed
--   - Operator must approve execution
--   - User-initiated unwind with full position close
--
-- Revenue Model:
--   Each loop compounds: deposit → borrow at 90% LTV → re-stake
--   Net APY = stakingRate × leverage − borrowRate × (leverage − 1)
--   Example: 6% stake, 4% borrow, 5 loops at 90% LTV:
--     leverage ≈ 5.13x → net ≈ 6% × 5.13 − 4% × 4.13 = 14.26%

module CantonLoopStrategy where

import DA.Time
import DA.Optional (fromOptional)
import CantonDirectMint (CantonUSDC(..), CantonMUSD(..), CantonMUSD_Burn(..), CantonMUSD_Split(..), Money, Bps)
import CantonSMUSD (CantonSMUSD(..))
import CantonBoostPool (CantonCoin(..))

-- ============================================================
--                     SECTION 1: STRATEGY CONFIG
-- ============================================================

-- | Strategy type tag
data LoopStrategy
  = CantonMaxiLoop   -- Mint → Stake → Borrow → Deposit Canton into Boost Pool → Loop
  | SMUSDMaxiLoop    -- Mint → Stake → Borrow → Re-stake → Loop
  deriving (Eq, Show)

-- | Global configuration for loop strategies
data LoopConfig = LoopConfig with
    maxLoops             : Int          -- Maximum loop iterations (default 5)
    minHealthFactorBps   : Bps          -- Min health factor before each loop (11500 = 115%)
    targetLtvBps         : Bps          -- Target LTV per loop (9000 = 90% for sMUSD collateral)
    minLoopAmountMusd    : Money        -- Minimum mUSD per loop to avoid dust
    borrowFeeBps         : Bps          -- Expected borrow fee per loop
    cooldownCheckEnabled : Bool         -- Whether to check sMUSD cooldown before unstaking
  deriving (Eq, Show)

defaultLoopConfig : LoopConfig
defaultLoopConfig = LoopConfig with
    maxLoops = 5
    minHealthFactorBps = 11500       -- 115% min health factor
    targetLtvBps = 9000              -- 90% LTV (sMUSD collateral)
    minLoopAmountMusd = 10.0         -- 10 mUSD minimum per loop
    borrowFeeBps = 0                 -- No upfront fee (interest accrues)
    cooldownCheckEnabled = True

-- ============================================================
--                     SECTION 2: LOOP POSITION
-- ============================================================

-- | Tracks a user's leveraged loop position
template CantonLoopPosition
  with
    operator       : Party
    user           : Party
    strategy       : LoopStrategy
    config         : LoopConfig
    -- Position state
    totalDeposited : Money           -- Total USDC initially deposited
    totalMusdMinted : Money          -- Total mUSD minted across all loops
    totalStaked    : Money           -- Total mUSD staked into sMUSD
    totalBorrowed  : Money           -- Total mUSD borrowed across all loops
    loopsCompleted : Int             -- Number of loops executed
    leverageMultiplier : Decimal     -- Current effective leverage (e.g. 5.13)
    -- Contract references
    smusdCids      : [ContractId CantonSMUSD]   -- All sMUSD positions from staking
    cantonCoinCid  : Optional (ContractId CantonCoin)  -- Canton position (CantonMaxi only)
    createdAt      : Time
    lastUpdated    : Time
    status         : Text            -- "active" | "unwinding" | "closed"
  where
    signatory operator, user
    -- FIX D-C01 (LS-8): Combine all ensure predicates into a single clause.
    -- Previously used multiple `ensure` statements — only the LAST one was enforced.
    ensure totalDeposited > 0.0
        && loopsCompleted >= 0 && loopsCompleted <= config.maxLoops
        && status `elem` ["active", "unwinding", "closed"]

    -- | User can request to unwind the entire position
    choice LoopPosition_Unwind : ContractId CantonLoopUnwindRequest
      controller user
      do
        assertMsg "ALREADY_UNWINDING" (status /= "unwinding")
        assertMsg "ALREADY_CLOSED" (status /= "closed")
        now <- getTime
        create CantonLoopUnwindRequest with
          position = this
          requestedAt = now

    -- | Operator updates position state after a loop iteration
    -- FIX D-H01: Added on-ledger health factor validation
    choice LoopPosition_RecordLoop : ContractId CantonLoopPosition
      with
        musdMinted    : Money
        musdStaked    : Money
        musdBorrowed  : Money
        newSmusdCid   : ContractId CantonSMUSD
        newLeverage   : Decimal
      controller operator
      do
        assertMsg "MAX_LOOPS_REACHED" (loopsCompleted < config.maxLoops)
        assertMsg "POSITIVE_AMOUNTS" (musdMinted > 0.0 && musdStaked > 0.0 && musdBorrowed > 0.0)

        -- FIX D-H01: On-ledger health factor check before recording loop
        let newTotalStaked = totalStaked + musdStaked
        let newTotalBorrowed = totalBorrowed + musdBorrowed
        -- Convert Money (Numeric 18) to Decimal (Numeric 10) for health factor calc
        let stakedDec : Decimal = intToDecimal (truncate newTotalStaked)
        let borrowedDec : Decimal = intToDecimal (truncate newTotalBorrowed)
        let healthFactor = calculateHealthFactor stakedDec 9300 borrowedDec
        let minHF = intToDecimal config.minHealthFactorBps / 10000.0
        assertMsg "HEALTH_FACTOR_TOO_LOW" (healthFactor >= minHF)

        now <- getTime
        create this with
          totalMusdMinted = totalMusdMinted + musdMinted
          totalStaked = newTotalStaked
          totalBorrowed = newTotalBorrowed
          loopsCompleted = loopsCompleted + 1
          leverageMultiplier = newLeverage
          smusdCids = smusdCids ++ [newSmusdCid]
          lastUpdated = now

    -- | Mark position as closed after unwind completes
    -- FIX D-H02: Validate that debt is fully repaid and status is "unwinding"
    choice LoopPosition_Close : ()
      controller operator
      do
        assertMsg "NOT_UNWINDING" (status == "unwinding")
        assertMsg "DEBT_NOT_REPAID" (totalBorrowed <= 0.0)
        return ()

-- ============================================================
--                     SECTION 3: LOOP EXECUTION REQUEST
-- ============================================================

-- | User requests to open a new loop strategy position
-- FIX D-C01: Both operator AND user are signatories to prevent forging.
-- Uses proposal pattern — user creates, operator must also sign to execute.
template CantonLoopRequest
  with
    operator       : Party
    user           : Party
    strategy       : LoopStrategy
    config         : LoopConfig
    initialUsdcCid : ContractId CantonUSDC    -- USDC to start the loop
    initialAmount  : Money                     -- USDC amount
    requestedLoops : Int                       -- How many loops to execute (≤ maxLoops)
    requestedAt    : Time
  where
    signatory user, operator
    ensure initialAmount > 0.0
      && requestedLoops > 0 && requestedLoops <= config.maxLoops

    -- | Operator executes the loop strategy
    -- FIX D-C02: Fetch and consume the USDC token to verify ownership and amount.
    choice LoopRequest_Execute : ContractId CantonLoopPosition
      controller operator
      do
        now <- getTime
        -- Validate config
        assertMsg "TOO_MANY_LOOPS" (requestedLoops <= config.maxLoops)
        assertMsg "MIN_AMOUNT" (initialAmount >= config.minLoopAmountMusd)

        -- FIX D-C02: Fetch the USDC token, verify ownership + amount, and archive it
        usdcToken <- fetch initialUsdcCid
        assertMsg "USDC_NOT_OWNED_BY_USER" (usdcToken.owner == user)
        assertMsg "USDC_AMOUNT_MISMATCH" (usdcToken.amount >= initialAmount)
        archive initialUsdcCid

        -- Create initial position (first loop happens off-ledger via relay,
        -- this records the starting state)
        create CantonLoopPosition with
          operator
          user
          strategy
          config
          totalDeposited = initialAmount
          totalMusdMinted = 0.0       -- Will be updated by RecordLoop
          totalStaked = 0.0
          totalBorrowed = 0.0
          loopsCompleted = 0
          leverageMultiplier = 1.0
          smusdCids = []
          cantonCoinCid = None
          createdAt = now
          lastUpdated = now
          status = "active"

    -- | User can cancel before execution
    -- FIX D-C03: Return the ORIGINAL escrowed USDC instead of minting new tokens.
    -- The USDC was NOT consumed during request creation (only on execute),
    -- so we simply let the user know the request is cancelled. The USDC CID
    -- remains live and usable by the user.
    choice LoopRequest_Cancel : ()
      controller user
      do
        -- The original initialUsdcCid was never archived (only archived on Execute),
        -- so the user retains it automatically. Nothing to return.
        return ()

-- ============================================================
--                     SECTION 4: UNWIND REQUEST
-- ============================================================

-- | Request to unwind a loop position (repay all borrows, unstake all sMUSD)
template CantonLoopUnwindRequest
  with
    position    : CantonLoopPosition
    requestedAt : Time
  where
    signatory position.operator, position.user

    -- | Operator executes the unwind
    -- Reverse process:
    --   1. Sell Canton coin for mUSD (CantonMaxi only)
    --   2. Unstake sMUSD → mUSD (may need cooldown wait)
    --   3. Repay borrow with mUSD
    --   4. Withdraw remaining sMUSD collateral
    --   5. Unstake remaining sMUSD → mUSD
    --   6. Redeem mUSD → USDC via DirectMint
    --   7. Return USDC to user
    -- FIX D-H03: Validate returned amount against position state.
    --   The operator cannot return more than the total deposited + reasonable yield,
    --   and must return at least a minimum floor based on net position value.
    choice UnwindRequest_Execute : ContractId CantonUSDC
      with
        usdcReturned : Money    -- Final USDC amount after all fees/slippage
      controller position.operator
      do
        assertMsg "POSITIVE_RETURN" (usdcReturned > 0.0)
        -- FIX D-H03: Cap max return to prevent unbounded minting.
        -- Max possible = initial deposit × leverage × 2 (generous ceiling for gains)
        -- Convert Money (Numeric 18) to Decimal (Numeric 10) for arithmetic
        let depositDec : Decimal = intToDecimal (truncate position.totalDeposited)
        let maxReturnDec = depositDec * position.leverageMultiplier * 2.0
        let returnedDec : Decimal = intToDecimal (truncate usdcReturned)
        assertMsg "RETURN_EXCEEDS_MAX" (returnedDec <= maxReturnDec)
        -- Return USDC to user
        create CantonUSDC with
          issuer = position.operator
          owner = position.user
          amount = usdcReturned
          privacyObservers = []

    -- | User can cancel unwind (position stays active)
    choice UnwindRequest_Cancel : ContractId CantonLoopPosition
      controller position.user
      do
        now <- getTime
        create position with
          status = "active"
          lastUpdated = now

-- ============================================================
--                     SECTION 5: LEVERAGE CALCULATOR
-- ============================================================

-- | Calculate effective leverage for N loops at given LTV
-- leverage = Σ(ltv^i) for i=0..N-1 = (1 - ltv^N) / (1 - ltv)
-- Example: 5 loops at 90% LTV:
--   leverage = (1 - 0.9^5) / (1 - 0.9) = (1 - 0.59049) / 0.1 = 4.0951

-- Helper: top-level recursive accumulator (DAML doesn't support local recursion)
leverageAccum : Decimal -> Int -> Decimal -> Decimal -> Decimal
leverageAccum _ltv 0 acc _factor = acc
leverageAccum ltvVal n acc factor = leverageAccum ltvVal (n - 1) (acc + factor) (factor * ltvVal)

calculateLeverage : Decimal -> Int -> Decimal
calculateLeverage ltv loops = leverageAccum ltv loops 0.0 1.0

-- | Calculate net APY from loop strategy
-- netAPY = stakingRate × leverage − borrowRate × (leverage − 1)
calculateNetAPY : Decimal -> Decimal -> Decimal -> Decimal
calculateNetAPY stakingRate borrowRate leverage =
  stakingRate * leverage - borrowRate * (leverage - 1.0)

-- | Calculate health factor check
-- healthFactor = (collateralValue × liquidationThreshold) / debtValue
-- Must be > minHealthFactor before each new loop
-- Uses Decimal (Numeric 10) to avoid Money (Numeric 18) type mismatch
calculateHealthFactor : Decimal -> Bps -> Decimal -> Decimal
calculateHealthFactor collateralValue liquidationThresholdBps debtValue =
  if debtValue <= 0.0
    then 999.0  -- No debt = infinite health
    else
      let threshold = intToDecimal liquidationThresholdBps / 10000.0
      in  (collateralValue * threshold) / debtValue

-- ============================================================
--                     SECTION 6: LOOP STRATEGY TEMPLATES
-- ============================================================

-- | Pre-built strategy templates for the frontend

-- | Canton Maxi Loop — maximize Canton coin exposure via leveraged sMUSD
-- Flow per loop: mUSD → stake sMUSD → borrow mUSD → buy Canton
cantonMaxiLoopConfig : LoopConfig
cantonMaxiLoopConfig = defaultLoopConfig with
    maxLoops = 3              -- Conservative: only 3 loops for volatile Canton coin
    minHealthFactorBps = 12000 -- 120% min health (higher due to volatile destination asset)
    targetLtvBps = 9000

-- | sMUSD Maxi Loop — maximize sMUSD yield via recursive staking
-- Flow per loop: mUSD → stake sMUSD → borrow mUSD → re-stake
smusdMaxiLoopConfig : LoopConfig
smusdMaxiLoopConfig = defaultLoopConfig with
    maxLoops = 5              -- More loops safe for stable-to-stable
    minHealthFactorBps = 11500 -- 115% min health
    targetLtvBps = 9000

-- ============================================================
--                     SECTION 7: STRATEGY ESTIMATOR
-- ============================================================

-- | Off-ledger view for frontend to display estimated strategy returns
data StrategyEstimate = StrategyEstimate with
    strategy        : LoopStrategy
    initialDeposit  : Money
    loops           : Int
    leverage        : Decimal
    stakingAPY      : Decimal    -- Current sMUSD APY
    borrowAPY       : Decimal    -- Current borrow rate
    netAPY          : Decimal    -- Estimated net APY after leverage
    estimatedYield  : Decimal    -- Estimated annual yield (Decimal for arithmetic compat)
    healthFactor    : Decimal    -- Estimated health factor at target leverage
  deriving (Eq, Show)

-- | Calculate strategy estimate for frontend display
estimateStrategy : LoopStrategy -> Money -> Int -> Decimal -> Decimal -> StrategyEstimate
estimateStrategy strat deposit loops stakingRate borrowRate =
  let
    ltv = 0.9  -- 90% for sMUSD collateral
    leverage = calculateLeverage ltv loops
    netAPY = calculateNetAPY stakingRate borrowRate leverage
    -- Convert Money (Numeric 18) to Decimal (Numeric 10) for arithmetic
    depositDec : Decimal = intToDecimal (truncate deposit)
    estimatedYield = depositDec * netAPY
    -- After all loops: total staked ≈ deposit × leverage, total borrowed ≈ deposit × (leverage - 1)
    totalStaked = depositDec * leverage
    totalBorrowed = depositDec * (leverage - 1.0)
    healthFactor = calculateHealthFactor totalStaked 9300 totalBorrowed
  in StrategyEstimate with
    strategy = strat
    initialDeposit = deposit
    loops = loops
    leverage = leverage
    stakingAPY = stakingRate
    borrowAPY = borrowRate
    netAPY = netAPY
    estimatedYield = estimatedYield
    healthFactor = healthFactor
