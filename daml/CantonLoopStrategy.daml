-- | CantonLoopStrategy (H-04)
-- Canton-side loop leverage strategy with mandatory compliance checks.
--
-- Architecture:
--   Mirrors the on-chain LeverageVault.sol loop strategy on Canton.
--   Users deposit collateral, borrow mUSD in a loop to amplify exposure.
--   Each operation is compliance-gated via ComplianceRegistry checks.
--
-- Compliance:
--   - Blacklisted users cannot open, extend, or close positions
--   - Frozen users cannot withdraw or reduce positions
--   - All choices call ComplianceRegistry.IsCompliant before execution
--
-- Lifecycle:
--   1. User opens a loop position with initial collateral
--   2. System borrows mUSD, swaps, deposits collateral, repeats N loops
--   3. User can extend (add collateral) or partially unwind
--   4. Full close: unwind all loops, repay debt, return remainder

module CantonLoopStrategy where

import DA.Time
import DA.Action (when)
import DA.Optional (isSome)
import CantonDirectMint (CantonUSDC(..), CantonMUSD(..), Money, Bps)
import CantonSMUSD (CantonSMUSD(..))
import CantonLending (CantonLendingService(..), EscrowedCollateral(..), CollateralType(..))
import Compliance (ComplianceRegistry(..), IsCompliant(..), ValidateMint(..), ValidateRedemption(..))
import Governance (GovernanceActionLog(..), ActionType(..))
import UserPrivacySettings (lookupUserObservers)

-- ============================================================
--                     DATA TYPES
-- ============================================================

-- | Loop strategy variants
data LoopStrategy = SMUSDMaxiLoop
  deriving (Eq, Show)

-- | Governance-controlled loop parameters
data LoopConfig = LoopConfig with
    maxLoops           : Int    -- Maximum leverage loops (default 5)
    minHealthFactorBps : Bps    -- Minimum health factor x 10000 (default 11500 = 1.15)
    targetLtvBps       : Bps    -- Target loan-to-value x 10000 (default 9000 = 90%)
  deriving (Eq, Show)

-- | Default loop configuration
defaultLoopConfig : LoopConfig
defaultLoopConfig = LoopConfig with
  maxLoops = 5
  minHealthFactorBps = 11500
  targetLtvBps = 9000

-- | Strategy estimation result
data StrategyEstimate = StrategyEstimate with
    leverage     : Money
    netAPY       : Money
    healthFactor : Money
  deriving (Eq, Show)

-- ============================================================
--                     SECTION 1: LOOP POSITION
-- ============================================================

-- | Represents an active leveraged loop position on Canton.
template CantonLoopPosition
  with
    operator           : Party
    user               : Party
    strategy           : LoopStrategy
    config             : LoopConfig
    totalDeposited     : Money              -- Original USDC deposit
    loopsCompleted     : Int                -- Loops executed so far
    totalStaked        : Money              -- Total sMUSD staked
    totalBorrowed      : Money              -- Total mUSD debt accumulated
    leverageMultiplier : Money              -- Current effective leverage
    status             : Text               -- "active" or "unwinding"
    smusdCids          : [ContractId CantonSMUSD]  -- sMUSD positions from loops
    requestedLoops     : Int                -- Number of loops requested
    configCid          : ContractId CantonLoopStrategyConfig
    openedAt           : Time               -- Position open timestamp
    lastUpdated        : Time               -- Last interaction timestamp
    privacyObservers   : [Party]            -- Opt-in transparency
  where
    signatory operator, user
    observer privacyObservers

    ensure totalDeposited > 0.0

    -- | Update observers from user's privacy settings
    choice LoopPosition_UpdateObservers : ContractId CantonLoopPosition
      with
        newObservers : [Party]
      controller user
      do create this with privacyObservers = newObservers

    -- | Record a completed loop iteration (operator only).
    choice LoopPosition_RecordLoop : ContractId CantonLoopPosition
      with
        musdMinted   : Money
        musdStaked   : Money
        musdBorrowed : Money
        newSmusdCid  : ContractId CantonSMUSD
        newLeverage  : Money
      controller operator
      do
        assertMsg "NOT_ACTIVE" (status == "active")
        assertMsg "MAX_LOOPS_REACHED" (loopsCompleted < requestedLoops)
        let newTotalStaked = totalStaked + musdStaked
        let newTotalBorrowed = totalBorrowed + musdBorrowed
        -- Health factor check: (staked x targetLTV) / borrowed >= minHF
        when (newTotalBorrowed > 0.0) do
          let hf = (newTotalStaked * intToNumeric config.targetLtvBps / 10000.0) / newTotalBorrowed
          assertMsg "HEALTH_FACTOR_TOO_LOW" (hf >= intToNumeric config.minHealthFactorBps / 10000.0)
        now <- getTime
        create this with
          loopsCompleted = loopsCompleted + 1
          totalStaked = newTotalStaked
          totalBorrowed = newTotalBorrowed
          leverageMultiplier = newLeverage
          smusdCids = smusdCids ++ [newSmusdCid]
          lastUpdated = now

    -- | Initiate position unwind (user only). Sets status to "unwinding".
    choice LoopPosition_Unwind : (ContractId CantonLoopPosition, ContractId CantonUnwindRequest)
      controller user
      do
        assertMsg "NOT_ACTIVE" (status == "active")
        now <- getTime
        unwindingPosCid <- create this with
          status = "unwinding"
          lastUpdated = now
        unwindReqCid <- create CantonUnwindRequest with
          operator
          user
          positionCid = unwindingPosCid
          totalBorrowed
          loopsCompleted
          totalDeposited
        return (unwindingPosCid, unwindReqCid)

-- ============================================================
--                     SECTION 2: LOOP STRATEGY SERVICE
-- ============================================================

-- | Canton loop strategy service -- manages leveraged positions.
-- All choices are compliance-gated via ComplianceRegistry.
template CantonLoopStrategyService
  with
    operator               : Party
    -- Strategy parameters
    maxLoops               : Int            -- Maximum number of leverage loops (e.g., 10)
    maxLeverageX10         : Int            -- Max leverage x 10 (e.g., 30 = 3.0x)
    minBorrowPerLoop       : Money          -- Minimum borrow per loop iteration
    totalPositions         : Int            -- Count of active positions
    totalCollateralLocked  : Money          -- Aggregate collateral across all positions
    totalDebtIssued        : Money          -- Aggregate debt across all positions
    -- Fees
    entryFeeBps            : Bps            -- Fee on initial deposit (default 0)
    exitFeeBps             : Bps            -- Fee on position close (default 25 = 0.25%)
    protocolFeesAccrued    : Money          -- Accumulated protocol fees
    -- State
    paused                 : Bool
    -- H-04: Mandatory compliance
    complianceRegistryCid  : ContractId ComplianceRegistry
    lendingServiceCid      : ContractId CantonLendingService
    serviceName            : Text
    observers              : [Party]
  where
    signatory operator
    observer observers

    key (operator, serviceName) : (Party, Text)
    maintainer key._1

    ensure maxLoops > 0 && maxLoops <= 20
        && maxLeverageX10 >= 10 && maxLeverageX10 <= 40
        && minBorrowPerLoop > 0.0
        && totalPositions >= 0
        && totalCollateralLocked >= 0.0
        && totalDebtIssued >= 0.0
        && entryFeeBps >= 0 && entryFeeBps <= 500
        && exitFeeBps >= 0 && exitFeeBps <= 500
        && protocolFeesAccrued >= 0.0

    -- | Open a new leveraged loop position via service.
    choice Loop_Open : (ContractId CantonLoopStrategyService, ContractId CantonLoopPosition)
      with
        user              : Party
        depositAmount     : Money
        requestedLoops    : Int
        loopConfigCid     : ContractId CantonLoopStrategyConfig
      controller user
      do
        assertMsg "STRATEGY_PAUSED" (not paused)
        assertMsg "TOO_MANY_LOOPS" (requestedLoops > 0 && requestedLoops <= maxLoops)
        assertMsg "DEPOSIT_POSITIVE" (depositAmount > 0.0)

        exercise complianceRegistryCid ValidateMint
          with minter = user

        now <- getTime

        let entryFee = depositAmount * intToNumeric entryFeeBps / 10000.0
        let netDeposit = depositAmount - entryFee

        posCid <- create CantonLoopPosition with
          operator
          user
          strategy = SMUSDMaxiLoop
          config = defaultLoopConfig
          totalDeposited = netDeposit
          loopsCompleted = 0
          totalStaked = 0.0
          totalBorrowed = 0.0
          leverageMultiplier = 1.0
          status = "active"
          smusdCids = []
          requestedLoops
          configCid = loopConfigCid
          openedAt = now
          lastUpdated = now
          privacyObservers = []

        svcCid <- create this with
          totalPositions = totalPositions + 1
          totalCollateralLocked = totalCollateralLocked + netDeposit
          protocolFeesAccrued = protocolFeesAccrued + entryFee

        return (svcCid, posCid)

    -- | Close an existing leveraged position.
    choice Loop_Close : ContractId CantonLoopStrategyService
      with
        user       : Party
        positionCid : ContractId CantonLoopPosition
      controller user
      do
        assertMsg "STRATEGY_PAUSED" (not paused)

        exercise complianceRegistryCid ValidateRedemption
          with redeemer = user

        pos <- fetch positionCid
        assertMsg "NOT_POSITION_OWNER" (pos.user == user)
        assertMsg "POSITION_OPERATOR_MISMATCH" (pos.operator == operator)

        archive positionCid

        let remainder = pos.totalDeposited - pos.totalBorrowed
        let exitFee = remainder * intToNumeric exitFeeBps / 10000.0

        create this with
          totalPositions = totalPositions - 1
          totalCollateralLocked = totalCollateralLocked - pos.totalDeposited
          totalDebtIssued = totalDebtIssued - pos.totalBorrowed
          protocolFeesAccrued = protocolFeesAccrued + exitFee

    -- | Emergency close a user's position (admin only).
    choice Loop_EmergencyClose : ContractId CantonLoopStrategyService
      with
        positionCid : ContractId CantonLoopPosition
      controller operator
      do
        pos <- fetch positionCid
        archive positionCid

        create this with
          totalPositions = totalPositions - 1
          totalCollateralLocked = totalCollateralLocked - pos.totalDeposited
          totalDebtIssued = totalDebtIssued - pos.totalBorrowed

    -- | Update strategy parameters (operator only).
    choice Loop_UpdateParams : ContractId CantonLoopStrategyService
      with
        newMaxLoops        : Int
        newMaxLeverageX10  : Int
        newMinBorrowPerLoop : Money
      controller operator
      do
        assertMsg "INVALID_MAX_LOOPS" (newMaxLoops > 0 && newMaxLoops <= 20)
        assertMsg "INVALID_MAX_LEVERAGE" (newMaxLeverageX10 >= 10 && newMaxLeverageX10 <= 40)
        assertMsg "INVALID_MIN_BORROW" (newMinBorrowPerLoop > 0.0)

        create this with
          maxLoops = newMaxLoops
          maxLeverageX10 = newMaxLeverageX10
          minBorrowPerLoop = newMinBorrowPerLoop

    -- | Pause/unpause the strategy.
    choice Loop_SetPaused : ContractId CantonLoopStrategyService
      with
        newPaused : Bool
      controller operator
      do create this with paused = newPaused

    -- | Withdraw accumulated protocol fees.
    choice Loop_WithdrawFees : ContractId CantonLoopStrategyService
      with
        amount : Money
      controller operator
      do
        assertMsg "INSUFFICIENT_FEES" (amount <= protocolFeesAccrued)
        create this with protocolFeesAccrued = protocolFeesAccrued - amount

-- ============================================================
--                     SECTION 3: GOVERNANCE CONFIG
-- ============================================================

-- | Governance-controlled loop strategy configuration.
template CantonLoopStrategyConfig
  with
    operator              : Party
    config                : LoopConfig
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    observers             : [Party]
  where
    signatory operator
    observer observers

    choice LoopConfig_UpdateMaxLoops : ContractId CantonLoopStrategyConfig
      with
        newMaxLoops : Int
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- fetch governanceProofCid
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "WRONG_MODULE" (proof.targetModule == "CantonLoopStrategy")
        assertMsg "MAX_LOOPS_TOO_HIGH" (newMaxLoops >= 1 && newMaxLoops <= 10)
        archive governanceProofCid
        create this with config = config with maxLoops = newMaxLoops

    choice LoopConfig_UpdateTargetLtv : ContractId CantonLoopStrategyConfig
      with
        newTargetLtvBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- fetch governanceProofCid
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "WRONG_MODULE" (proof.targetModule == "CantonLoopStrategy")
        assertMsg "TARGET_LTV_TOO_HIGH" (newTargetLtvBps >= 5000 && newTargetLtvBps <= 9500)
        archive governanceProofCid
        create this with config = config with targetLtvBps = newTargetLtvBps

    choice LoopConfig_UpdateMinHealthFactor : ContractId CantonLoopStrategyConfig
      with
        newMinHealthFactorBps : Bps
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- fetch governanceProofCid
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "WRONG_MODULE" (proof.targetModule == "CantonLoopStrategy")
        assertMsg "MIN_HF_TOO_LOW" (newMinHealthFactorBps >= 11000)
        archive governanceProofCid
        create this with config = config with minHealthFactorBps = newMinHealthFactorBps

    choice LoopConfig_SetComplianceRegistry : ContractId CantonLoopStrategyConfig
      with
        newComplianceRegistryCid : Optional (ContractId ComplianceRegistry)
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- fetch governanceProofCid
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "WRONG_MODULE" (proof.targetModule == "CantonLoopStrategy")
        archive governanceProofCid
        create this with complianceRegistryCid = newComplianceRegistryCid

-- ============================================================
--                     SECTION 4: LOOP REQUEST
-- ============================================================

-- | Request to open a new leveraged loop position.
template CantonLoopRequest
  with
    operator       : Party
    user           : Party
    strategy       : LoopStrategy
    config         : LoopConfig
    initialUsdcCid : ContractId CantonUSDC
    initialAmount  : Money
    requestedLoops : Int
    requestedAt    : Time
    configCid      : ContractId CantonLoopStrategyConfig
  where
    signatory operator, user
    ensure initialAmount > 0.0 && requestedLoops >= 1

    -- | Execute the loop request: compliance check, consume USDC, create position.
    choice LoopRequest_Execute : ContractId CantonLoopPosition
      controller operator
      do
        -- Compliance check from config
        cfg <- fetch configCid
        case cfg.complianceRegistryCid of
          Some regCid -> exercise regCid ValidateMint with minter = user
          None -> pure ()
        -- Archive the USDC (deposited into strategy)
        archive initialUsdcCid
        now <- getTime
        create CantonLoopPosition with
          operator
          user
          strategy
          config
          totalDeposited = initialAmount
          loopsCompleted = 0
          totalStaked = 0.0
          totalBorrowed = 0.0
          leverageMultiplier = 1.0
          status = "active"
          smusdCids = []
          requestedLoops
          configCid
          openedAt = now
          lastUpdated = now
          privacyObservers = []

    -- | Cancel the request (user keeps USDC).
    choice LoopRequest_Cancel : ()
      controller user
      do pure ()

-- ============================================================
--                     SECTION 5: UNWIND REQUEST
-- ============================================================

-- | Request to unwind a leveraged loop position.
template CantonUnwindRequest
  with
    operator       : Party
    user           : Party
    positionCid    : ContractId CantonLoopPosition
    totalBorrowed  : Money
    loopsCompleted : Int
    totalDeposited : Money
  where
    signatory operator, user

    -- | Execute the unwind: validate, archive sMUSD/mUSD, return USDC.
    choice UnwindRequest_Execute : ContractId CantonUSDC
      with
        usdcReturned   : Money
        smusdToArchive : [ContractId CantonSMUSD]
        musdToBurn     : Optional (ContractId CantonMUSD)
        configCid      : ContractId CantonLoopStrategyConfig
      controller operator
      do
        -- Compliance check from config
        cfg <- fetch configCid
        case cfg.complianceRegistryCid of
          Some regCid -> exercise regCid ValidateRedemption with redeemer = user
          None -> pure ()
        -- Validate sMUSD count matches loops completed
        assertMsg "SMUSD_COUNT_MISMATCH" (length smusdToArchive == loopsCompleted)
        -- Validate mUSD burn required when debt exists
        when (totalBorrowed > 0.0) do
          assertMsg "MUSD_BURN_REQUIRED" (isSome musdToBurn)
        -- Validate minimum return floor (10% of original deposit)
        let minReturn = totalDeposited * 0.1
        assertMsg "RETURN_BELOW_MINIMUM" (usdcReturned >= minReturn)
        -- Archive sMUSD positions
        _ <- mapA archive smusdToArchive
        -- Burn mUSD if provided
        case musdToBurn of
          Some musdCid -> archive musdCid
          None -> pure ()
        -- Archive the unwinding position
        archive positionCid
        -- Return USDC to user
        create CantonUSDC with
          issuer = operator
          owner = user
          amount = usdcReturned
          privacyObservers = []

    -- | Cancel the unwind: restore position to active.
    choice UnwindRequest_Cancel : ContractId CantonLoopPosition
      controller user
      do
        pos <- fetch positionCid
        archive positionCid
        now <- getTime
        create pos with
          status = "active"
          lastUpdated = now

-- ============================================================
--                     SECTION 6: PURE CALCULATIONS
-- ============================================================

-- | Calculate effective leverage for N loops at a given LTV ratio.
-- Uses geometric sum: 1 + ltv + ltv^2 + ... + ltv^(n-1)
calculateLeverage : Money -> Int -> Money
calculateLeverage _ numLoops | numLoops <= 1 = 1.0
calculateLeverage ltvRatio numLoops =
  fst (foldl (\(acc, power) _ -> (acc + power * ltvRatio, power * ltvRatio)) (1.0, 1.0) [1..numLoops - 1])

-- | Calculate net APY: stakingAPY x leverage - borrowAPY x (leverage - 1)
calculateNetAPY : Money -> Money -> Money -> Money
calculateNetAPY stakingAPY borrowAPY leverage =
  stakingAPY * leverage - borrowAPY * (leverage - 1.0)

-- | Calculate health factor: (stakedValue x threshold%) / debtValue
-- Returns 999.0 when debt is zero.
calculateHealthFactor : Money -> Bps -> Money -> Money
calculateHealthFactor stakedValue thresholdBps debtValue
  | debtValue == 0.0 = 999.0
  | otherwise = (stakedValue * intToNumeric thresholdBps / 10000.0) / debtValue

-- | Estimate strategy outcomes for given parameters.
estimateStrategy : LoopStrategy -> LoopConfig -> Money -> Int -> Money -> Money -> StrategyEstimate
estimateStrategy _strategy config depositAmount numLoops stakingAPY borrowAPY =
  let leverage = calculateLeverage (intToNumeric config.targetLtvBps / 10000.0) numLoops
      netAPY = calculateNetAPY stakingAPY borrowAPY leverage
      totalStaked = depositAmount * leverage
      totalBorrowedEst = totalStaked - depositAmount
      healthFactor = calculateHealthFactor totalStaked config.targetLtvBps totalBorrowedEst
  in StrategyEstimate with ..
