-- | CantonSMUSD
-- Canton-side staked mUSD (smUSD) with UNIFIED yield from Ethereum
--
-- Architecture:
--   smUSD yield on Canton uses a GLOBAL share price synchronized from Ethereum.
--   This ensures equal yield distribution across both chains.
--
--   UNIFIED share price model:
--     globalSharePrice = TreasuryV2.totalValue() / (ethShares + cantonShares)
--
--   When Ethereum Treasury generates yield:
--     1. YieldSyncService calculates global share price on Ethereum
--     2. Multiple attestors independently submit attestations via SharePriceAttestation
--     3. SyncGlobalSharePrice requires quorum of matching attestations (DAML-R01 FIX)
--     4. All smUSD holders on both chains benefit equally
--     5. Users unstake at global share price → same yield rate everywhere

module CantonSMUSD where

import DA.Time
import DA.List (length, dedup, sort, (!!))
import DA.Foldable (forA_)
import CantonDirectMint (CantonMUSD(..), CantonMUSD_Burn(..), Money)
import UserPrivacySettings (lookupUserObservers)
import Governance (GovernanceActionLog(..), ActionType(..), ConsumeProof(..))
import Compliance (ComplianceRegistry, ValidateTransfer(..))

-- ============================================================
--                     SECTION 1: STAKED mUSD POSITION
-- ============================================================

-- | Individual smUSD position.
-- Represents a user's share in the yield vault.
-- Amount is in "shares" — redeemable for mUSD at current share price.
-- FIX D-M01: Added stakedAt timestamp for cooldown enforcement
template CantonSMUSD
  with
    issuer : Party
    owner : Party
    shares : Money          -- Number of shares (not mUSD amount)
    entrySharePrice : Money -- Share price when staked (for tracking)
    stakedAt : Time         -- FIX D-M01: Timestamp when staked (for cooldown)
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure shares > 0.0

    -- | Update observers from user's privacy settings
    choice SMUSD_UpdateObservers : ContractId CantonSMUSD
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    -- FIX DL-C2: Use proposal pattern for safe dual-signatory transfers
    choice SMUSD_Transfer : ContractId CantonSMUSDTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create CantonSMUSDTransferProposal with
          smusd = this
          newOwner

    choice SMUSD_Split : (ContractId CantonSMUSD, ContractId CantonSMUSD)
      with
        splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_SHARES_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_SHARES_LESS_THAN_TOTAL" (splitShares < shares)
        c1 <- create this with shares = splitShares
        c2 <- create this with shares = shares - splitShares
        return (c1, c2)

    choice SMUSD_Merge : ContractId CantonSMUSD
      with
        otherCid : ContractId CantonSMUSD
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        archive otherCid
        -- FIX HIGH-02: Use the MORE RECENT stakedAt to prevent cooldown bypass.
        -- Without this, a user could merge recently-staked shares into an older position
        -- to inherit the older stakedAt and bypass the cooldown period.
        let mergedStakedAt = if other.stakedAt > stakedAt then other.stakedAt else stakedAt
        create this with
          shares = shares + other.shares
          stakedAt = mergedStakedAt

-- | FIX DL-C2: Transfer proposal for CantonSMUSD (dual-signatory safe)
-- Prevents forced signatory obligations on unwitting recipients
template CantonSMUSDTransferProposal
  with
    smusd : CantonSMUSD
    newOwner : Party
  where
    signatory smusd.issuer, smusd.owner
    observer newOwner

    choice CantonSMUSDTransferProposal_Accept : ContractId CantonSMUSD
      controller newOwner
      do create smusd with owner = newOwner

    choice CantonSMUSDTransferProposal_Reject : ContractId CantonSMUSD
      controller newOwner
      do create smusd

    choice CantonSMUSDTransferProposal_Cancel : ContractId CantonSMUSD
      controller smusd.owner
      do create smusd

-- ============================================================
--                     SECTION 1b: SHARE PRICE ATTESTATION (FIX DAML-R01)
-- ============================================================

-- | SharePriceAttestation — Independent attestation of cross-chain share price.
-- FIX DAML-R01: Instead of trusting a single relay operator to sync share prices,
-- we require multiple independent attestors (validators) to submit matching
-- attestations before the price is accepted. This eliminates the single-relay
-- trust boundary.
--
-- Flow:
--   1. Each attestor independently reads TreasuryV2.totalValue() from Ethereum
--   2. Each submits a SharePriceAttestation on Canton
--   3. SyncGlobalSharePrice collects attestation CIDs and requires:
--      a) At least `minAttestors` unique attestations
--      b) All attested prices within `maxAttestationDeviationBps` of each other
--      c) Governance proof (existing requirement)
--   4. The median price from attestations is used as the synced value
template SharePriceAttestation
  with
    attestor    : Party        -- The validator/relay submitting this attestation
    operator    : Party        -- Protocol operator (observer)
    epochNumber : Int          -- Which sync epoch this attests to
    attestedSharePrice   : Money   -- Share price this attestor observed
    attestedTotalAssets  : Money   -- Total assets this attestor observed
    attestedTotalShares  : Money   -- Total shares this attestor observed
    attestedAt  : Time         -- When attestation was created
  where
    signatory attestor
    observer operator

    ensure attestedSharePrice > 0.0
        && attestedTotalAssets >= 0.0
        && attestedTotalShares >= 0.0
        && epochNumber > 0

    -- | Operator consumes attestation after using it in sync
    choice ConsumeAttestation : SharePriceAttestation
      controller operator
      do return this

-- ============================================================
--                     SECTION 2: STAKING SERVICE
-- ============================================================

-- | Canton smUSD staking service with UNIFIED cross-chain yield.
-- Uses global share price synced from Ethereum for equal yield distribution.
-- FIX DAML-R01: Requires multi-attestor quorum for share price syncs.
template CantonStakingService
  with
    operator : Party
    totalShares : Money         -- Total smUSD shares on Canton
    -- UNIFIED YIELD: Global share price from Ethereum (includes all chains)
    globalSharePrice : Money    -- Synced from Ethereum: globalAssets / globalShares
    globalTotalAssets : Money   -- Total assets backing all shares (both chains)
    globalTotalShares : Money   -- Total shares across both chains
    lastSyncEpoch : Int         -- Last synced epoch from Ethereum
    cooldownSeconds : Int       -- Minimum stake duration before unstake
    minDeposit : Money          -- Minimum mUSD deposit
    paused : Bool
    -- FIX DAML-012: Track mUSD minted during unstake for supply cap enforcement
    unstakeMintedTotal : Money    -- Cumulative mUSD minted via unstake
    unstakeMintCap : Money        -- Maximum mUSD mintable via unstake before governance reset
    -- FIX DAML-R01: Multi-attestor configuration
    authorizedAttestors : [Party]         -- Parties allowed to submit attestations
    minAttestors : Int                    -- Minimum attestations required for sync (quorum)
    maxAttestationDeviationBps : Int      -- Max allowed deviation between attestors (e.g. 100 = 1%)
    -- Compliance integration
    complianceRegistryCid : Optional (ContractId ComplianceRegistry)
    -- Master Participation Agreement (passed through to minted CantonMUSD on unstake)
    mpaHash : Text
    mpaUri : Text
    observers : [Party]         -- Users who can exercise Stake/Unstake
  where
    signatory operator
    observer observers ++ authorizedAttestors

    ensure totalShares >= 0.0 && globalSharePrice > 0.0
        && unstakeMintedTotal >= 0.0  -- FIX DAML-012
        && unstakeMintCap > 0.0       -- FIX DAML-012
        && minAttestors > 0
        && DA.List.length authorizedAttestors >= minAttestors
        && maxAttestationDeviationBps > 0

    -- | Current share price: uses GLOBAL share price for unified yield
    nonconsuming choice GetSharePrice : Money
      controller operator
      do
        return globalSharePrice

    -- | Stake: mUSD → smUSD shares at GLOBAL share price
    -- User deposits mUSD, receives shares at the unified global share price
    choice Stake : (ContractId CantonStakingService, ContractId CantonSMUSD)
      with
        user : Party
        musdCid : ContractId CantonMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- FIX D-H5: Compliance check before staking
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = user; receiver = operator
          None -> pure ()

        musd <- fetch musdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_DEPOSIT" (musd.amount >= minDeposit)

        -- Calculate shares using GLOBAL share price
        let newShares = musd.amount / globalSharePrice

        -- Lock the mUSD (burn from user, add to pool)
        exercise musdCid CantonMUSD_Burn

        -- Issue smUSD shares
        -- FIX D-M01: Record staked timestamp for cooldown enforcement
        now <- getTime
        userObs <- lookupUserObservers operator user
        smusdCid <- create CantonSMUSD with
          issuer = operator
          owner = user
          shares = newShares
          entrySharePrice = globalSharePrice
          stakedAt = now
          privacyObservers = userObs

        -- Update pool state (local shares only - global sync happens via bridge)
        newService <- create this with
          totalShares = totalShares + newShares

        return (newService, smusdCid)

    -- | Unstake: smUSD shares → mUSD at GLOBAL share price
    -- User redeems shares at the unified global share price (includes all yield)
    -- FIX D-M01: Enforce cooldown period symmetry with Solidity's 24h unstake cooldown
    choice Unstake : (ContractId CantonStakingService, ContractId CantonMUSD)
      with
        user : Party
        smusdCid : ContractId CantonSMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- FIX D-H5: Compliance check before unstaking
        case complianceRegistryCid of
          Some crCid -> exercise crCid ValidateTransfer with sender = operator; receiver = user
          None -> pure ()

        smusd <- fetch smusdCid
        assertMsg "OWNER_MISMATCH" (smusd.owner == user)

        -- FIX D-M01: Enforce cooldown period before allowing unstake
        now <- getTime
        let cooldownRel = seconds cooldownSeconds
        let elapsed = subTime now smusd.stakedAt
        assertMsg "COOLDOWN_NOT_ELAPSED" (elapsed >= cooldownRel)

        -- Calculate mUSD value using GLOBAL share price
        let musdAmount = smusd.shares * globalSharePrice

        -- FIX DAML-012: Enforce unstake mint supply cap to prevent unbounded mUSD minting.
        -- Tracks cumulative mUSD minted via unstake and caps it.
        -- The cap can be reset by governance via Staking_ResetUnstakeMintCounter.
        assertMsg "UNSTAKE_SHARES_EXCEED_TOTAL" (smusd.shares <= totalShares)
        assertMsg "UNSTAKE_MINT_CAP_EXCEEDED" (unstakeMintedTotal + musdAmount <= unstakeMintCap)

        -- Burn smUSD shares
        archive smusdCid

        -- Mint mUSD to user (at global share price — includes cross-chain yield)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = musdAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        -- Update pool state
        -- FIX DAML-012: Track cumulative mUSD minted via unstake for supply cap enforcement
        newService <- create this with
          totalShares = totalShares - smusd.shares
          unstakeMintedTotal = unstakeMintedTotal + musdAmount

        return (newService, musdCid)

    -- | Sync global share price from Ethereum (replaces old SyncYield)
    -- Called by operator after multiple attestors independently submit share price attestations.
    -- FIX D-H3: Governance-gated admin choice
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    -- FIX DAML-R01: Requires quorum of independent attestations with price agreement
    choice SyncGlobalSharePrice : ContractId CantonStakingService
      with
        attestationCids : [ContractId SharePriceAttestation]  -- FIX DAML-R01: attestation proofs
        epochNumber : Int             -- Must be sequential
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastSyncEpoch)

        -- FIX DAML-R01: Require minimum number of attestations (quorum)
        let numAttestations = DA.List.length attestationCids
        assertMsg "INSUFFICIENT_ATTESTATIONS" (numAttestations >= minAttestors)

        -- FIX DAML-R01: Consume all attestations, verify each one
        attestations <- mapA (\cid -> exercise cid ConsumeAttestation) attestationCids

        -- Verify all attestations are for this epoch
        forA_ attestations $ \a ->
          assertMsg "ATTESTATION_EPOCH_MISMATCH" (a.epochNumber == epochNumber)

        -- Verify all attestors are authorized and unique
        let attestorParties = map (\a -> a.attestor) attestations
        let uniqueAttestors = dedup attestorParties
        assertMsg "DUPLICATE_ATTESTORS" (DA.List.length uniqueAttestors == numAttestations)
        forA_ uniqueAttestors $ \p ->
          assertMsg "UNAUTHORIZED_ATTESTOR" (p `elem` authorizedAttestors)

        -- FIX DAML-R01: Verify all attested prices are within deviation tolerance
        let prices = map (\a -> a.attestedSharePrice) attestations
        let maxPrice = foldl max 0.0 prices
        let minPrice = foldl min maxPrice prices
        let deviationBps = if minPrice > 0.0
              then ((maxPrice - minPrice) / minPrice) * 10000.0
              else 0.0
        assertMsg "ATTESTATION_PRICE_DEVIATION_TOO_LARGE" (deviationBps <= intToNumeric maxAttestationDeviationBps)

        -- FIX DAML-R01: Use median price from attestations (not operator-supplied)
        let sortedPrices = sort prices
        let mid = DA.List.length sortedPrices / 2
        let medianPrice = sortedPrices !! mid

        -- FIX D-M05: Allow share price decrease for slashing/loss events, but cap at 10% max decrease
        let minAllowedPrice = globalSharePrice * 0.9
        assertMsg "SHARE_PRICE_DECREASE_TOO_LARGE" (medianPrice >= minAllowedPrice)
        assertMsg "SHARE_PRICE_MUST_BE_POSITIVE" (medianPrice > 0.0)

        -- Use median values from attestations for total assets/shares
        let sortedAssets = sort (map (\a -> a.attestedTotalAssets) attestations)
        let medianAssets = sortedAssets !! mid
        let sortedShares = sort (map (\a -> a.attestedTotalShares) attestations)
        let medianShares = sortedShares !! mid

        create this with
          globalSharePrice = medianPrice
          globalTotalAssets = medianAssets
          globalTotalShares = medianShares
          lastSyncEpoch = epochNumber

    -- | Legacy SyncYield for backwards compatibility (deprecated)
    -- FIX D-H3: Governance-gated admin choice
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    -- FIX DAML-C04: Added same guards as SyncGlobalSharePrice (10% decrease cap, positivity)
    choice SyncYield : ContractId CantonStakingService
      with
        newTotalTreasuryAssets : Money
        yieldAccrued : Money
        epochNumber : Int
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastSyncEpoch)
        -- Convert to global share price model
        let newSharePrice = if globalTotalShares > 0.0
              then newTotalTreasuryAssets / globalTotalShares
              else globalSharePrice
        -- FIX DAML-C04: Apply same safety guards as SyncGlobalSharePrice
        assertMsg "SHARE_PRICE_MUST_BE_POSITIVE" (newSharePrice > 0.0)
        let minAllowedPrice = globalSharePrice * 0.9
        assertMsg "SHARE_PRICE_DECREASE_TOO_LARGE" (newSharePrice >= minAllowedPrice)
        create this with
          globalSharePrice = newSharePrice
          globalTotalAssets = newTotalTreasuryAssets
          lastSyncEpoch = epochNumber

    -- | Admin: Pause/unpause
    -- FIX D-H3: Governance-gated admin choice
    -- FIX DAML-D1: Converted to consuming (was nonconsuming+archive-self)
    choice Staking_SetPaused : ContractId CantonStakingService
      with
        newPaused : Bool
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        -- FIX DAML-S1: Consume proof after use (prevents replay)
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == EmergencyPause)
        create this with paused = newPaused

    -- FIX DAML-012: Governance-gated reset of unstake mint counter
    -- Allows governance to reset the cumulative unstake mint counter when needed
    choice Staking_ResetUnstakeMintCounter : ContractId CantonStakingService
      with
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        create this with unstakeMintedTotal = 0.0

    -- FIX DAML-012: Governance-gated update of unstake mint cap
    choice Staking_UpdateUnstakeMintCap : ContractId CantonStakingService
      with
        newCap : Money
        governanceProofCid : ContractId GovernanceActionLog
      controller operator
      do
        proof <- exercise governanceProofCid ConsumeProof
        assertMsg "WRONG_ACTION_TYPE" (proof.actionType == ParameterUpdate)
        assertMsg "CAP_MUST_BE_POSITIVE" (newCap > 0.0)
        create this with unstakeMintCap = newCap
