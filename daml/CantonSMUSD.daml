-- | CantonSMUSD
-- Canton-side staked mUSD (smUSD) with UNIFIED yield from Ethereum
--
-- Architecture:
--   smUSD yield on Canton uses a GLOBAL share price synchronized from Ethereum.
--   This ensures equal yield distribution across both chains.
--
--   UNIFIED share price model:
--     globalSharePrice = TreasuryV2.totalValue() / (ethShares + cantonShares)
--
--   When Ethereum Treasury generates yield:
--     1. YieldSyncService calculates global share price on Ethereum
--     2. Global share price is synced to Canton via SyncGlobalSharePrice
--     3. All smUSD holders on both chains benefit equally
--     4. Users unstake at global share price → same yield rate everywhere

module CantonSMUSD where

import DA.Time
import CantonDirectMint (CantonMUSD(..), CantonMUSD_Burn(..), Money)
import UserPrivacySettings (lookupUserObservers)
import Compliance (ComplianceRegistry(..), ValidateMint(..), ValidateRedemption(..))

-- ============================================================
--                     SECTION 1: STAKED mUSD POSITION
-- ============================================================

-- | Individual smUSD position.
-- Represents a user's share in the yield vault.
-- Amount is in "shares" — redeemable for mUSD at current share price.
-- FIX D-M01: Added stakedAt timestamp for cooldown enforcement
template CantonSMUSD
  with
    issuer : Party
    owner : Party
    shares : Money          -- Number of shares (not mUSD amount)
    entrySharePrice : Money -- Share price when staked (for tracking)
    stakedAt : Time         -- FIX D-M01: Timestamp when staked (for cooldown)
    privacyObservers : [Party]  -- Opt-in transparency (from UserPrivacySettings)
  where
    signatory issuer, owner
    observer privacyObservers

    ensure shares > 0.0

    -- | Update observers from user's privacy settings
    choice SMUSD_UpdateObservers : ContractId CantonSMUSD
      with
        newObservers : [Party]
      controller owner
      do create this with privacyObservers = newObservers

    -- FIX DL-C2: Use proposal pattern for safe dual-signatory transfers
    choice SMUSD_Transfer : ContractId CantonSMUSDTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create CantonSMUSDTransferProposal with
          smusd = this
          newOwner

    choice SMUSD_Split : (ContractId CantonSMUSD, ContractId CantonSMUSD)
      with
        splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_SHARES_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_SHARES_LESS_THAN_TOTAL" (splitShares < shares)
        c1 <- create this with shares = splitShares
        c2 <- create this with shares = shares - splitShares
        return (c1, c2)

    choice SMUSD_Merge : ContractId CantonSMUSD
      with
        otherCid : ContractId CantonSMUSD
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        archive otherCid
        create this with shares = shares + other.shares

-- | FIX DL-C2: Transfer proposal for CantonSMUSD (dual-signatory safe)
-- Prevents forced signatory obligations on unwitting recipients
template CantonSMUSDTransferProposal
  with
    smusd : CantonSMUSD
    newOwner : Party
  where
    signatory smusd.issuer, smusd.owner
    observer newOwner

    choice CantonSMUSDTransferProposal_Accept : ContractId CantonSMUSD
      controller newOwner
      do create smusd with owner = newOwner

    choice CantonSMUSDTransferProposal_Reject : ContractId CantonSMUSD
      controller newOwner
      do create smusd

    choice CantonSMUSDTransferProposal_Cancel : ContractId CantonSMUSD
      controller smusd.owner
      do create smusd

-- ============================================================
--                     SECTION 2: STAKING SERVICE
-- ============================================================

-- | Canton smUSD staking service with UNIFIED cross-chain yield.
-- Uses global share price synced from Ethereum for equal yield distribution.
template CantonStakingService
  with
    operator : Party
    governance : Party          -- FIX HIGH-07: Governance co-signer for critical operations
    totalShares : Money         -- Total smUSD shares on Canton
    -- UNIFIED YIELD: Global share price from Ethereum (includes all chains)
    globalSharePrice : Money    -- Synced from Ethereum: globalAssets / globalShares
    globalTotalAssets : Money   -- Total assets backing all shares (both chains)
    globalTotalShares : Money   -- Total shares across both chains
    lastSyncEpoch : Int         -- Last synced epoch from Ethereum
    cooldownSeconds : Int       -- Minimum stake duration before unstake
    minDeposit : Money          -- Minimum mUSD deposit
    paused : Bool
    -- DAML-H-04: Mandatory compliance — all stakers must pass blacklist/freeze checks
    complianceRegistryCid : ContractId ComplianceRegistry
    -- Master Participation Agreement (passed through to minted CantonMUSD on unstake)
    mpaHash : Text
    mpaUri : Text
    observers : [Party]         -- Users who can exercise Stake/Unstake
  where
    signatory operator
    observer observers

    ensure totalShares >= 0.0 && globalSharePrice > 0.0

    -- | Current share price: uses GLOBAL share price for unified yield
    nonconsuming choice GetSharePrice : Money
      controller operator
      do
        return globalSharePrice

    -- | Stake: mUSD → smUSD shares at GLOBAL share price
    -- User deposits mUSD, receives shares at the unified global share price
    choice Stake : (ContractId CantonStakingService, ContractId CantonSMUSD)
      with
        user : Party
        musdCid : ContractId CantonMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- DAML-H-04: Mandatory compliance check — staker must not be blacklisted
        exercise complianceRegistryCid ValidateMint with minter = user

        musd <- fetch musdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_DEPOSIT" (musd.amount >= minDeposit)

        -- Calculate shares using GLOBAL share price
        let newShares = musd.amount / globalSharePrice

        -- Lock the mUSD (burn from user, add to pool)
        exercise musdCid CantonMUSD_Burn

        -- Issue smUSD shares
        -- FIX D-M01: Record staked timestamp for cooldown enforcement
        now <- getTime
        userObs <- lookupUserObservers operator user
        smusdCid <- create CantonSMUSD with
          issuer = operator
          owner = user
          shares = newShares
          entrySharePrice = globalSharePrice
          stakedAt = now
          privacyObservers = userObs

        -- Update pool state (local shares only - global sync happens via bridge)
        newService <- create this with
          totalShares = totalShares + newShares

        return (newService, smusdCid)

    -- | Unstake: smUSD shares → mUSD at GLOBAL share price
    -- User redeems shares at the unified global share price (includes all yield)
    -- FIX D-M01: Enforce cooldown period symmetry with Solidity's 24h unstake cooldown
    choice Unstake : (ContractId CantonStakingService, ContractId CantonMUSD)
      with
        user : Party
        smusdCid : ContractId CantonSMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        -- DAML-H-04: Mandatory compliance check — unstaker must not be blacklisted/frozen
        exercise complianceRegistryCid ValidateRedemption with redeemer = user

        smusd <- fetch smusdCid
        assertMsg "OWNER_MISMATCH" (smusd.owner == user)

        -- FIX D-M01: Enforce cooldown period before allowing unstake
        now <- getTime
        let cooldownRel = seconds cooldownSeconds
        let elapsed = subTime now smusd.stakedAt
        assertMsg "COOLDOWN_NOT_ELAPSED" (elapsed >= cooldownRel)

        -- Calculate mUSD value using GLOBAL share price
        let musdAmount = smusd.shares * globalSharePrice

        -- Burn smUSD shares
        archive smusdCid

        -- Mint mUSD to user (at global share price — includes cross-chain yield)
        userObs <- lookupUserObservers operator user
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = musdAmount
          agreementHash = mpaHash
          agreementUri = mpaUri
          privacyObservers = userObs

        -- Update pool state
        newService <- create this with
          totalShares = totalShares - smusd.shares

        return (newService, musdCid)

    -- | Sync global share price from Ethereum (replaces old SyncYield)
    -- Called by operator after YieldSyncService calculates global share price
    -- FIX HIGH-07: Requires governance co-approval — prevents unilateral operator manipulation
    choice SyncGlobalSharePrice : ContractId CantonStakingService
      with
        newGlobalSharePrice : Money   -- Global share price from Ethereum
        newGlobalTotalAssets : Money  -- Total assets across both chains
        newGlobalTotalShares : Money  -- Total shares across both chains
        epochNumber : Int             -- Must be sequential
        attestationHash : Text        -- FIX D-M-02: Validator attestation hash (SHA-256 of price data)
        validatorCount : Int          -- FIX D-M-02: Number of validators who signed this attestation
      controller operator, governance
      do
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastSyncEpoch)
        assertMsg "SHARE_PRICE_MUST_BE_POSITIVE" (newGlobalSharePrice > 0.0)
        -- FIX D-M-02: Require BFT supermajority attestation (at least 3 validators)
        assertMsg "ATTESTATION_HASH_REQUIRED" (attestationHash /= "")
        assertMsg "INSUFFICIENT_VALIDATOR_ATTESTATION" (validatorCount >= 3)
        -- FIX D-M05: Allow share price decrease for slashing/loss events, but cap at 10% max decrease
        let minAllowedPrice = globalSharePrice * 0.9
        assertMsg "SHARE_PRICE_DECREASE_TOO_LARGE" (newGlobalSharePrice >= minAllowedPrice)
        -- FIX D-M09: Cap share price increase at 10% per epoch to prevent manipulation
        let maxAllowedPrice = globalSharePrice * 1.1
        assertMsg "SHARE_PRICE_INCREASE_TOO_LARGE" (newGlobalSharePrice <= maxAllowedPrice)

        create this with
          globalSharePrice = newGlobalSharePrice
          globalTotalAssets = newGlobalTotalAssets
          globalTotalShares = newGlobalTotalShares
          lastSyncEpoch = epochNumber

    -- | Legacy SyncYield for backwards compatibility (deprecated)
    -- FIX C-DAML-03: Require governance co-signature (matches SyncGlobalSharePrice)
    choice SyncYield : ContractId CantonStakingService
      with
        newTotalTreasuryAssets : Money
        yieldAccrued : Money
        epochNumber : Int
      controller operator, governance
      do
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastSyncEpoch)
        -- Convert to global share price model
        let newSharePrice = if globalTotalShares > 0.0
              then newTotalTreasuryAssets / globalTotalShares
              else globalSharePrice
        create this with
          globalSharePrice = newSharePrice
          globalTotalAssets = newTotalTreasuryAssets
          lastSyncEpoch = epochNumber

    -- | Admin: Pause/unpause
    choice Staking_SetPaused : ContractId CantonStakingService
      with
        newPaused : Bool
      controller operator
      do
        create this with paused = newPaused
