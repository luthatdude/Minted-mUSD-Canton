-- | CantonSMUSD
-- Canton-side staked mUSD (smUSD) with yield synchronized from Ethereum
--
-- Architecture:
--   smUSD yield on Canton is synchronized from Ethereum via attestations.
--   The bridge reports total yield, Canton smUSD applies it.
--
--   ERC-4626 equivalent share price model:
--     sharePrice = totalAssets / totalShares
--
--   When Ethereum Treasury generates yield:
--     1. Yield attestation arrives via BLEBridgeProtocol.YieldAttestation
--     2. Operator calls SyncYield with verified payload
--     3. totalAssets increases → sharePrice increases
--     4. Users unstake at new share price → receive more mUSD than deposited

module CantonSMUSD where

import DA.Time
import CantonDirectMint (CantonMUSD(..), CantonMUSD_Burn(..), Money)

-- ============================================================
--                     SECTION 1: STAKED mUSD POSITION
-- ============================================================

-- | Individual smUSD position.
-- Represents a user's share in the yield vault.
-- Amount is in "shares" — redeemable for mUSD at current share price.
-- Yield can be claimed without unstaking via ClaimYield.
template CantonSMUSD
  with
    issuer : Party
    owner : Party
    shares : Money              -- Number of shares (not mUSD amount)
    entrySharePrice : Money     -- Share price when staked (for tracking)
    lastClaimedPrice : Money    -- Share price at last yield claim
  where
    signatory issuer, owner

    ensure shares > 0.0

    -- FIX DL-C2: Use proposal pattern for safe dual-signatory transfers
    choice SMUSD_Transfer : ContractId CantonSMUSDTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create CantonSMUSDTransferProposal with
          smusd = this
          newOwner

    choice SMUSD_Split : (ContractId CantonSMUSD, ContractId CantonSMUSD)
      with
        splitShares : Money
      controller owner
      do
        assertMsg "SPLIT_SHARES_POSITIVE" (splitShares > 0.0)
        assertMsg "SPLIT_SHARES_LESS_THAN_TOTAL" (splitShares < shares)
        c1 <- create this with shares = splitShares
        c2 <- create this with shares = shares - splitShares
        return (c1, c2)

    choice SMUSD_Merge : ContractId CantonSMUSD
      with
        otherCid : ContractId CantonSMUSD
      controller owner
      do
        other <- fetch otherCid
        assertMsg "ISSUER_MISMATCH" (other.issuer == issuer)
        assertMsg "OWNER_MISMATCH" (other.owner == owner)
        archive otherCid
        create this with shares = shares + other.shares

-- | FIX DL-C2: Transfer proposal for CantonSMUSD (dual-signatory safe)
-- Prevents forced signatory obligations on unwitting recipients
template CantonSMUSDTransferProposal
  with
    smusd : CantonSMUSD
    newOwner : Party
  where
    signatory smusd.issuer, smusd.owner
    observer newOwner

    choice CantonSMUSDTransferProposal_Accept : ContractId CantonSMUSD
      controller newOwner
      do create smusd with owner = newOwner

    choice CantonSMUSDTransferProposal_Reject : ContractId CantonSMUSD
      controller newOwner
      do create smusd

    choice CantonSMUSDTransferProposal_Cancel : ContractId CantonSMUSD
      controller smusd.owner
      do create smusd

-- ============================================================
--                     SECTION 2: STAKING SERVICE
-- ============================================================

-- | Canton smUSD staking service.
-- Manages the share price model and yield sync from Ethereum.
template CantonStakingService
  with
    operator : Party
    totalShares : Money         -- Total smUSD shares outstanding
    totalAssets : Money         -- Total mUSD value backing all shares
    lastYieldEpoch : Int        -- Last synced yield epoch from Ethereum
    cooldownSeconds : Int       -- Minimum stake duration before unstake
    minDeposit : Money          -- Minimum mUSD deposit
    paused : Bool
    -- Master Participation Agreement (passed through to minted CantonMUSD on unstake)
    mpaHash : Text
    mpaUri : Text
    observers : [Party]         -- Users who can exercise Stake/Unstake
  where
    signatory operator
    observer observers

    ensure totalShares >= 0.0 && totalAssets >= 0.0

    -- | Current share price: totalAssets / totalShares
    -- Returns 1.0 if no shares exist (initial price)
    nonconsuming choice GetSharePrice : Money
      controller operator
      do
        if totalShares == 0.0
          then return 1.000000000000000000
          else return (totalAssets / totalShares)

    -- | Stake: mUSD → smUSD shares
    -- User deposits mUSD, receives shares at current share price
    choice Stake : (ContractId CantonStakingService, ContractId CantonSMUSD)
      with
        user : Party
        musdCid : ContractId CantonMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        musd <- fetch musdCid
        assertMsg "ISSUER_MISMATCH" (musd.issuer == operator)
        assertMsg "OWNER_MISMATCH" (musd.owner == user)
        assertMsg "BELOW_MIN_DEPOSIT" (musd.amount >= minDeposit)

        -- Calculate shares: amount / sharePrice
        let sharePrice = if totalShares == 0.0
              then 1.000000000000000000
              else totalAssets / totalShares
        let newShares = musd.amount / sharePrice

        -- Lock the mUSD (burn from user, add to pool)
        exercise musdCid CantonMUSD_Burn

        -- Issue smUSD shares (lastClaimedPrice = entry price, no yield yet)
        smusdCid <- create CantonSMUSD with
          issuer = operator
          owner = user
          shares = newShares
          entrySharePrice = sharePrice
          lastClaimedPrice = sharePrice

        -- Update pool state
        newService <- create this with
          totalShares = totalShares + newShares
          totalAssets = totalAssets + musd.amount

        return (newService, smusdCid)

    -- | Unstake: smUSD shares → mUSD
    -- User redeems shares at current share price (which includes yield)
    choice Unstake : (ContractId CantonStakingService, ContractId CantonMUSD)
      with
        user : Party
        smusdCid : ContractId CantonSMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        smusd <- fetch smusdCid
        assertMsg "OWNER_MISMATCH" (smusd.owner == user)

        -- Calculate mUSD value: shares × sharePrice
        let sharePrice = if totalShares == 0.0
              then 1.000000000000000000
              else totalAssets / totalShares
        let musdAmount = smusd.shares * sharePrice

        assertMsg "INSUFFICIENT_POOL_ASSETS" (totalAssets >= musdAmount)

        -- Burn smUSD shares
        archive smusdCid

        -- Mint mUSD to user (at current share price — includes yield)
        musdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = musdAmount
          agreementHash = mpaHash
          agreementUri = mpaUri

        -- Update pool state
        newService <- create this with
          totalShares = totalShares - smusd.shares
          totalAssets = totalAssets - musdAmount

        return (newService, musdCid)

    -- | Claim yield without unstaking.
    -- User keeps their smUSD shares but receives accumulated yield as mUSD.
    -- Yield = shares × (currentSharePrice - lastClaimedPrice)
    choice ClaimYield : (ContractId CantonStakingService, ContractId CantonSMUSD, ContractId CantonMUSD)
      with
        user : Party
        smusdCid : ContractId CantonSMUSD
      controller user
      do
        assertMsg "SERVICE_PAUSED" (not paused)

        smusd <- fetch smusdCid
        assertMsg "OWNER_MISMATCH" (smusd.owner == user)

        -- Calculate current share price
        let currentPrice = if totalShares == 0.0
              then 1.000000000000000000
              else totalAssets / totalShares

        -- Calculate yield since last claim
        let priceDelta = currentPrice - smusd.lastClaimedPrice
        assertMsg "NO_YIELD_TO_CLAIM" (priceDelta > 0.0)

        let yieldAmount = smusd.shares * priceDelta
        assertMsg "INSUFFICIENT_POOL_ASSETS" (totalAssets >= yieldAmount)

        -- Update smUSD position with new claimed price (keep shares)
        archive smusdCid
        newSmusdCid <- create smusd with
          lastClaimedPrice = currentPrice

        -- Mint yield as mUSD to user
        yieldMusdCid <- create CantonMUSD with
          issuer = operator
          owner = user
          amount = yieldAmount
          agreementHash = mpaHash
          agreementUri = mpaUri

        -- Reduce pool assets by claimed yield
        newService <- create this with
          totalAssets = totalAssets - yieldAmount

        return (newService, newSmusdCid, yieldMusdCid)

    -- | Sync yield from Ethereum via attestation.
    -- Called by operator after a YieldAttestation is finalized.
    -- Increases totalAssets → increases share price → smUSD holders profit.
    choice SyncYield : ContractId CantonStakingService
      with
        newTotalTreasuryAssets : Money  -- Verified total from YieldAttestation
        yieldAccrued : Money            -- New yield since last sync
        epochNumber : Int               -- Must be sequential
      controller operator
      do
        assertMsg "EPOCH_NOT_SEQUENTIAL" (epochNumber > lastYieldEpoch)
        assertMsg "YIELD_MUST_BE_NONNEG" (yieldAccrued >= 0.0)

        -- Increase total assets by the yield amount
        -- This raises the share price for all smUSD holders
        create this with
          totalAssets = totalAssets + yieldAccrued
          lastYieldEpoch = epochNumber

    -- | Admin: Pause/unpause
    choice Staking_SetPaused : ContractId CantonStakingService
      with
        newPaused : Bool
      controller operator
      do
        create this with paused = newPaused

-- ============================================================
--                     SECTION 3: YIELD DISTRIBUTION
-- ============================================================

-- | Pending yield claim for a user.
-- Created when yield is auto-distributed, user can claim anytime.
-- This allows yield to be pushed without requiring user to initiate.
template PendingYieldClaim
  with
    operator : Party
    user : Party
    yieldAmount : Money           -- mUSD yield owed
    epochNumber : Int             -- From which yield epoch
    createdAt : Time
    mpaHash : Text
    mpaUri : Text
  where
    signatory operator
    observer user

    ensure yieldAmount > 0.0

    -- User claims their pending yield → gets mUSD
    choice YieldClaim_Collect : ContractId CantonMUSD
      controller user
      do
        create CantonMUSD with
          issuer = operator
          owner = user
          amount = yieldAmount
          agreementHash = mpaHash
          agreementUri = mpaUri

    -- Admin can cancel if needed (e.g., compliance issue)
    choice YieldClaim_Cancel : ()
      controller operator
      do pure ()

-- | Yield distribution request from Ethereum.
-- When ETH Treasury has yield to distribute, a bridge-in brings USDC
-- which backs the mUSD that will be distributed to stakers.
template YieldDistributionRequest
  with
    operator : Party
    totalYieldAmount : Money      -- Total yield to distribute
    epochNumber : Int
    backingBridgedIn : Bool       -- Whether USDC backing has arrived
    createdAt : Time
  where
    signatory operator

    ensure totalYieldAmount > 0.0

    -- Mark backing as received (after bridge-in from Ethereum)
    choice YieldDist_ConfirmBacking : ContractId YieldDistributionRequest
      controller operator
      do
        create this with backingBridgedIn = True

    -- Distribute yield to a specific staker (called per position)
    -- This pushes yield without user action
    choice YieldDist_DistributeToStaker : (ContractId YieldDistributionRequest, ContractId PendingYieldClaim)
      with
        smusdCid : ContractId CantonSMUSD
        stakingServiceCid : ContractId CantonStakingService
        mpaHash : Text
        mpaUri : Text
      controller operator
      do
        assertMsg "BACKING_NOT_BRIDGED" backingBridgedIn

        smusd <- fetch smusdCid
        service <- fetch stakingServiceCid

        -- Calculate this user's share of yield
        let userShareRatio = smusd.shares / service.totalShares
        let userYield = totalYieldAmount * userShareRatio

        now <- getTime
        claimCid <- create PendingYieldClaim with
          operator = operator
          user = smusd.owner
          yieldAmount = userYield
          epochNumber = epochNumber
          createdAt = now
          mpaHash = mpaHash
          mpaUri = mpaUri

        -- Track remaining yield to distribute
        let remainingYield = totalYieldAmount - userYield
        newDistReq <- create this with
          totalYieldAmount = remainingYield

        return (newDistReq, claimCid)
