-- | MUSD_Protocol
-- Full mUSD protocol implementation on Canton/Daml
-- Sections: Asset definitions, Direct minting, Staking/yield, Canton attestation bridge

module MUSD_Protocol where

import DA.Time
import DA.Date
import DA.Action (foldlA)

-- | -----------------------------------------------------------------------------------------
-- | SECTION 1: ASSET DEFINITIONS
-- | -----------------------------------------------------------------------------------------

-- | Represents the external USDC asset (mock representation for the protocol).
-- | In a real scenario, this would likely be a Daml Interface or a Holding contract.
-- FIX H-19: Added ensure clause for positive amounts
template Usdc
  with
    issuer : Party
    owner : Party
    amount : Decimal
  where
    signatory issuer, owner

    -- FIX H-5: Require strictly positive amounts to prevent zero-value contract spam
    ensure amount > 0.0

    -- FIX D-C08: Transfer creates proposal instead of directly assigning signatory
    choice Usdc_Transfer : ContractId UsdcTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create UsdcTransferProposal with
          usdc = this
          newOwner

    choice Usdc_Split : (ContractId Usdc, ContractId Usdc)
      with
        splitAmount : Decimal
      controller owner
      do
        assertMsg "Split amount must be positive" (splitAmount > 0.0)
        assertMsg "Insufficient funds" (amount > splitAmount)
        c1 <- create this with amount = splitAmount
        c2 <- create this with amount = amount - splitAmount
        return (c1, c2)

-- | Represents the mUSD Stablecoin.
-- FIX H-19: Added ensure clause for positive amounts
template Musd
  with
    issuer : Party
    owner : Party
    amount : Decimal
  where
    signatory issuer, owner

    -- FIX H-5: Require strictly positive amounts to prevent zero-value contract spam
    ensure amount > 0.0

    -- FIX D-C09: Transfer creates proposal instead of directly assigning signatory
    choice Musd_Transfer : ContractId MusdTransferProposal
      with
        newOwner : Party
      controller owner
      do
        create MusdTransferProposal with
          musd = this
          newOwner

    choice Musd_Merge : ContractId Musd
      with
        otherCid : ContractId Musd
      controller owner
      do
        other <- fetch otherCid
        assertMsg "Merge: Issuers must match" (other.issuer == issuer)
        assertMsg "Merge: Owners must match" (other.owner == owner)
        archive otherCid
        create this with amount = amount + other.amount

-- FIX D-C08: Transfer proposal for Usdc (dual-signatory safe)
template UsdcTransferProposal
  with
    usdc : Usdc
    newOwner : Party
  where
    signatory usdc.issuer, usdc.owner
    observer newOwner

    choice UsdcTransferProposal_Accept : ContractId Usdc
      controller newOwner
      do create usdc with owner = newOwner

    choice UsdcTransferProposal_Reject : ContractId Usdc
      controller newOwner
      do create usdc

    choice UsdcTransferProposal_Cancel : ContractId Usdc
      controller usdc.owner
      do create usdc

-- FIX D-C09: Transfer proposal for Musd (dual-signatory safe)
template MusdTransferProposal
  with
    musd : Musd
    newOwner : Party
  where
    signatory musd.issuer, musd.owner
    observer newOwner

    choice MusdTransferProposal_Accept : ContractId Musd
      controller newOwner
      do create musd with owner = newOwner

    choice MusdTransferProposal_Reject : ContractId Musd
      controller newOwner
      do create musd

    choice MusdTransferProposal_Cancel : ContractId Musd
      controller musd.owner
      do create musd

-- | Represents the Staked mUSD (sMUSD) which accrues yield.
template Smusd
  with
    issuer : Party
    owner : Party
    amount : Decimal         -- The principal amount
    entryTime : Time         -- When the stake started
    interestRate : Decimal   -- Annual percentage (e.g., 0.05 for 5%)
  where
    signatory issuer, owner
    -- FIX D-H03: Ensure positive amount and non-negative interest rate
    ensure amount > 0.0 && interestRate >= 0.0

-- | -----------------------------------------------------------------------------------------
-- | SECTION 2: DIRECT MINTING (USDC -> mUSD)
-- | -----------------------------------------------------------------------------------------

-- | A service contract provided by the Issuer allowing users to swap USDC for mUSD.
-- | Security Critical: This defines the exchange rate and custody transfer.
-- FIX D-H03: Add supply cap tracking to prevent unbounded minting
template MintingService
  with
    operator : Party       -- The protocol operator/issuer
    usdcIssuer : Party     -- The trusted issuer of USDC
    supplyCap : Decimal    -- Maximum supply allowed
    currentSupply : Decimal -- Current minted supply
  where
    signatory operator
    observer usdcIssuer

    -- FIX D-H03: Consuming choice to track supply cap
    choice Mint_Musd : (ContractId MintingService, ContractId Musd)
      with
        user : Party
        usdcCid : ContractId Usdc
      controller user
      do
        -- 1. Fetch the provided USDC
        usdc <- fetch usdcCid
        -- 2. Validate Inputs
        assertMsg "Mint: Currency mismatch" (usdc.issuer == usdcIssuer)
        assertMsg "Mint: Owner mismatch" (usdc.owner == user)
        assertMsg "Mint: Amount must be positive" (usdc.amount > 0.0)
        -- FIX D-H03: Enforce supply cap
        assertMsg "EXCEEDS_SUPPLY_CAP" (currentSupply + usdc.amount <= supplyCap)
        -- 3. Execute Atomic Swap
        -- Transfer USDC to the Operator (Reserve)
        -- FIX D-C08: Usdc_Transfer returns proposal; accept it
        usdcProposal <- exercise usdcCid Usdc_Transfer with newOwner = operator
        exercise usdcProposal UsdcTransferProposal_Accept
        -- Mint equal amount of mUSD to the User (1:1 Peg)
        musdCid <- create Musd with
          issuer = operator
          owner = user
          amount = usdc.amount
        newService <- create this with currentSupply = currentSupply + usdc.amount
        return (newService, musdCid)

    -- FIX C-05: Burn requires operator-provided USDC reserve CID instead of forging
    nonconsuming choice Burn_Musd : ContractId Usdc
      with
        user : Party
        musdCid : ContractId Musd
        usdcReserveCid : ContractId Usdc
      controller user, operator
      do
        -- 1. Fetch mUSD
        musd <- fetch musdCid
        -- 2. Validate
        assertMsg "Burn: Issuer mismatch" (musd.issuer == operator)
        assertMsg "Burn: Owner mismatch" (musd.owner == user)
        -- 3. Validate USDC reserve
        reserve <- fetch usdcReserveCid
        assertMsg "Burn: Reserve issuer mismatch" (reserve.issuer == usdcIssuer)
        assertMsg "Burn: Reserve owner must be operator" (reserve.owner == operator)
        assertMsg "Burn: Insufficient reserve" (reserve.amount >= musd.amount)
        -- 4. Execute Atomic Swap
        -- Archive the mUSD (Burn)
        archive musdCid
        -- Split reserve if needed, transfer USDC to user
        -- FIX D-C08: Usdc_Transfer returns proposal; accept it
        if reserve.amount == musd.amount
        then do
          usdcProp <- exercise usdcReserveCid Usdc_Transfer with newOwner = user
          exercise usdcProp UsdcTransferProposal_Accept
        else do
          (payout, _) <- exercise usdcReserveCid Usdc_Split with splitAmount = musd.amount
          usdcProp <- exercise payout Usdc_Transfer with newOwner = user
          exercise usdcProp UsdcTransferProposal_Accept

-- | -----------------------------------------------------------------------------------------
-- | SECTION 3: STAKING & YIELD (sMUSD)
-- | -----------------------------------------------------------------------------------------

template StakingService
  with
    operator : Party
    baseRate : Decimal     -- e.g. 0.05
  where
    signatory operator

    nonconsuming choice Stake : ContractId Smusd
      with
        user : Party
        musdCid : ContractId Musd
      controller user
      do
        musd <- fetch musdCid
        assertMsg "Stake: Issuer mismatch" (musd.issuer == operator)
        currentTime <- getTime
        -- Lock/Archive mUSD
        archive musdCid
        -- Issue sMUSD
        create Smusd with
          issuer = operator
          owner = user
          amount = musd.amount
          entryTime = currentTime
          interestRate = baseRate

    nonconsuming choice Unstake : ContractId Musd
      with
        user : Party
        smusdCid : ContractId Smusd
      controller user
      do
        smusd <- fetch smusdCid
        assertMsg "Unstake: Owner mismatch" (smusd.owner == user)
        currentTime <- getTime
        archive smusdCid
        -- Calculate Yield
        -- Formula: Amount * Rate * (TimeDelta in Years)
        -- Note: Daml math with Time requires conversion to microseconds
        let durationMicro = subTime currentTime smusd.entryTime
        let microsecondsPerYear = 31536000000000.0  -- 365 * 24 * 60 * 60 * 1000000
        let durationYears = (intToDecimal (relToInt durationMicro)) / microsecondsPerYear
        let interest = smusd.amount * smusd.interestRate * durationYears
        -- FIX M-15: Cap yield to prevent excessive unbacked minting
        let maxYieldRate = 0.50  -- 50% max annual yield
        let maxInterest = smusd.amount * maxYieldRate * durationYears
        let cappedInterest = if interest > maxInterest then maxInterest else interest
        -- FIX D-M04: Cap total yield at 200% of principal regardless of duration
        let maxTotalYield = smusd.amount * 2.0
        let finalInterest = if cappedInterest > maxTotalYield then maxTotalYield else cappedInterest
        let totalReturn = smusd.amount + finalInterest
        -- Mint mUSD + Yield back to user
        create Musd with
          issuer = operator
          owner = user
          amount = totalReturn

-- | -----------------------------------------------------------------------------------------
-- | SECTION 4: CANTON ATTESTATION FLOW (BRIDGE)
-- | -----------------------------------------------------------------------------------------

-- | Step 1: User locks assets on the source domain to request bridging.
template BridgeLock
  with
    operator : Party        -- Bridge operator
    user : Party            -- User bridging funds
    amount : Decimal
    targetDomainId : Text   -- Where the funds should go
    targetAddress : Text    -- User's address/party on target
    validators : [Party]    -- List of required validators
    nonce : Int             -- Unique ID for this transaction
    lockedAt : Time         -- FIX D-M07: Track lock time for minimum duration
  where
    signatory user, operator
    -- Validates that the lock is active
    observer validators

    -- FIX D-M07: Require minimum lock duration before cancellation
    choice Cancel_BridgeLock : ContractId Musd
      controller user, operator
      do
        now <- getTime
        let minLockDuration = minutes 10
        assertMsg "CANCEL_TOO_EARLY: minimum 10 minute lock" (subTime now lockedAt >= minLockDuration)
        -- Refund mUSD to user since bridge failed
        create Musd with
          issuer = operator
          owner = user
          amount = amount

-- | Service to initiate the bridge lock.
template BridgeService
  with
    operator : Party
    validators : [Party]
  where
    signatory operator
    observer validators

    nonconsuming choice Lock_Musd_For_Bridge : ContractId BridgeLock
      with
        user : Party
        musdCid : ContractId Musd
        targetDomain : Text
        targetAddr : Text
        nonce : Int
      controller user
      do
        musd <- fetch musdCid
        assertMsg "Bridge: Only mUSD can be bridged" (musd.issuer == operator)
        -- Transfer mUSD to operator (Locking mechanism)
        -- Alternatively, we could archive it here if the bridge mints fresh on the other side.
        -- Here we archive to remove from circulation on Source Domain.
        archive musdCid
        now <- getTime
        create BridgeLock with
          operator = operator
          user = user
          amount = musd.amount
          targetDomainId = targetDomain
          targetAddress = targetAddr
          validators = validators
          nonce = nonce
          lockedAt = now

-- | Step 2: Attestation (The Proof).
-- | Validators observe the BridgeLock and create an attestation.
template BridgeAttestation
  with
    validator : Party
    user : Party
    amount : Decimal
    targetDomainId : Text
    nonce : Int
    signature : Text         -- Cryptographic proof (simplified as text here)
  where
    signatory validator
    observer user

-- | Step 3: Redemption / Minting on Target Side.
-- | This contract would exist on the Target Canton domain.
-- | It collects attestations and mints the wrapped token.
template BridgeClaim
  with
    operator : Party
    user : Party
    amount : Decimal
    nonce : Int
    requiredSignatures : Int
    collectedValidators : [Party]
  where
    signatory user, operator

    -- FIX H-11: Archive attestation after use to prevent replay across claims
    choice Add_Attestation : ContractId BridgeClaim
      with
        attestationCid : ContractId BridgeAttestation
      controller user
      do
        att <- fetch attestationCid
        -- Security Checks
        assertMsg "Claim: Invalid Nonce" (att.nonce == nonce)
        assertMsg "Claim: Invalid User" (att.user == user)
        assertMsg "Claim: Amount Mismatch" (att.amount == amount)
        assertMsg "Claim: Validator already signed" (not (elem att.validator collectedValidators))
        -- Archive to prevent reuse
        archive attestationCid
        create this with
          collectedValidators = att.validator :: collectedValidators

    -- Finalize and Mint if threshold met
    -- FIX C-4: Removed invalid empty 'with' block before controller
    choice Finalize_Bridge_Mint : ContractId Musd
      controller user
      do
        assertMsg "Claim: Not enough signatures" (length collectedValidators >= requiredSignatures)
        create Musd with
          issuer = operator
          owner = user
          amount = amount

-- | -----------------------------------------------------------------------------------------
-- | SECTION 5: INITIALIZATION / SETUP SCRIPT
-- | -----------------------------------------------------------------------------------------

-- | Helper to set up the environment
setup : Script ()
setup = do
  -- 1. Allocate Parties
  operator <- allocateParty "Musd_Issuer"
  usdcBank <- allocateParty "Circle_Mock"
  alice <- allocateParty "Alice"
  validator1 <- allocateParty "Validator_1"
  validator2 <- allocateParty "Validator_2"

  -- 2. Issue USDC to Alice
  -- FIX D-H05: Use submitMulti for dual-signatory contract (Usdc has signatory issuer, owner)
  usdcCid <- submitMulti [usdcBank, alice] [] do
    createCmd Usdc with
      issuer = usdcBank
      owner = alice
      amount = 1000.0

  -- 3. Deploy Protocol Services
  mintingSvc <- submit operator do
    createCmd MintingService with
      operator = operator
      usdcIssuer = usdcBank
      supplyCap = 1000000.0
      currentSupply = 0.0

  stakingSvc <- submit operator do
    createCmd StakingService with
      operator = operator
      baseRate = 0.05

  bridgeSvc <- submit operator do
    createCmd BridgeService with
      operator = operator
      validators = [validator1, validator2]

  -- 4. Alice Mints mUSD (Swaps USDC)
  (mintingSvc2, musdCid) <- submit alice do
    exerciseCmd mintingSvc Mint_Musd with
      user = alice
      usdcCid = usdcCid

  -- 5. Alice Stakes mUSD
  smusdCid <- submit alice do
    exerciseCmd stakingSvc Stake with
      user = alice
      musdCid = musdCid

  -- Time passes... (Simulated)
  passTime (days 365)

  -- 6. Alice Unstakes (Gets Yield)
  finalMusd <- submit alice do
    exerciseCmd stakingSvc Unstake with
      user = alice
      smusdCid = smusdCid

  -- 7. Alice Bridges to another Canton Domain
  submit alice do
    exerciseCmd bridgeSvc Lock_Musd_For_Bridge with
      user = alice
      musdCid = finalMusd
      targetDomain = "canton-domain-beta"
      targetAddr = "Party::Alice::Target"
      nonce = 101

  return ()

-- | Helper: Convert RelTime to Int (microseconds)
-- FIX C-3: Previous implementation used O(microseconds) loop which is non-terminating
-- for any real duration. Use divRelTime for O(1) conversion.
relToInt : RelTime -> Int
relToInt rt =
  if rt < seconds 0 then 0
  else
    -- Convert to microseconds using divRelTime:
    -- divRelTime rt (microseconds 1) gives number of microseconds in rt
    let totalMicros = divRelTime rt (microseconds 1)
    in totalMicros

-- | Helper: Convert Int to Decimal
intToDecimal : Int -> Decimal
intToDecimal = intToNumeric
